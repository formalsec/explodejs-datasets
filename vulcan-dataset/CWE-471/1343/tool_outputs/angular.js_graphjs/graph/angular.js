const v20970 = function (window) {
    'use strict';
    var minErrConfig = {};
    minErrConfig.objectMaxDepth = 5;
    minErrConfig.urlErrorParamsEnabled = true;
    const errorHandlingConfig = function (config) {
        const v10491 = isObject(config);
        if (v10491) {
            const v10492 = config.objectMaxDepth;
            const v10493 = isDefined(v10492);
            if (v10493) {
                const v10494 = config.objectMaxDepth;
                const v10495 = isValidObjectMaxDepth(v10494);
                const v10496 = config.objectMaxDepth;
                let v10497;
                if (v10495) {
                    v10497 = v10496;
                } else {
                    v10497 = NaN;
                }
                minErrConfig.objectMaxDepth = v10497;
            }
            const v10498 = config.urlErrorParamsEnabled;
            const v10499 = isDefined(v10498);
            const v10500 = config.urlErrorParamsEnabled;
            const v10501 = isBoolean(v10500);
            const v10502 = v10499 && v10501;
            if (v10502) {
                const v10503 = config.urlErrorParamsEnabled;
                minErrConfig.urlErrorParamsEnabled = v10503;
            }
        } else {
            return minErrConfig;
        }
    };
    const isValidObjectMaxDepth = function (maxDepth) {
        const v10504 = isNumber(maxDepth);
        const v10505 = maxDepth > 0;
        const v10506 = v10504 && v10505;
        return v10506;
    };
    const minErr = function (module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        var url = 'https://errors.angularjs.org/1.7.8/';
        const v10507 = url.replace('.', '\\.');
        var regex = v10507 + '[\\s\\S]*';
        var errRegExp = new RegExp(regex, 'g');
        const v10538 = function () {
            var code = arguments[0];
            var template = arguments[1];
            const v10508 = module + ':';
            let v10509;
            if (module) {
                v10509 = v10508;
            } else {
                v10509 = '';
            }
            const v10510 = '[' + v10509;
            const v10511 = v10510 + code;
            var message = v10511 + '] ';
            const v10512 = sliceArgs(arguments, 2);
            const v10515 = function (arg) {
                const v10513 = minErrConfig.objectMaxDepth;
                const v10514 = toDebugString(arg, v10513);
                return v10514;
            };
            var templateArgs = v10512.map(v10515);
            var paramPrefix;
            var i;
            const v10523 = function (match) {
                const v10516 = -1;
                const v10517 = match.slice(1, v10516);
                const v10518 = +v10517;
                var index = v10518;
                const v10519 = templateArgs.length;
                const v10520 = index < v10519;
                if (v10520) {
                    const v10521 = templateArgs[index];
                    const v10522 = v10521.replace(errRegExp, '');
                    return v10522;
                }
                return match;
            };
            message += template.replace(/\{\d+\}/g, v10523);
            const v10524 = '\n' + url;
            const v10525 = module + '/';
            let v10526;
            if (module) {
                v10526 = v10525;
            } else {
                v10526 = '';
            }
            const v10527 = v10524 + v10526;
            message += v10527 + code;
            const v10528 = minErrConfig.urlErrorParamsEnabled;
            if (v10528) {
                (i = 0, paramPrefix = '?')
                const v10529 = templateArgs.length;
                let v10530 = i < v10529;
                while (v10530) {
                    const v10532 = paramPrefix + 'p';
                    const v10533 = v10532 + i;
                    const v10534 = v10533 + '=';
                    const v10535 = templateArgs[i];
                    const v10536 = encodeURIComponent(v10535);
                    message += v10534 + v10536;
                    const v10531 = i++;
                    v10530 = i < v10529;
                }
            }
            const v10537 = new ErrorConstructor(message);
            return v10537;
        };
        return v10538;
    };
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
    var VALIDITY_STATE_PROPERTY = 'validity';
    const v10539 = Object.prototype;
    var hasOwnProperty = v10539.hasOwnProperty;
    var lowercase = function (string) {
        const v10540 = isString(string);
        const v10541 = string.toLowerCase();
        let v10542;
        if (v10540) {
            v10542 = v10541;
        } else {
            v10542 = string;
        }
        return v10542;
    };
    var uppercase = function (string) {
        const v10543 = isString(string);
        const v10544 = string.toUpperCase();
        let v10545;
        if (v10543) {
            v10545 = v10544;
        } else {
            v10545 = string;
        }
        return v10545;
    };
    var msie;
    var jqLite;
    var jQuery;
    const v10546 = [];
    var slice = v10546.slice;
    const v10547 = [];
    var splice = v10547.splice;
    const v10548 = [];
    var push = v10548.push;
    const v10549 = Object.prototype;
    var toString = v10549.toString;
    var getPrototypeOf = Object.getPrototypeOf;
    var ngMinErr = minErr('ng');
    const v10550 = window.angular;
    const v10551 = {};
    var angular = v10550 || (window.angular = v10551);
    var angularModule;
    var uid = 0;
    const v10552 = window.document;
    msie = v10552.documentMode;
    const isArrayLike = function (obj) {
        const v10553 = obj == null;
        const v10554 = isWindow(obj);
        const v10555 = v10553 || v10554;
        if (v10555) {
            return false;
        }
        const v10556 = isArray(obj);
        const v10557 = isString(obj);
        const v10558 = v10556 || v10557;
        const v10559 = obj instanceof jqLite;
        const v10560 = jqLite && v10559;
        const v10561 = v10558 || v10560;
        if (v10561) {
            return true;
        }
        const v10562 = Object(obj);
        const v10563 = 'length' in v10562;
        const v10564 = obj.length;
        var length = v10563 && v10564;
        const v10565 = isNumber(length);
        const v10566 = length >= 0;
        const v10567 = length - 1;
        const v10568 = v10567 in obj;
        const v10569 = v10566 && v10568;
        const v10570 = obj.item;
        const v10571 = typeof v10570;
        const v10572 = v10571 === 'function';
        const v10573 = v10569 || v10572;
        const v10574 = v10565 && v10573;
        return v10574;
    };
    const forEach = function (obj, iterator, context) {
        var key;
        var length;
        if (obj) {
            const v10575 = isFunction(obj);
            if (v10575) {
                for (key in obj) {
                    const v10576 = key !== 'prototype';
                    const v10577 = key !== 'length';
                    const v10578 = v10576 && v10577;
                    const v10579 = key !== 'name';
                    const v10580 = v10578 && v10579;
                    const v10581 = obj.hasOwnProperty(key);
                    const v10582 = v10580 && v10581;
                    if (v10582) {
                        const v10583 = obj[key];
                        const v10584 = iterator.call(context, v10583, key, obj);
                        v10584;
                    }
                }
            } else {
                const v10585 = isArray(obj);
                const v10586 = isArrayLike(obj);
                const v10587 = v10585 || v10586;
                if (v10587) {
                    const v10588 = typeof obj;
                    var isPrimitive = v10588 !== 'object';
                    (key = 0, length = obj.length)
                    let v10589 = key < length;
                    while (v10589) {
                        const v10591 = key in obj;
                        const v10592 = isPrimitive || v10591;
                        if (v10592) {
                            const v10593 = obj[key];
                            const v10594 = iterator.call(context, v10593, key, obj);
                            v10594;
                        }
                        const v10590 = key++;
                        v10589 = key < length;
                    }
                } else {
                    const v10595 = obj.forEach;
                    const v10596 = obj.forEach;
                    const v10597 = v10596 !== forEach;
                    const v10598 = v10595 && v10597;
                    if (v10598) {
                        const v10599 = obj.forEach(iterator, context, obj);
                        v10599;
                    } else {
                        const v10600 = isBlankObject(obj);
                        if (v10600) {
                            for (key in obj) {
                                const v10601 = obj[key];
                                const v10602 = iterator.call(context, v10601, key, obj);
                                v10602;
                            }
                        } else {
                            const v10603 = obj.hasOwnProperty;
                            const v10604 = typeof v10603;
                            const v10605 = v10604 === 'function';
                            if (v10605) {
                                for (key in obj) {
                                    const v10606 = obj.hasOwnProperty(key);
                                    if (v10606) {
                                        const v10607 = obj[key];
                                        const v10608 = iterator.call(context, v10607, key, obj);
                                        v10608;
                                    }
                                }
                            } else {
                                for (key in obj) {
                                    const v10609 = hasOwnProperty.call(obj, key);
                                    if (v10609) {
                                        const v10610 = obj[key];
                                        const v10611 = iterator.call(context, v10610, key, obj);
                                        v10611;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return obj;
    };
    const forEachSorted = function (obj, iterator, context) {
        const v10612 = Object.keys(obj);
        var keys = v10612.sort();
        var i = 0;
        const v10613 = keys.length;
        let v10614 = i < v10613;
        while (v10614) {
            const v10616 = keys[i];
            const v10617 = obj[v10616];
            const v10618 = keys[i];
            const v10619 = iterator.call(context, v10617, v10618);
            v10619;
            const v10615 = i++;
            v10614 = i < v10613;
        }
        return keys;
    };
    const reverseParams = function (iteratorFn) {
        const v10621 = function (value, key) {
            const v10620 = iteratorFn(key, value);
            v10620;
        };
        return v10621;
    };
    const nextUid = function () {
        const v10622 = ++uid;
        return v10622;
    };
    const setHashKey = function (obj, h) {
        if (h) {
            obj.$$hashKey = h;
        } else {
            const v10623 = obj.$$hashKey;
            const v10624 = delete v10623;
            v10624;
        }
    };
    const baseExtend = function (dst, objs, deep) {
        var h = dst.$$hashKey;
        var i = 0;
        var ii = objs.length;
        let v10625 = i < ii;
        while (v10625) {
            var obj = objs[i];
            const v10627 = isObject(obj);
            const v10628 = !v10627;
            const v10629 = isFunction(obj);
            const v10630 = !v10629;
            const v10631 = v10628 && v10630;
            if (v10631) {
                continue;
            }
            var keys = Object.keys(obj);
            var j = 0;
            var jj = keys.length;
            let v10632 = j < jj;
            while (v10632) {
                var key = keys[j];
                var src = obj[key];
                const v10634 = isObject(src);
                const v10635 = deep && v10634;
                if (v10635) {
                    const v10636 = isDate(src);
                    if (v10636) {
                        const v10637 = src.valueOf();
                        dst[key] = new Date(v10637);
                    } else {
                        const v10638 = isRegExp(src);
                        if (v10638) {
                            dst[key] = new RegExp(src);
                        } else {
                            const v10639 = src.nodeName;
                            if (v10639) {
                                const v10640 = src.cloneNode(true);
                                dst[key] = v10640;
                            } else {
                                const v10641 = isElement(src);
                                if (v10641) {
                                    const v10642 = src.clone();
                                    dst[key] = v10642;
                                } else {
                                    const v10643 = dst[key];
                                    const v10644 = isObject(v10643);
                                    const v10645 = !v10644;
                                    if (v10645) {
                                        const v10646 = isArray(src);
                                        const v10647 = [];
                                        const v10648 = {};
                                        let v10649;
                                        if (v10646) {
                                            v10649 = v10647;
                                        } else {
                                            v10649 = v10648;
                                        }
                                        dst[key] = v10649;
                                    }
                                    const v10650 = dst[key];
                                    const v10651 = [src];
                                    const v10652 = baseExtend(v10650, v10651, true);
                                    v10652;
                                }
                            }
                        }
                    }
                } else {
                    dst[key] = src;
                }
                const v10633 = j++;
                v10632 = j < jj;
            }
            const v10626 = ++i;
            v10625 = i < ii;
        }
        const v10653 = setHashKey(dst, h);
        v10653;
        return dst;
    };
    const extend = function (dst) {
        const v10654 = slice.call(arguments, 1);
        const v10655 = baseExtend(dst, v10654, false);
        return v10655;
    };
    const merge = function (dst) {
        const v10656 = slice.call(arguments, 1);
        const v10657 = baseExtend(dst, v10656, true);
        return v10657;
    };
    const toInt = function (str) {
        const v10658 = parseInt(str, 10);
        return v10658;
    };
    const v10659 = Number.isNaN;
    const v10661 = function isNumberNaN(num) {
        const v10660 = num !== num;
        return v10660;
    };
    var isNumberNaN = v10659 || v10661;
    const inherit = function (parent, extra) {
        const v10662 = Object.create(parent);
        const v10663 = extend(v10662, extra);
        return v10663;
    };
    const noop = function () {
    };
    noop.$inject = [];
    const identity = function ($) {
        return $;
    };
    identity.$inject = [];
    const valueFn = function (value) {
        const v10664 = function valueRef() {
            return value;
        };
        return v10664;
    };
    const hasCustomToString = function (obj) {
        const v10665 = obj.toString;
        const v10666 = isFunction(v10665);
        const v10667 = obj.toString;
        const v10668 = v10667 !== toString;
        const v10669 = v10666 && v10668;
        return v10669;
    };
    const isUndefined = function (value) {
        const v10670 = typeof value;
        const v10671 = v10670 === 'undefined';
        return v10671;
    };
    const isDefined = function (value) {
        const v10672 = typeof value;
        const v10673 = v10672 !== 'undefined';
        return v10673;
    };
    const isObject = function (value) {
        const v10674 = value !== null;
        const v10675 = typeof value;
        const v10676 = v10675 === 'object';
        const v10677 = v10674 && v10676;
        return v10677;
    };
    const isBlankObject = function (value) {
        const v10678 = value !== null;
        const v10679 = typeof value;
        const v10680 = v10679 === 'object';
        const v10681 = v10678 && v10680;
        const v10682 = getPrototypeOf(value);
        const v10683 = !v10682;
        const v10684 = v10681 && v10683;
        return v10684;
    };
    const isString = function (value) {
        const v10685 = typeof value;
        const v10686 = v10685 === 'string';
        return v10686;
    };
    const isNumber = function (value) {
        const v10687 = typeof value;
        const v10688 = v10687 === 'number';
        return v10688;
    };
    const isDate = function (value) {
        const v10689 = toString.call(value);
        const v10690 = v10689 === '[object Date]';
        return v10690;
    };
    const isArray = function (arr) {
        const v10691 = Array.isArray(arr);
        const v10692 = arr instanceof Array;
        const v10693 = v10691 || v10692;
        return v10693;
    };
    const isError = function (value) {
        var tag = toString.call(value);
        switch (tag) {
        case '[object Error]':
            return true;
        case '[object Exception]':
            return true;
        case '[object DOMException]':
            return true;
        default:
            const v10694 = value instanceof Error;
            return v10694;
        }
    };
    const isFunction = function (value) {
        const v10695 = typeof value;
        const v10696 = v10695 === 'function';
        return v10696;
    };
    const isRegExp = function (value) {
        const v10697 = toString.call(value);
        const v10698 = v10697 === '[object RegExp]';
        return v10698;
    };
    const isWindow = function (obj) {
        const v10699 = obj.window;
        const v10700 = v10699 === obj;
        const v10701 = obj && v10700;
        return v10701;
    };
    const isScope = function (obj) {
        const v10702 = obj.$evalAsync;
        const v10703 = obj && v10702;
        const v10704 = obj.$watch;
        const v10705 = v10703 && v10704;
        return v10705;
    };
    const isFile = function (obj) {
        const v10706 = toString.call(obj);
        const v10707 = v10706 === '[object File]';
        return v10707;
    };
    const isFormData = function (obj) {
        const v10708 = toString.call(obj);
        const v10709 = v10708 === '[object FormData]';
        return v10709;
    };
    const isBlob = function (obj) {
        const v10710 = toString.call(obj);
        const v10711 = v10710 === '[object Blob]';
        return v10711;
    };
    const isBoolean = function (value) {
        const v10712 = typeof value;
        const v10713 = v10712 === 'boolean';
        return v10713;
    };
    const isPromiseLike = function (obj) {
        const v10714 = obj.then;
        const v10715 = isFunction(v10714);
        const v10716 = obj && v10715;
        return v10716;
    };
    var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/;
    const isTypedArray = function (value) {
        const v10717 = value.length;
        const v10718 = isNumber(v10717);
        const v10719 = value && v10718;
        const v10720 = toString.call(value);
        const v10721 = TYPED_ARRAY_REGEXP.test(v10720);
        const v10722 = v10719 && v10721;
        return v10722;
    };
    const isArrayBuffer = function (obj) {
        const v10723 = toString.call(obj);
        const v10724 = v10723 === '[object ArrayBuffer]';
        return v10724;
    };
    var trim = function (value) {
        const v10725 = isString(value);
        const v10726 = value.trim();
        let v10727;
        if (v10725) {
            v10727 = v10726;
        } else {
            v10727 = value;
        }
        return v10727;
    };
    var escapeForRegexp = function (s) {
        const v10728 = s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, '\\$1');
        const v10729 = v10728.replace(/\x08/g, '\\x08');
        return v10729;
    };
    const isElement = function (node) {
        const v10730 = node.nodeName;
        const v10731 = node.prop;
        const v10732 = node.attr;
        const v10733 = v10731 && v10732;
        const v10734 = node.find;
        const v10735 = v10733 && v10734;
        const v10736 = v10730 || v10735;
        const v10737 = node && v10736;
        const v10738 = !v10737;
        const v10739 = !v10738;
        return v10739;
    };
    const makeMap = function (str) {
        var obj = {};
        var items = str.split(',');
        var i;
        (i = 0)
        const v10740 = items.length;
        let v10741 = i < v10740;
        while (v10741) {
            const v10743 = items[i];
            obj[v10743] = true;
            const v10742 = i++;
            v10741 = i < v10740;
        }
        return obj;
    };
    const nodeName_ = function (element) {
        const v10744 = element.nodeName;
        const v10745 = element[0];
        const v10746 = element[0];
        const v10747 = v10746.nodeName;
        const v10748 = v10745 && v10747;
        const v10749 = v10744 || v10748;
        const v10750 = lowercase(v10749);
        return v10750;
    };
    const includes = function (array, obj) {
        const v10751 = Array.prototype;
        const v10752 = v10751.indexOf;
        const v10753 = v10752.call(array, obj);
        const v10754 = -1;
        const v10755 = v10753 !== v10754;
        return v10755;
    };
    const arrayRemove = function (array, value) {
        var index = array.indexOf(value);
        const v10756 = index >= 0;
        if (v10756) {
            const v10757 = array.splice(index, 1);
            v10757;
        }
        return index;
    };
    const copy = function (source, destination, maxDepth) {
        var stackSource = [];
        var stackDest = [];
        const v10758 = isValidObjectMaxDepth(maxDepth);
        if (v10758) {
            maxDepth = maxDepth;
        } else {
            maxDepth = NaN;
        }
        if (destination) {
            const v10759 = isTypedArray(destination);
            const v10760 = isArrayBuffer(destination);
            const v10761 = v10759 || v10760;
            if (v10761) {
                const v10762 = ngMinErr('cpta', 'Can\'t copy! TypedArray destination cannot be mutated.');
                throw v10762;
            }
            const v10763 = source === destination;
            if (v10763) {
                const v10764 = ngMinErr('cpi', 'Can\'t copy! Source and destination are identical.');
                throw v10764;
            }
            const v10765 = isArray(destination);
            if (v10765) {
                destination.length = 0;
            } else {
                const v10769 = function (value, key) {
                    const v10766 = key !== '$$hashKey';
                    if (v10766) {
                        const v10767 = destination[key];
                        const v10768 = delete v10767;
                        v10768;
                    }
                };
                const v10770 = forEach(destination, v10769);
                v10770;
            }
            const v10771 = stackSource.push(source);
            v10771;
            const v10772 = stackDest.push(destination);
            v10772;
            const v10773 = copyRecurse(source, destination, maxDepth);
            return v10773;
        }
        const v10774 = copyElement(source, maxDepth);
        return v10774;
        const copyRecurse = function (source, destination, maxDepth) {
            const v10775 = maxDepth--;
            v10775;
            const v10776 = maxDepth < 0;
            if (v10776) {
                return '...';
            }
            var h = destination.$$hashKey;
            var key;
            const v10777 = isArray(source);
            if (v10777) {
                var i = 0;
                var ii = source.length;
                let v10778 = i < ii;
                while (v10778) {
                    const v10780 = source[i];
                    const v10781 = copyElement(v10780, maxDepth);
                    const v10782 = destination.push(v10781);
                    v10782;
                    const v10779 = i++;
                    v10778 = i < ii;
                }
            } else {
                const v10783 = isBlankObject(source);
                if (v10783) {
                    for (key in source) {
                        const v10784 = source[key];
                        const v10785 = copyElement(v10784, maxDepth);
                        destination[key] = v10785;
                    }
                } else {
                    const v10786 = source.hasOwnProperty;
                    const v10787 = typeof v10786;
                    const v10788 = v10787 === 'function';
                    const v10789 = source && v10788;
                    if (v10789) {
                        for (key in source) {
                            const v10790 = source.hasOwnProperty(key);
                            if (v10790) {
                                const v10791 = source[key];
                                const v10792 = copyElement(v10791, maxDepth);
                                destination[key] = v10792;
                            }
                        }
                    } else {
                        for (key in source) {
                            const v10793 = hasOwnProperty.call(source, key);
                            if (v10793) {
                                const v10794 = source[key];
                                const v10795 = copyElement(v10794, maxDepth);
                                destination[key] = v10795;
                            }
                        }
                    }
                }
            }
            const v10796 = setHashKey(destination, h);
            v10796;
            return destination;
        };
        const copyElement = function (source, maxDepth) {
            const v10797 = isObject(source);
            const v10798 = !v10797;
            if (v10798) {
                return source;
            }
            var index = stackSource.indexOf(source);
            const v10799 = -1;
            const v10800 = index !== v10799;
            if (v10800) {
                const v10801 = stackDest[index];
                return v10801;
            }
            const v10802 = isWindow(source);
            const v10803 = isScope(source);
            const v10804 = v10802 || v10803;
            if (v10804) {
                const v10805 = ngMinErr('cpws', 'Can\'t copy! Making copies of Window or Scope instances is not supported.');
                throw v10805;
            }
            var needsRecurse = false;
            var destination = copyType(source);
            const v10806 = destination === undefined;
            if (v10806) {
                const v10807 = isArray(source);
                const v10808 = [];
                const v10809 = getPrototypeOf(source);
                const v10810 = Object.create(v10809);
                if (v10807) {
                    destination = v10808;
                } else {
                    destination = v10810;
                }
                needsRecurse = true;
            }
            const v10811 = stackSource.push(source);
            v10811;
            const v10812 = stackDest.push(destination);
            v10812;
            const v10813 = copyRecurse(source, destination, maxDepth);
            let v10814;
            if (needsRecurse) {
                v10814 = v10813;
            } else {
                v10814 = destination;
            }
            return v10814;
        };
        const copyType = function (source) {
            const v10815 = toString.call(source);
            switch (v10815) {
            case '[object Int8Array]':
            case '[object Int16Array]':
            case '[object Int32Array]':
            case '[object Float32Array]':
            case '[object Float64Array]':
            case '[object Uint8Array]':
            case '[object Uint8ClampedArray]':
            case '[object Uint16Array]':
            case '[object Uint32Array]':
                const v10816 = source.buffer;
                const v10817 = copyElement(v10816);
                const v10818 = source.byteOffset;
                const v10819 = source.length;
                const v10820 = new source.constructor(v10817, v10818, v10819);
                return v10820;
            case '[object ArrayBuffer]':
                const v10821 = source.slice;
                const v10822 = !v10821;
                if (v10822) {
                    const v10823 = source.byteLength;
                    var copied = new ArrayBuffer(v10823);
                    const v10824 = new Uint8Array(copied);
                    const v10825 = new Uint8Array(source);
                    const v10826 = v10824.set(v10825);
                    v10826;
                    return copied;
                }
                const v10827 = source.slice(0);
                return v10827;
            case '[object Boolean]':
            case '[object Number]':
            case '[object String]':
            case '[object Date]':
                const v10828 = source.valueOf();
                const v10829 = new source.constructor(v10828);
                return v10829;
            case '[object RegExp]':
                const v10830 = source.source;
                const v10831 = source.toString();
                const v10832 = v10831.match(/[^/]*$/);
                const v10833 = v10832[0];
                var re = new RegExp(v10830, v10833);
                const v10834 = source.lastIndex;
                re.lastIndex = v10834;
                return re;
            case '[object Blob]':
                const v10835 = [source];
                const v10836 = source.type;
                const v10837 = { type: v10836 };
                const v10838 = new source.constructor(v10835, v10837);
                return v10838;
            }
            const v10839 = source.cloneNode;
            const v10840 = isFunction(v10839);
            if (v10840) {
                const v10841 = source.cloneNode(true);
                return v10841;
            }
        };
    };
    const simpleCompare = function (a, b) {
        const v10842 = a === b;
        const v10843 = a !== a;
        const v10844 = b !== b;
        const v10845 = v10843 && v10844;
        const v10846 = v10842 || v10845;
        return v10846;
    };
    const equals = function (o1, o2) {
        const v10847 = o1 === o2;
        if (v10847) {
            return true;
        }
        const v10848 = o1 === null;
        const v10849 = o2 === null;
        const v10850 = v10848 || v10849;
        if (v10850) {
            return false;
        }
        const v10851 = o1 !== o1;
        const v10852 = o2 !== o2;
        const v10853 = v10851 && v10852;
        if (v10853) {
            return true;
        }
        const v10854 = typeof o1;
        var t1 = v10854;
        const v10855 = typeof o2;
        var t2 = v10855;
        var length;
        var key;
        var keySet;
        const v10856 = t1 === t2;
        const v10857 = t1 === 'object';
        const v10858 = v10856 && v10857;
        if (v10858) {
            const v10859 = isArray(o1);
            if (v10859) {
                const v10860 = isArray(o2);
                const v10861 = !v10860;
                if (v10861) {
                    return false;
                }
                const v10862 = o2.length;
                const v10863 = (length = o1.length) === v10862;
                if (v10863) {
                    key = 0
                    let v10864 = key < length;
                    while (v10864) {
                        const v10866 = o1[key];
                        const v10867 = o2[key];
                        const v10868 = equals(v10866, v10867);
                        const v10869 = !v10868;
                        if (v10869) {
                            return false;
                        }
                        const v10865 = key++;
                        v10864 = key < length;
                    }
                    return true;
                }
            } else {
                const v10870 = isDate(o1);
                if (v10870) {
                    const v10871 = isDate(o2);
                    const v10872 = !v10871;
                    if (v10872) {
                        return false;
                    }
                    const v10873 = o1.getTime();
                    const v10874 = o2.getTime();
                    const v10875 = simpleCompare(v10873, v10874);
                    return v10875;
                } else {
                    const v10876 = isRegExp(o1);
                    if (v10876) {
                        const v10877 = isRegExp(o2);
                        const v10878 = !v10877;
                        if (v10878) {
                            return false;
                        }
                        const v10879 = o1.toString();
                        const v10880 = o2.toString();
                        const v10881 = v10879 === v10880;
                        return v10881;
                    } else {
                        const v10882 = isScope(o1);
                        const v10883 = isScope(o2);
                        const v10884 = v10882 || v10883;
                        const v10885 = isWindow(o1);
                        const v10886 = v10884 || v10885;
                        const v10887 = isWindow(o2);
                        const v10888 = v10886 || v10887;
                        const v10889 = isArray(o2);
                        const v10890 = v10888 || v10889;
                        const v10891 = isDate(o2);
                        const v10892 = v10890 || v10891;
                        const v10893 = isRegExp(o2);
                        const v10894 = v10892 || v10893;
                        if (v10894) {
                            return false;
                        }
                        keySet = createMap();
                        for (key in o1) {
                            const v10895 = key.charAt(0);
                            const v10896 = v10895 === '$';
                            const v10897 = o1[key];
                            const v10898 = isFunction(v10897);
                            const v10899 = v10896 || v10898;
                            if (v10899) {
                                continue;
                            }
                            const v10900 = o1[key];
                            const v10901 = o2[key];
                            const v10902 = equals(v10900, v10901);
                            const v10903 = !v10902;
                            if (v10903) {
                                return false;
                            }
                            keySet[key] = true;
                        }
                        for (key in o2) {
                            const v10904 = key in keySet;
                            const v10905 = !v10904;
                            const v10906 = key.charAt(0);
                            const v10907 = v10906 !== '$';
                            const v10908 = v10905 && v10907;
                            const v10909 = o2[key];
                            const v10910 = isDefined(v10909);
                            const v10911 = v10908 && v10910;
                            const v10912 = o2[key];
                            const v10913 = isFunction(v10912);
                            const v10914 = !v10913;
                            const v10915 = v10911 && v10914;
                            if (v10915) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
            }
        }
        return false;
    };
    var csp = function () {
        const v10916 = csp.rules;
        const v10917 = isDefined(v10916);
        const v10918 = !v10917;
        if (v10918) {
            const v10919 = window.document;
            const v10920 = v10919.querySelector('[ng-csp]');
            const v10921 = window.document;
            const v10922 = v10921.querySelector('[data-ng-csp]');
            var ngCspElement = v10920 || v10922;
            if (ngCspElement) {
                const v10923 = ngCspElement.getAttribute('ng-csp');
                const v10924 = ngCspElement.getAttribute('data-ng-csp');
                var ngCspAttribute = v10923 || v10924;
                const v10925 = !ngCspAttribute;
                const v10926 = ngCspAttribute.indexOf('no-unsafe-eval');
                const v10927 = -1;
                const v10928 = v10926 !== v10927;
                const v10929 = v10925 || v10928;
                const v10930 = !ngCspAttribute;
                const v10931 = ngCspAttribute.indexOf('no-inline-style');
                const v10932 = -1;
                const v10933 = v10931 !== v10932;
                const v10934 = v10930 || v10933;
                const v10935 = {};
                v10935.noUnsafeEval = v10929;
                v10935.noInlineStyle = v10934;
                csp.rules = v10935;
            } else {
                const v10936 = noUnsafeEval();
                const v10937 = {};
                v10937.noUnsafeEval = v10936;
                v10937.noInlineStyle = false;
                csp.rules = v10937;
            }
        }
        const v10938 = csp.rules;
        return v10938;
        const noUnsafeEval = function () {
            try {
                const v10939 = new Function('');
                v10939;
                return false;
            } catch (e) {
                return true;
            }
        };
    };
    var jq = function () {
        const v10940 = jq.name_;
        const v10941 = isDefined(v10940);
        if (v10941) {
            const v10942 = jq.name_;
            return v10942;
        }
        var el;
        var i;
        var ii = ngAttrPrefixes.length;
        var prefix;
        var name;
        (i = 0)
        let v10943 = i < ii;
        while (v10943) {
            prefix = ngAttrPrefixes[i];
            const v10945 = window.document;
            const v10946 = prefix.replace(':', '\\:');
            const v10947 = '[' + v10946;
            const v10948 = v10947 + 'jq]';
            el = v10945.querySelector(v10948);
            if (el) {
                const v10949 = prefix + 'jq';
                name = el.getAttribute(v10949);
                break;
            }
            const v10944 = ++i;
            v10943 = i < ii;
        }
        return jq.name_ = name;
    };
    const concat = function (array1, array2, index) {
        const v10950 = slice.call(array2, index);
        const v10951 = array1.concat(v10950);
        return v10951;
    };
    const sliceArgs = function (args, startIndex) {
        const v10952 = startIndex || 0;
        const v10953 = slice.call(args, v10952);
        return v10953;
    };
    const bind = function (self, fn) {
        let curryArgs;
        const v10954 = arguments.length;
        const v10955 = v10954 > 2;
        const v10956 = sliceArgs(arguments, 2);
        const v10957 = [];
        if (v10955) {
            curryArgs = v10956;
        } else {
            curryArgs = v10957;
        }
        const v10958 = isFunction(fn);
        const v10959 = fn instanceof RegExp;
        const v10960 = !v10959;
        const v10961 = v10958 && v10960;
        if (v10961) {
            const v10962 = curryArgs.length;
            const v10968 = function () {
                const v10963 = arguments.length;
                const v10964 = concat(curryArgs, arguments, 0);
                const v10965 = fn.apply(self, v10964);
                const v10966 = fn.apply(self, curryArgs);
                let v10967;
                if (v10963) {
                    v10967 = v10965;
                } else {
                    v10967 = v10966;
                }
                return v10967;
            };
            const v10973 = function () {
                const v10969 = arguments.length;
                const v10970 = fn.apply(self, arguments);
                const v10971 = fn.call(self);
                let v10972;
                if (v10969) {
                    v10972 = v10970;
                } else {
                    v10972 = v10971;
                }
                return v10972;
            };
            let v10974;
            if (v10962) {
                v10974 = v10968;
            } else {
                v10974 = v10973;
            }
            return v10974;
        } else {
            return fn;
        }
    };
    const toJsonReplacer = function (key, value) {
        var val = value;
        const v10975 = typeof key;
        const v10976 = v10975 === 'string';
        const v10977 = key.charAt(0);
        const v10978 = v10977 === '$';
        const v10979 = v10976 && v10978;
        const v10980 = key.charAt(1);
        const v10981 = v10980 === '$';
        const v10982 = v10979 && v10981;
        if (v10982) {
            val = undefined;
        } else {
            const v10983 = isWindow(value);
            if (v10983) {
                val = '$WINDOW';
            } else {
                const v10984 = window.document;
                const v10985 = v10984 === value;
                const v10986 = value && v10985;
                if (v10986) {
                    val = '$DOCUMENT';
                } else {
                    const v10987 = isScope(value);
                    if (v10987) {
                        val = '$SCOPE';
                    }
                }
            }
        }
        return val;
    };
    const toJson = function (obj, pretty) {
        const v10988 = isUndefined(obj);
        if (v10988) {
            return undefined;
        }
        const v10989 = isNumber(pretty);
        const v10990 = !v10989;
        if (v10990) {
            if (pretty) {
                pretty = 2;
            } else {
                pretty = null;
            }
        }
        const v10991 = JSON.stringify(obj, toJsonReplacer, pretty);
        return v10991;
    };
    const fromJson = function (json) {
        const v10992 = isString(json);
        const v10993 = JSON.parse(json);
        let v10994;
        if (v10992) {
            v10994 = v10993;
        } else {
            v10994 = json;
        }
        return v10994;
    };
    var ALL_COLONS = /:/g;
    const timezoneToOffset = function (timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, '');
        const v10995 = 'Jan 01, 1970 00:00:00 ' + timezone;
        const v10996 = Date.parse(v10995);
        var requestedTimezoneOffset = v10996 / 60000;
        const v10997 = isNumberNaN(requestedTimezoneOffset);
        let v10998;
        if (v10997) {
            v10998 = fallback;
        } else {
            v10998 = requestedTimezoneOffset;
        }
        return v10998;
    };
    const addDateMinutes = function (date, minutes) {
        const v10999 = date.getTime();
        date = new Date(v10999);
        const v11000 = date.getMinutes();
        const v11001 = v11000 + minutes;
        const v11002 = date.setMinutes(v11001);
        v11002;
        return date;
    };
    const convertTimezoneToLocal = function (date, timezone, reverse) {
        const v11003 = -1;
        if (reverse) {
            reverse = v11003;
        } else {
            reverse = 1;
        }
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        const v11004 = timezoneOffset - dateTimezoneOffset;
        const v11005 = reverse * v11004;
        const v11006 = addDateMinutes(date, v11005);
        return v11006;
    };
    const startingTag = function (element) {
        const v11007 = jqLite(element);
        const v11008 = v11007.clone();
        element = v11008.empty();
        const v11009 = jqLite('<div></div>');
        const v11010 = v11009.append(element);
        var elemHtml = v11010.html();
        try {
            const v11011 = element[0];
            const v11012 = v11011.nodeType;
            const v11013 = v11012 === NODE_TYPE_TEXT;
            const v11014 = lowercase(elemHtml);
            const v11015 = elemHtml.match(/^(<[^>]+>)/);
            const v11016 = v11015[1];
            const v11019 = function (match, nodeName) {
                const v11017 = lowercase(nodeName);
                const v11018 = '<' + v11017;
                return v11018;
            };
            const v11020 = v11016.replace(/^<([\w-]+)/, v11019);
            let v11021;
            if (v11013) {
                v11021 = v11014;
            } else {
                v11021 = v11020;
            }
            return v11021;
        } catch (e) {
            const v11022 = lowercase(elemHtml);
            return v11022;
        }
    };
    const tryDecodeURIComponent = function (value) {
        try {
            const v11023 = decodeURIComponent(value);
            return v11023;
        } catch (e) {
        }
    };
    const parseKeyValue = function (keyValue) {
        var obj = {};
        const v11024 = keyValue || '';
        const v11025 = v11024.split('&');
        const v11039 = function (keyValue) {
            var splitPoint;
            var key;
            var val;
            if (keyValue) {
                keyValue = keyValue.replace(/\+/g, '%20');
                key = keyValue;
                splitPoint = keyValue.indexOf('=');
                const v11026 = -1;
                const v11027 = splitPoint !== v11026;
                if (v11027) {
                    key = keyValue.substring(0, splitPoint);
                    const v11028 = splitPoint + 1;
                    val = keyValue.substring(v11028);
                }
                key = tryDecodeURIComponent(key);
                const v11029 = isDefined(key);
                if (v11029) {
                    const v11030 = isDefined(val);
                    const v11031 = tryDecodeURIComponent(val);
                    if (v11030) {
                        val = v11031;
                    } else {
                        val = true;
                    }
                    const v11032 = hasOwnProperty.call(obj, key);
                    const v11033 = !v11032;
                    if (v11033) {
                        obj[key] = val;
                    } else {
                        const v11034 = obj[key];
                        const v11035 = isArray(v11034);
                        if (v11035) {
                            const v11036 = obj[key];
                            const v11037 = v11036.push(val);
                            v11037;
                        } else {
                            const v11038 = obj[key];
                            obj[key] = [
                                v11038,
                                val
                            ];
                        }
                    }
                }
            }
        };
        const v11040 = forEach(v11025, v11039);
        v11040;
        return obj;
    };
    const toKeyValue = function (obj) {
        var parts = [];
        const v11058 = function (value, key) {
            const v11041 = isArray(value);
            if (v11041) {
                const v11049 = function (arrayValue) {
                    const v11042 = encodeUriQuery(key, true);
                    const v11043 = arrayValue === true;
                    const v11044 = encodeUriQuery(arrayValue, true);
                    const v11045 = '=' + v11044;
                    let v11046;
                    if (v11043) {
                        v11046 = '';
                    } else {
                        v11046 = v11045;
                    }
                    const v11047 = v11042 + v11046;
                    const v11048 = parts.push(v11047);
                    v11048;
                };
                const v11050 = forEach(value, v11049);
                v11050;
            } else {
                const v11051 = encodeUriQuery(key, true);
                const v11052 = value === true;
                const v11053 = encodeUriQuery(value, true);
                const v11054 = '=' + v11053;
                let v11055;
                if (v11052) {
                    v11055 = '';
                } else {
                    v11055 = v11054;
                }
                const v11056 = v11051 + v11055;
                const v11057 = parts.push(v11056);
                v11057;
            }
        };
        const v11059 = forEach(obj, v11058);
        v11059;
        const v11060 = parts.length;
        const v11061 = parts.join('&');
        let v11062;
        if (v11060) {
            v11062 = v11061;
        } else {
            v11062 = '';
        }
        return v11062;
    };
    const encodeUriSegment = function (val) {
        const v11063 = encodeUriQuery(val, true);
        const v11064 = v11063.replace(/%26/gi, '&');
        const v11065 = v11064.replace(/%3D/gi, '=');
        const v11066 = v11065.replace(/%2B/gi, '+');
        return v11066;
    };
    const encodeUriQuery = function (val, pctEncodeSpaces) {
        const v11067 = encodeURIComponent(val);
        const v11068 = v11067.replace(/%40/gi, '@');
        const v11069 = v11068.replace(/%3A/gi, ':');
        const v11070 = v11069.replace(/%24/g, '$');
        const v11071 = v11070.replace(/%2C/gi, ',');
        const v11072 = v11071.replace(/%3B/gi, ';');
        let v11073;
        if (pctEncodeSpaces) {
            v11073 = '%20';
        } else {
            v11073 = '+';
        }
        const v11074 = v11072.replace(/%20/g, v11073);
        return v11074;
    };
    var ngAttrPrefixes = [
        'ng-',
        'data-ng-',
        'ng:',
        'x-ng-'
    ];
    const getNgAttribute = function (element, ngAttr) {
        var attr;
        var i;
        var ii = ngAttrPrefixes.length;
        (i = 0)
        let v11075 = i < ii;
        while (v11075) {
            const v11077 = ngAttrPrefixes[i];
            attr = v11077 + ngAttr;
            const v11078 = isString(attr = element.getAttribute(attr));
            if (v11078) {
                return attr;
            }
            const v11076 = ++i;
            v11075 = i < ii;
        }
        return null;
    };
    const allowAutoBootstrap = function (document) {
        var script = document.currentScript;
        const v11079 = !script;
        if (v11079) {
            return true;
        }
        const v11080 = window.HTMLScriptElement;
        const v11081 = script instanceof v11080;
        const v11082 = window.SVGScriptElement;
        const v11083 = script instanceof v11082;
        const v11084 = v11081 || v11083;
        const v11085 = !v11084;
        if (v11085) {
            return false;
        }
        var attributes = script.attributes;
        const v11086 = attributes.getNamedItem('src');
        const v11087 = attributes.getNamedItem('href');
        const v11088 = attributes.getNamedItem('xlink:href');
        var srcs = [
            v11086,
            v11087,
            v11088
        ];
        const v11098 = function (src) {
            const v11089 = !src;
            if (v11089) {
                return true;
            }
            const v11090 = src.value;
            const v11091 = !v11090;
            if (v11091) {
                return false;
            }
            var link = document.createElement('a');
            const v11092 = src.value;
            link.href = v11092;
            const v11093 = document.location;
            const v11094 = v11093.origin;
            const v11095 = link.origin;
            const v11096 = v11094 === v11095;
            if (v11096) {
                return true;
            }
            const v11097 = link.protocol;
            switch (v11097) {
            case 'http:':
            case 'https:':
            case 'ftp:':
            case 'blob:':
            case 'file:':
            case 'data:':
                return true;
            default:
                return false;
            }
        };
        const v11099 = srcs.every(v11098);
        return v11099;
    };
    const v11100 = window.document;
    var isAutoBootstrapAllowed = allowAutoBootstrap(v11100);
    const angularInit = function (element, bootstrap) {
        var appElement;
        var module;
        var config = {};
        const v11106 = function (prefix) {
            var name = prefix + 'app';
            const v11101 = !appElement;
            const v11102 = element.hasAttribute;
            const v11103 = v11101 && v11102;
            const v11104 = element.hasAttribute(name);
            const v11105 = v11103 && v11104;
            if (v11105) {
                appElement = element;
                module = element.getAttribute(name);
            }
        };
        const v11107 = forEach(ngAttrPrefixes, v11106);
        v11107;
        const v11113 = function (prefix) {
            var name = prefix + 'app';
            var candidate;
            const v11108 = !appElement;
            const v11109 = name.replace(':', '\\:');
            const v11110 = '[' + v11109;
            const v11111 = v11110 + ']';
            const v11112 = v11108 && (candidate = element.querySelector(v11111));
            if (v11112) {
                appElement = candidate;
                module = candidate.getAttribute(name);
            }
        };
        const v11114 = forEach(ngAttrPrefixes, v11113);
        v11114;
        if (appElement) {
            const v11115 = !isAutoBootstrapAllowed;
            if (v11115) {
                const v11116 = window.console;
                const v11117 = 'AngularJS: disabling automatic bootstrap. <script> protocol indicates ' + 'an extension, document.location.href does not match.';
                const v11118 = v11116.error(v11117);
                v11118;
                return;
            }
            const v11119 = getNgAttribute(appElement, 'strict-di');
            config.strictDi = v11119 !== null;
            const v11120 = [module];
            const v11121 = [];
            let v11122;
            if (module) {
                v11122 = v11120;
            } else {
                v11122 = v11121;
            }
            const v11123 = bootstrap(appElement, v11122, config);
            v11123;
        }
    };
    const bootstrap = function (element, modules, config) {
        const v11124 = isObject(config);
        const v11125 = !v11124;
        if (v11125) {
            config = {};
        }
        var defaultConfig = {};
        defaultConfig.strictDi = false;
        config = extend(defaultConfig, config);
        var doBootstrap = function () {
            element = jqLite(element);
            const v11126 = element.injector();
            if (v11126) {
                let tag;
                const v11127 = element[0];
                const v11128 = window.document;
                const v11129 = v11127 === v11128;
                const v11130 = startingTag(element);
                if (v11129) {
                    tag = 'document';
                } else {
                    tag = v11130;
                }
                const v11131 = tag.replace(/</, '&lt;');
                const v11132 = v11131.replace(/>/, '&gt;');
                const v11133 = ngMinErr('btstrpd', 'App already bootstrapped with this element \'{0}\'', v11132);
                throw v11133;
            }
            const v11134 = [];
            modules = modules || v11134;
            const v11136 = function ($provide) {
                const v11135 = $provide.value('$rootElement', element);
                v11135;
            };
            const v11137 = [
                '$provide',
                v11136
            ];
            const v11138 = modules.unshift(v11137);
            v11138;
            const v11139 = config.debugInfoEnabled;
            if (v11139) {
                const v11141 = function ($compileProvider) {
                    const v11140 = $compileProvider.debugInfoEnabled(true);
                    v11140;
                };
                const v11142 = [
                    '$compileProvider',
                    v11141
                ];
                const v11143 = modules.push(v11142);
                v11143;
            }
            const v11144 = modules.unshift('ng');
            v11144;
            const v11145 = config.strictDi;
            var injector = createInjector(modules, v11145);
            const v11151 = function bootstrapApply(scope, element, compile, injector) {
                const v11149 = function () {
                    const v11146 = element.data('$injector', injector);
                    v11146;
                    const v11147 = compile(element);
                    const v11148 = v11147(scope);
                    v11148;
                };
                const v11150 = scope.$apply(v11149);
                v11150;
            };
            const v11152 = [
                '$rootScope',
                '$rootElement',
                '$compile',
                '$injector',
                v11151
            ];
            const v11153 = injector.invoke(v11152);
            v11153;
            return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        const v11154 = window.name;
        const v11155 = NG_ENABLE_DEBUG_INFO.test(v11154);
        const v11156 = window && v11155;
        if (v11156) {
            config.debugInfoEnabled = true;
            const v11157 = window.name;
            const v11158 = v11157.replace(NG_ENABLE_DEBUG_INFO, '');
            window.name = v11158;
        }
        const v11159 = window.name;
        const v11160 = NG_DEFER_BOOTSTRAP.test(v11159);
        const v11161 = !v11160;
        const v11162 = window && v11161;
        if (v11162) {
            const v11163 = doBootstrap();
            return v11163;
        }
        const v11164 = window.name;
        const v11165 = v11164.replace(NG_DEFER_BOOTSTRAP, '');
        window.name = v11165;
        const v11170 = function (extraModules) {
            const v11167 = function (module) {
                const v11166 = modules.push(module);
                v11166;
            };
            const v11168 = forEach(extraModules, v11167);
            v11168;
            const v11169 = doBootstrap();
            return v11169;
        };
        angular.resumeBootstrap = v11170;
        const v11171 = angular.resumeDeferredBootstrap;
        const v11172 = isFunction(v11171);
        if (v11172) {
            const v11173 = angular.resumeDeferredBootstrap();
            v11173;
        }
    };
    const reloadWithDebugInfo = function () {
        const v11174 = window.name;
        window.name = 'NG_ENABLE_DEBUG_INFO!' + v11174;
        const v11175 = window.location;
        const v11176 = v11175.reload();
        v11176;
    };
    const getTestability = function (rootElement) {
        const v11177 = angular.element(rootElement);
        var injector = v11177.injector();
        const v11178 = !injector;
        if (v11178) {
            const v11179 = ngMinErr('test', 'no injector found for element argument to getTestability');
            throw v11179;
        }
        const v11180 = injector.get('$$testability');
        return v11180;
    };
    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    const snake_case = function (name, separator) {
        separator = separator || '_';
        const v11184 = function (letter, pos) {
            let v11181;
            if (pos) {
                v11181 = separator;
            } else {
                v11181 = '';
            }
            const v11182 = letter.toLowerCase();
            const v11183 = v11181 + v11182;
            return v11183;
        };
        const v11185 = name.replace(SNAKE_CASE_REGEXP, v11184);
        return v11185;
    };
    var bindJQueryFired = false;
    const bindJQuery = function () {
        var originalCleanData;
        if (bindJQueryFired) {
            return;
        }
        var jqName = jq();
        const v11186 = isUndefined(jqName);
        const v11187 = window.jQuery;
        const v11188 = !jqName;
        const v11189 = window[jqName];
        let v11190;
        if (v11188) {
            v11190 = undefined;
        } else {
            v11190 = v11189;
        }
        if (v11186) {
            jQuery = v11187;
        } else {
            jQuery = v11190;
        }
        const v11191 = jQuery.fn;
        const v11192 = v11191.on;
        const v11193 = jQuery && v11192;
        if (v11193) {
            jqLite = jQuery;
            const v11194 = jQuery.fn;
            const v11195 = JQLitePrototype.scope;
            const v11196 = JQLitePrototype.isolateScope;
            const v11197 = JQLitePrototype.controller;
            const v11198 = JQLitePrototype.injector;
            const v11199 = JQLitePrototype.inheritedData;
            const v11200 = {
                scope: v11195,
                isolateScope: v11196,
                controller: v11197,
                injector: v11198,
                inheritedData: v11199
            };
            const v11201 = extend(v11194, v11200);
            v11201;
        } else {
            jqLite = JQLite;
        }
        originalCleanData = jqLite.cleanData;
        const v11212 = function (elems) {
            var events;
            var i = 0;
            var elem;
            let v11202 = (elem = elems[i]) != null;
            while (v11202) {
                const v11204 = jqLite._data(elem);
                const v11205 = {};
                const v11206 = v11204 || v11205;
                events = v11206.events;
                const v11207 = events.$destroy;
                const v11208 = events && v11207;
                if (v11208) {
                    const v11209 = jqLite(elem);
                    const v11210 = v11209.triggerHandler('$destroy');
                    v11210;
                }
                const v11203 = i++;
                v11202 = (elem = elems[i]) != null;
            }
            const v11211 = originalCleanData(elems);
            v11211;
        };
        jqLite.cleanData = v11212;
        angular.element = jqLite;
        bindJQueryFired = true;
    };
    const assertArg = function (arg, name, reason) {
        const v11213 = !arg;
        if (v11213) {
            const v11214 = name || '?';
            const v11215 = reason || 'required';
            const v11216 = ngMinErr('areq', 'Argument \'{0}\' is {1}', v11214, v11215);
            throw v11216;
        }
        return arg;
    };
    const assertArgFn = function (arg, name, acceptArrayAnnotation) {
        const v11217 = isArray(arg);
        const v11218 = acceptArrayAnnotation && v11217;
        if (v11218) {
            const v11219 = arg.length;
            const v11220 = v11219 - 1;
            arg = arg[v11220];
        }
        const v11221 = isFunction(arg);
        const v11222 = typeof arg;
        const v11223 = v11222 === 'object';
        const v11224 = arg && v11223;
        const v11225 = arg.constructor;
        const v11226 = v11225.name;
        const v11227 = v11226 || 'Object';
        const v11228 = typeof arg;
        let v11229;
        if (v11224) {
            v11229 = v11227;
        } else {
            v11229 = v11228;
        }
        const v11230 = 'not a function, got ' + v11229;
        const v11231 = assertArg(v11221, name, v11230);
        v11231;
        return arg;
    };
    const assertNotHasOwnProperty = function (name, context) {
        const v11232 = name === 'hasOwnProperty';
        if (v11232) {
            const v11233 = ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
            throw v11233;
        }
    };
    const getter = function (obj, path, bindFnToScope) {
        const v11234 = !path;
        if (v11234) {
            return obj;
        }
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        var i = 0;
        let v11235 = i < len;
        while (v11235) {
            key = keys[i];
            if (obj) {
                obj = (lastInstance = obj)[key];
            }
            const v11236 = i++;
            v11235 = i < len;
        }
        const v11237 = !bindFnToScope;
        const v11238 = isFunction(obj);
        const v11239 = v11237 && v11238;
        if (v11239) {
            const v11240 = bind(lastInstance, obj);
            return v11240;
        }
        return obj;
    };
    const getBlockNodes = function (nodes) {
        var node = nodes[0];
        const v11241 = nodes.length;
        const v11242 = v11241 - 1;
        var endNode = nodes[v11242];
        var blockNodes;
        var i = 1;
        const v11243 = node !== endNode;
        let v11244 = v11243 && (node = node.nextSibling);
        while (v11244) {
            const v11246 = nodes[i];
            const v11247 = v11246 !== node;
            const v11248 = blockNodes || v11247;
            if (v11248) {
                const v11249 = !blockNodes;
                if (v11249) {
                    const v11250 = slice.call(nodes, 0, i);
                    blockNodes = jqLite(v11250);
                }
                const v11251 = blockNodes.push(node);
                v11251;
            }
            const v11245 = i++;
            v11244 = v11243 && (node = node.nextSibling);
        }
        const v11252 = blockNodes || nodes;
        return v11252;
    };
    const createMap = function () {
        const v11253 = Object.create(null);
        return v11253;
    };
    const stringify = function (value) {
        const v11254 = value == null;
        if (v11254) {
            return '';
        }
        const v11255 = typeof value;
        switch (v11255) {
        case 'string':
            break;
        case 'number':
            value = '' + value;
            break;
        default:
            const v11256 = hasCustomToString(value);
            const v11257 = isArray(value);
            const v11258 = !v11257;
            const v11259 = v11256 && v11258;
            const v11260 = isDate(value);
            const v11261 = !v11260;
            const v11262 = v11259 && v11261;
            if (v11262) {
                value = value.toString();
            } else {
                value = toJson(value);
            }
        }
        return value;
    };
    var NODE_TYPE_ELEMENT = 1;
    var NODE_TYPE_ATTRIBUTE = 2;
    var NODE_TYPE_TEXT = 3;
    var NODE_TYPE_COMMENT = 8;
    var NODE_TYPE_DOCUMENT = 9;
    var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
    const setupModuleLoader = function (window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        const ensure = function (obj, name, factory) {
            const v11263 = obj[name];
            const v11264 = factory();
            const v11265 = v11263 || (obj[name] = v11264);
            return v11265;
        };
        var angular = ensure(window, 'angular', Object);
        const v11266 = angular.$$minErr;
        angular.$$minErr = v11266 || minErr;
        const v11309 = function () {
            var modules = {};
            const v11308 = function module(name, requires, configFn) {
                var info = {};
                var assertNotHasOwnProperty = function (name, context) {
                    const v11267 = name === 'hasOwnProperty';
                    if (v11267) {
                        const v11268 = ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
                        throw v11268;
                    }
                };
                const v11269 = assertNotHasOwnProperty(name, 'module');
                v11269;
                const v11270 = modules.hasOwnProperty(name);
                const v11271 = requires && v11270;
                if (v11271) {
                    modules[name] = null;
                }
                const v11306 = function () {
                    const v11272 = !requires;
                    if (v11272) {
                        const v11273 = 'Module \'{0}\' is not available! You either misspelled ' + 'the module name or forgot to load it. If registering a module ensure that you ';
                        const v11274 = v11273 + 'specify the dependencies as the second argument.';
                        const v11275 = $injectorMinErr('nomod', v11274, name);
                        throw v11275;
                    }
                    var invokeQueue = [];
                    var configBlocks = [];
                    var runBlocks = [];
                    var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
                    const v11280 = function (value) {
                        const v11276 = isDefined(value);
                        if (v11276) {
                            const v11277 = isObject(value);
                            const v11278 = !v11277;
                            if (v11278) {
                                const v11279 = ngMinErr('aobj', 'Argument \'{0}\' must be an object', 'value');
                                throw v11279;
                            }
                            info = value;
                            return this;
                        }
                        return info;
                    };
                    const v11281 = invokeLaterAndSetModuleName('$provide', 'provider');
                    const v11282 = invokeLaterAndSetModuleName('$provide', 'factory');
                    const v11283 = invokeLaterAndSetModuleName('$provide', 'service');
                    const v11284 = invokeLater('$provide', 'value');
                    const v11285 = invokeLater('$provide', 'constant', 'unshift');
                    const v11286 = invokeLaterAndSetModuleName('$provide', 'decorator', configBlocks);
                    const v11287 = invokeLaterAndSetModuleName('$animateProvider', 'register');
                    const v11288 = invokeLaterAndSetModuleName('$filterProvider', 'register');
                    const v11289 = invokeLaterAndSetModuleName('$controllerProvider', 'register');
                    const v11290 = invokeLaterAndSetModuleName('$compileProvider', 'directive');
                    const v11291 = invokeLaterAndSetModuleName('$compileProvider', 'component');
                    const v11293 = function (block) {
                        const v11292 = runBlocks.push(block);
                        v11292;
                        return this;
                    };
                    var moduleInstance = {};
                    moduleInstance._invokeQueue = invokeQueue;
                    moduleInstance._configBlocks = configBlocks;
                    moduleInstance._runBlocks = runBlocks;
                    moduleInstance.info = v11280;
                    moduleInstance.requires = requires;
                    moduleInstance.name = name;
                    moduleInstance.provider = v11281;
                    moduleInstance.factory = v11282;
                    moduleInstance.service = v11283;
                    moduleInstance.value = v11284;
                    moduleInstance.constant = v11285;
                    moduleInstance.decorator = v11286;
                    moduleInstance.animation = v11287;
                    moduleInstance.filter = v11288;
                    moduleInstance.controller = v11289;
                    moduleInstance.directive = v11290;
                    moduleInstance.component = v11291;
                    moduleInstance.config = config;
                    moduleInstance.run = v11293;
                    if (configFn) {
                        const v11294 = config(configFn);
                        v11294;
                    }
                    return moduleInstance;
                    const invokeLater = function (provider, method, insertMethod, queue) {
                        const v11295 = !queue;
                        if (v11295) {
                            queue = invokeQueue;
                        }
                        const v11299 = function () {
                            const v11296 = insertMethod || 'push';
                            const v11297 = [
                                provider,
                                method,
                                arguments
                            ];
                            const v11298 = queue[v11296](v11297);
                            v11298;
                            return moduleInstance;
                        };
                        return v11299;
                    };
                    const invokeLaterAndSetModuleName = function (provider, method, queue) {
                        const v11300 = !queue;
                        if (v11300) {
                            queue = invokeQueue;
                        }
                        const v11305 = function (recipeName, factoryFunction) {
                            const v11301 = isFunction(factoryFunction);
                            const v11302 = factoryFunction && v11301;
                            if (v11302) {
                                factoryFunction.$$moduleName = name;
                            }
                            const v11303 = [
                                provider,
                                method,
                                arguments
                            ];
                            const v11304 = queue.push(v11303);
                            v11304;
                            return moduleInstance;
                        };
                        return v11305;
                    };
                };
                const v11307 = ensure(modules, name, v11306);
                return v11307;
            };
            return v11308;
        };
        const v11310 = ensure(angular, 'module', v11309);
        return v11310;
    };
    const shallowCopy = function (src, dst) {
        const v11311 = isArray(src);
        if (v11311) {
            const v11312 = [];
            dst = dst || v11312;
            var i = 0;
            var ii = src.length;
            let v11313 = i < ii;
            while (v11313) {
                const v11315 = src[i];
                dst[i] = v11315;
                const v11314 = i++;
                v11313 = i < ii;
            }
        } else {
            const v11316 = isObject(src);
            if (v11316) {
                const v11317 = {};
                dst = dst || v11317;
                let key;
                for (key in src) {
                    const v11318 = key.charAt(0);
                    const v11319 = v11318 === '$';
                    const v11320 = key.charAt(1);
                    const v11321 = v11320 === '$';
                    const v11322 = v11319 && v11321;
                    const v11323 = !v11322;
                    if (v11323) {
                        const v11324 = src[key];
                        dst[key] = v11324;
                    }
                }
            }
        }
        const v11325 = dst || src;
        return v11325;
    };
    const serializeObject = function (obj, maxDepth) {
        var seen = [];
        const v11326 = isValidObjectMaxDepth(maxDepth);
        if (v11326) {
            obj = angular.copy(obj, null, maxDepth);
        }
        const v11331 = function (key, val) {
            val = toJsonReplacer(key, val);
            const v11327 = isObject(val);
            if (v11327) {
                const v11328 = seen.indexOf(val);
                const v11329 = v11328 >= 0;
                if (v11329) {
                    return '...';
                }
                const v11330 = seen.push(val);
                v11330;
            }
            return val;
        };
        const v11332 = JSON.stringify(obj, v11331);
        return v11332;
    };
    const toDebugString = function (obj, maxDepth) {
        const v11333 = typeof obj;
        const v11334 = v11333 === 'function';
        if (v11334) {
            const v11335 = obj.toString();
            const v11336 = v11335.replace(/ \{[\s\S]*$/, '');
            return v11336;
        } else {
            const v11337 = isUndefined(obj);
            if (v11337) {
                return 'undefined';
            } else {
                const v11338 = typeof obj;
                const v11339 = v11338 !== 'string';
                if (v11339) {
                    const v11340 = serializeObject(obj, maxDepth);
                    return v11340;
                }
            }
        }
        return obj;
    };
    var version = {};
    version.full = '1.7.8';
    version.major = 1;
    version.minor = 7;
    version.dot = 8;
    version.codeName = 'enthusiastic-oblation';
    const publishExternalAPI = function (angular) {
        const v11341 = {};
        v11341.$$counter = 0;
        const v11342 = {
            'errorHandlingConfig': errorHandlingConfig,
            'bootstrap': bootstrap,
            'copy': copy,
            'extend': extend,
            'merge': merge,
            'equals': equals,
            'element': jqLite,
            'forEach': forEach,
            'injector': createInjector,
            'noop': noop,
            'bind': bind,
            'toJson': toJson,
            'fromJson': fromJson,
            'identity': identity,
            'isUndefined': isUndefined,
            'isDefined': isDefined,
            'isString': isString,
            'isFunction': isFunction,
            'isObject': isObject,
            'isNumber': isNumber,
            'isElement': isElement,
            'isArray': isArray,
            'version': version,
            'isDate': isDate,
            'callbacks': v11341,
            'getTestability': getTestability,
            'reloadWithDebugInfo': reloadWithDebugInfo,
            '$$minErr': minErr,
            '$$csp': csp,
            '$$encodeUriSegment': encodeUriSegment,
            '$$encodeUriQuery': encodeUriQuery,
            '$$lowercase': lowercase,
            '$$stringify': stringify,
            '$$uppercase': uppercase
        };
        const v11343 = extend(angular, v11342);
        v11343;
        angularModule = setupModuleLoader(window);
        const v11344 = ['ngLocale'];
        const v11356 = function ngModule($provide) {
            const v11345 = { $$sanitizeUri: $$SanitizeUriProvider };
            const v11346 = $provide.provider(v11345);
            v11346;
            const v11347 = $provide.provider('$compile', $CompileProvider);
            const v11348 = {
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRef: ngRefDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            };
            const v11349 = v11347.directive(v11348);
            const v11350 = {
                ngInclude: ngIncludeFillContentDirective,
                input: hiddenInputBrowserCacheDirective
            };
            const v11351 = v11349.directive(v11350);
            const v11352 = v11351.directive(ngAttributeAliasDirectives);
            const v11353 = v11352.directive(ngEventDirectives);
            v11353;
            const v11354 = {
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $animateCss: $CoreAnimateCssProvider,
                $$animateJs: $$CoreAnimateJsProvider,
                $$animateQueue: $$CoreAnimateQueueProvider,
                $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $$isDocumentHidden: $$IsDocumentHiddenProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $$forceReflow: $$ForceReflowProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $$intervalFactory: $$IntervalFactoryProvider,
                $http: $HttpProvider,
                $httpParamSerializer: $HttpParamSerializerProvider,
                $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                $httpBackend: $HttpBackendProvider,
                $xhrFactory: $xhrFactoryProvider,
                $jsonpCallbacks: $jsonpCallbacksProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $$taskTrackerFactory: $$TaskTrackerFactoryProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$jqLite: $$jqLiteProvider,
                $$Map: $$MapProvider,
                $$cookieReader: $$CookieReaderProvider
            };
            const v11355 = $provide.provider(v11354);
            v11355;
        };
        const v11357 = [
            '$provide',
            v11356
        ];
        const v11358 = angularModule('ng', v11344, v11357);
        const v11359 = { angularVersion: '1.7.8' };
        const v11360 = v11358.info(v11359);
        v11360;
    };
    JQLite.expando = 'ng339';
    const v11361 = {};
    JQLite.cache = v11361;
    var jqCache = JQLite.cache;
    var jqId = 1;
    const v11368 = function (node) {
        const v11362 = this.cache;
        const v11363 = this.expando;
        const v11364 = node[v11363];
        const v11365 = v11362[v11364];
        const v11366 = {};
        const v11367 = v11365 || v11366;
        return v11367;
    };
    JQLite._data = v11368;
    const jqNextId = function () {
        const v11369 = ++jqId;
        return v11369;
    };
    var DASH_LOWERCASE_REGEXP = /-([a-z])/g;
    var MS_HACK_REGEXP = /^-ms-/;
    var MOUSE_EVENT_MAP = {};
    MOUSE_EVENT_MAP.mouseleave = 'mouseout';
    MOUSE_EVENT_MAP.mouseenter = 'mouseover';
    var jqLiteMinErr = minErr('jqLite');
    const cssKebabToCamel = function (name) {
        const v11370 = name.replace(MS_HACK_REGEXP, 'ms-');
        const v11371 = kebabToCamel(v11370);
        return v11371;
    };
    const fnCamelCaseReplace = function (all, letter) {
        const v11372 = letter.toUpperCase();
        return v11372;
    };
    const kebabToCamel = function (name) {
        const v11373 = name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
        return v11373;
    };
    var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
    var HTML_REGEXP = /<|&#?\w+;/;
    var TAG_NAME_REGEXP = /<([\w:-]+)/;
    var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
    const v11374 = [
        1,
        '<select multiple="multiple">',
        '</select>'
    ];
    const v11375 = [
        1,
        '<table>',
        '</table>'
    ];
    const v11376 = [
        2,
        '<table><colgroup>',
        '</colgroup></table>'
    ];
    const v11377 = [
        2,
        '<table><tbody>',
        '</tbody></table>'
    ];
    const v11378 = [
        3,
        '<table><tbody><tr>',
        '</tr></tbody></table>'
    ];
    const v11379 = [
        0,
        '',
        ''
    ];
    var wrapMap = {};
    wrapMap['option'] = v11374;
    wrapMap['thead'] = v11375;
    wrapMap['col'] = v11376;
    wrapMap['tr'] = v11377;
    wrapMap['td'] = v11378;
    wrapMap['_default'] = v11379;
    const v11380 = wrapMap.option;
    wrapMap.optgroup = v11380;
    const v11381 = wrapMap.thead;
    wrapMap.caption = v11381;
    wrapMap.colgroup = wrapMap.caption;
    wrapMap.tfoot = wrapMap.colgroup;
    wrapMap.tbody = wrapMap.tfoot;
    const v11382 = wrapMap.td;
    wrapMap.th = v11382;
    const jqLiteIsTextNode = function (html) {
        const v11383 = HTML_REGEXP.test(html);
        const v11384 = !v11383;
        return v11384;
    };
    const jqLiteAcceptsData = function (node) {
        var nodeType = node.nodeType;
        const v11385 = nodeType === NODE_TYPE_ELEMENT;
        const v11386 = !nodeType;
        const v11387 = v11385 || v11386;
        const v11388 = nodeType === NODE_TYPE_DOCUMENT;
        const v11389 = v11387 || v11388;
        return v11389;
    };
    const jqLiteHasData = function (node) {
        let key;
        const v11390 = node.ng339;
        const v11391 = jqCache[v11390];
        for (key in v11391) {
            return true;
        }
        return false;
    };
    const jqLiteBuildFragment = function (html, context) {
        var tmp;
        var tag;
        var wrap;
        var fragment = context.createDocumentFragment();
        var nodes = [];
        var i;
        const v11392 = jqLiteIsTextNode(html);
        if (v11392) {
            const v11393 = context.createTextNode(html);
            const v11394 = nodes.push(v11393);
            v11394;
        } else {
            const v11395 = context.createElement('div');
            tmp = fragment.appendChild(v11395);
            const v11396 = TAG_NAME_REGEXP.exec(html);
            const v11397 = [
                '',
                ''
            ];
            const v11398 = v11396 || v11397;
            const v11399 = v11398[1];
            tag = v11399.toLowerCase();
            const v11400 = wrapMap[tag];
            const v11401 = wrapMap._default;
            wrap = v11400 || v11401;
            const v11402 = wrap[1];
            const v11403 = html.replace(XHTML_TAG_REGEXP, '<$1></$2>');
            const v11404 = v11402 + v11403;
            const v11405 = wrap[2];
            tmp.innerHTML = v11404 + v11405;
            i = wrap[0];
            let v11406 = i--;
            while (v11406) {
                tmp = tmp.lastChild;
                v11406 = i--;
            }
            const v11407 = tmp.childNodes;
            nodes = concat(nodes, v11407);
            tmp = fragment.firstChild;
            tmp.textContent = '';
        }
        fragment.textContent = '';
        fragment.innerHTML = '';
        const v11409 = function (node) {
            const v11408 = fragment.appendChild(node);
            v11408;
        };
        const v11410 = forEach(nodes, v11409);
        v11410;
        return fragment;
    };
    const jqLiteParseHTML = function (html, context) {
        const v11411 = window.document;
        context = context || v11411;
        var parsed;
        if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
            const v11412 = parsed[1];
            const v11413 = context.createElement(v11412);
            const v11414 = [v11413];
            return v11414;
        }
        if (parsed = jqLiteBuildFragment(html, context)) {
            const v11415 = parsed.childNodes;
            return v11415;
        }
        const v11416 = [];
        return v11416;
    };
    const jqLiteWrapNode = function (node, wrapper) {
        var parent = node.parentNode;
        if (parent) {
            const v11417 = parent.replaceChild(wrapper, node);
            v11417;
        }
        const v11418 = wrapper.appendChild(node);
        v11418;
    };
    const v11419 = window.Node;
    const v11420 = v11419.prototype;
    const v11421 = v11420.contains;
    const v11426 = function (arg) {
        const v11422 = this.compareDocumentPosition(arg);
        const v11423 = v11422 & 16;
        const v11424 = !v11423;
        const v11425 = !v11424;
        return v11425;
    };
    var jqLiteContains = v11421 || v11426;
    const JQLite = function (element) {
        const v11427 = element instanceof JQLite;
        if (v11427) {
            return element;
        }
        var argIsString;
        const v11428 = isString(element);
        if (v11428) {
            element = trim(element);
            argIsString = true;
        }
        const v11429 = this instanceof JQLite;
        const v11430 = !v11429;
        if (v11430) {
            const v11431 = element.charAt(0);
            const v11432 = v11431 !== '<';
            const v11433 = argIsString && v11432;
            if (v11433) {
                const v11434 = jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
                throw v11434;
            }
            const v11435 = new JQLite(element);
            return v11435;
        }
        if (argIsString) {
            const v11436 = jqLiteParseHTML(element);
            const v11437 = jqLiteAddNodes(this, v11436);
            v11437;
        } else {
            const v11438 = isFunction(element);
            if (v11438) {
                const v11439 = jqLiteReady(element);
                v11439;
            } else {
                const v11440 = jqLiteAddNodes(this, element);
                v11440;
            }
        }
    };
    const jqLiteClone = function (element) {
        const v11441 = element.cloneNode(true);
        return v11441;
    };
    const jqLiteDealoc = function (element, onlyDescendants) {
        const v11442 = !onlyDescendants;
        const v11443 = jqLiteAcceptsData(element);
        const v11444 = v11442 && v11443;
        if (v11444) {
            const v11445 = [element];
            const v11446 = jqLite.cleanData(v11445);
            v11446;
        }
        const v11447 = element.querySelectorAll;
        if (v11447) {
            const v11448 = element.querySelectorAll('*');
            const v11449 = jqLite.cleanData(v11448);
            v11449;
        }
    };
    const isEmptyObject = function (obj) {
        var name;
        for (name in obj) {
            return false;
        }
        return true;
    };
    const removeIfEmptyData = function (element) {
        var expandoId = element.ng339;
        const v11450 = jqCache[expandoId];
        var expandoStore = expandoId && v11450;
        const v11451 = expandoStore.events;
        var events = expandoStore && v11451;
        const v11452 = expandoStore.data;
        var data = expandoStore && v11452;
        const v11453 = !data;
        const v11454 = isEmptyObject(data);
        const v11455 = v11453 || v11454;
        const v11456 = !events;
        const v11457 = isEmptyObject(events);
        const v11458 = v11456 || v11457;
        const v11459 = v11455 && v11458;
        if (v11459) {
            const v11460 = jqCache[expandoId];
            const v11461 = delete v11460;
            v11461;
            element.ng339 = undefined;
        }
    };
    const jqLiteOff = function (element, type, fn, unsupported) {
        const v11462 = isDefined(unsupported);
        if (v11462) {
            const v11463 = jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
            throw v11463;
        }
        var expandoStore = jqLiteExpandoStore(element);
        const v11464 = expandoStore.events;
        var events = expandoStore && v11464;
        const v11465 = expandoStore.handle;
        var handle = expandoStore && v11465;
        const v11466 = !handle;
        if (v11466) {
            return;
        }
        const v11467 = !type;
        if (v11467) {
            for (type in events) {
                const v11468 = type !== '$destroy';
                if (v11468) {
                    const v11469 = element.removeEventListener(type, handle);
                    v11469;
                }
                const v11470 = events[type];
                const v11471 = delete v11470;
                v11471;
            }
        } else {
            var removeHandler = function (type) {
                var listenerFns = events[type];
                const v11472 = isDefined(fn);
                if (v11472) {
                    const v11473 = [];
                    const v11474 = listenerFns || v11473;
                    const v11475 = arrayRemove(v11474, fn);
                    v11475;
                }
                const v11476 = isDefined(fn);
                const v11477 = v11476 && listenerFns;
                const v11478 = listenerFns.length;
                const v11479 = v11478 > 0;
                const v11480 = v11477 && v11479;
                const v11481 = !v11480;
                if (v11481) {
                    const v11482 = element.removeEventListener(type, handle);
                    v11482;
                    const v11483 = events[type];
                    const v11484 = delete v11483;
                    v11484;
                }
            };
            const v11485 = type.split(' ');
            const v11490 = function (type) {
                const v11486 = removeHandler(type);
                v11486;
                const v11487 = MOUSE_EVENT_MAP[type];
                if (v11487) {
                    const v11488 = MOUSE_EVENT_MAP[type];
                    const v11489 = removeHandler(v11488);
                    v11489;
                }
            };
            const v11491 = forEach(v11485, v11490);
            v11491;
        }
        const v11492 = removeIfEmptyData(element);
        v11492;
    };
    const jqLiteRemoveData = function (element, name) {
        var expandoId = element.ng339;
        const v11493 = jqCache[expandoId];
        var expandoStore = expandoId && v11493;
        if (expandoStore) {
            if (name) {
                const v11494 = expandoStore.data;
                const v11495 = v11494[name];
                const v11496 = delete v11495;
                v11496;
            } else {
                const v11497 = {};
                expandoStore.data = v11497;
            }
            const v11498 = removeIfEmptyData(element);
            v11498;
        }
    };
    const jqLiteExpandoStore = function (element, createIfNecessary) {
        var expandoId = element.ng339;
        const v11499 = jqCache[expandoId];
        var expandoStore = expandoId && v11499;
        const v11500 = !expandoStore;
        const v11501 = createIfNecessary && v11500;
        if (v11501) {
            expandoId = jqNextId();
            element.ng339 = expandoId;
            const v11502 = {};
            const v11503 = {};
            const v11504 = {};
            v11504.events = v11502;
            v11504.data = v11503;
            v11504.handle = undefined;
            jqCache.expandoId = v11504;
            expandoStore = jqCache[expandoId];
        }
        return expandoStore;
    };
    const jqLiteData = function (element, key, value) {
        const v11505 = jqLiteAcceptsData(element);
        if (v11505) {
            var prop;
            var isSimpleSetter = isDefined(value);
            const v11506 = !isSimpleSetter;
            const v11507 = v11506 && key;
            const v11508 = isObject(key);
            const v11509 = !v11508;
            var isSimpleGetter = v11507 && v11509;
            const v11510 = !key;
            var massGetter = v11510;
            const v11511 = !isSimpleGetter;
            var expandoStore = jqLiteExpandoStore(element, v11511);
            const v11512 = expandoStore.data;
            var data = expandoStore && v11512;
            if (isSimpleSetter) {
                const v11513 = kebabToCamel(key);
                data[v11513] = value;
            } else {
                if (massGetter) {
                    return data;
                } else {
                    if (isSimpleGetter) {
                        const v11514 = kebabToCamel(key);
                        const v11515 = data[v11514];
                        const v11516 = data && v11515;
                        return v11516;
                    } else {
                        for (prop in key) {
                            const v11517 = kebabToCamel(prop);
                            const v11518 = key[prop];
                            data[v11517] = v11518;
                        }
                    }
                }
            }
        }
    };
    const jqLiteHasClass = function (element, selector) {
        const v11519 = element.getAttribute;
        const v11520 = !v11519;
        if (v11520) {
            return false;
        }
        const v11521 = element.getAttribute('class');
        const v11522 = v11521 || '';
        const v11523 = ' ' + v11522;
        const v11524 = v11523 + ' ';
        const v11525 = v11524.replace(/[\n\t]/g, ' ');
        const v11526 = ' ' + selector;
        const v11527 = v11526 + ' ';
        const v11528 = v11525.indexOf(v11527);
        const v11529 = -1;
        const v11530 = v11528 > v11529;
        return v11530;
    };
    const jqLiteRemoveClass = function (element, cssClasses) {
        const v11531 = element.setAttribute;
        const v11532 = cssClasses && v11531;
        if (v11532) {
            const v11533 = element.getAttribute('class');
            const v11534 = v11533 || '';
            const v11535 = ' ' + v11534;
            const v11536 = v11535 + ' ';
            var existingClasses = v11536.replace(/[\n\t]/g, ' ');
            var newClasses = existingClasses;
            const v11537 = cssClasses.split(' ');
            const v11540 = function (cssClass) {
                cssClass = trim(cssClass);
                const v11538 = ' ' + cssClass;
                const v11539 = v11538 + ' ';
                newClasses = newClasses.replace(v11539, ' ');
            };
            const v11541 = forEach(v11537, v11540);
            v11541;
            const v11542 = newClasses !== existingClasses;
            if (v11542) {
                const v11543 = trim(newClasses);
                const v11544 = element.setAttribute('class', v11543);
                v11544;
            }
        }
    };
    const jqLiteAddClass = function (element, cssClasses) {
        const v11545 = element.setAttribute;
        const v11546 = cssClasses && v11545;
        if (v11546) {
            const v11547 = element.getAttribute('class');
            const v11548 = v11547 || '';
            const v11549 = ' ' + v11548;
            const v11550 = v11549 + ' ';
            var existingClasses = v11550.replace(/[\n\t]/g, ' ');
            var newClasses = existingClasses;
            const v11551 = cssClasses.split(' ');
            const v11557 = function (cssClass) {
                cssClass = trim(cssClass);
                const v11552 = ' ' + cssClass;
                const v11553 = v11552 + ' ';
                const v11554 = newClasses.indexOf(v11553);
                const v11555 = -1;
                const v11556 = v11554 === v11555;
                if (v11556) {
                    newClasses += cssClass + ' ';
                }
            };
            const v11558 = forEach(v11551, v11557);
            v11558;
            const v11559 = newClasses !== existingClasses;
            if (v11559) {
                const v11560 = trim(newClasses);
                const v11561 = element.setAttribute('class', v11560);
                v11561;
            }
        }
    };
    const jqLiteAddNodes = function (root, elements) {
        if (elements) {
            const v11562 = elements.nodeType;
            if (v11562) {
                const v11563 = root.length;
                const v11564 = v11563++;
                root[v11564] = elements;
            } else {
                var length = elements.length;
                const v11565 = typeof length;
                const v11566 = v11565 === 'number';
                const v11567 = elements.window;
                const v11568 = v11567 !== elements;
                const v11569 = v11566 && v11568;
                if (v11569) {
                    if (length) {
                        var i = 0;
                        let v11570 = i < length;
                        while (v11570) {
                            const v11572 = root.length;
                            const v11573 = v11572++;
                            const v11574 = elements[i];
                            root[v11573] = v11574;
                            const v11571 = i++;
                            v11570 = i < length;
                        }
                    }
                } else {
                    const v11575 = root.length;
                    const v11576 = v11575++;
                    root[v11576] = elements;
                }
            }
        }
    };
    const jqLiteController = function (element, name) {
        const v11577 = name || 'ngController';
        const v11578 = '$' + v11577;
        const v11579 = v11578 + 'Controller';
        const v11580 = jqLiteInheritedData(element, v11579);
        return v11580;
    };
    const jqLiteInheritedData = function (element, name, value) {
        const v11581 = element.nodeType;
        const v11582 = v11581 === NODE_TYPE_DOCUMENT;
        if (v11582) {
            element = element.documentElement;
        }
        let names;
        const v11583 = isArray(name);
        const v11584 = [name];
        if (v11583) {
            names = name;
        } else {
            names = v11584;
        }
        while (element) {
            var i = 0;
            var ii = names.length;
            let v11585 = i < ii;
            while (v11585) {
                const v11587 = names[i];
                const v11588 = isDefined(value = jqLite.data(element, v11587));
                if (v11588) {
                    return value;
                }
                const v11586 = i++;
                v11585 = i < ii;
            }
            const v11589 = element.parentNode;
            const v11590 = element.nodeType;
            const v11591 = v11590 === NODE_TYPE_DOCUMENT_FRAGMENT;
            const v11592 = element.host;
            const v11593 = v11591 && v11592;
            element = v11589 || v11593;
        }
    };
    const jqLiteEmpty = function (element) {
        const v11594 = jqLiteDealoc(element, true);
        v11594;
        let v11595 = element.firstChild;
        while (v11595) {
            const v11596 = element.firstChild;
            const v11597 = element.removeChild(v11596);
            v11597;
            v11595 = element.firstChild;
        }
    };
    const jqLiteRemove = function (element, keepData) {
        const v11598 = !keepData;
        if (v11598) {
            const v11599 = jqLiteDealoc(element);
            v11599;
        }
        var parent = element.parentNode;
        if (parent) {
            const v11600 = parent.removeChild(element);
            v11600;
        }
    };
    const jqLiteDocumentLoaded = function (action, win) {
        win = win || window;
        const v11601 = win.document;
        const v11602 = v11601.readyState;
        const v11603 = v11602 === 'complete';
        if (v11603) {
            const v11604 = win.setTimeout(action);
            v11604;
        } else {
            const v11605 = jqLite(win);
            const v11606 = v11605.on('load', action);
            v11606;
        }
    };
    const jqLiteReady = function (fn) {
        const trigger = function () {
            const v11607 = window.document;
            const v11608 = v11607.removeEventListener('DOMContentLoaded', trigger);
            v11608;
            const v11609 = window.removeEventListener('load', trigger);
            v11609;
            const v11610 = fn();
            v11610;
        };
        const v11611 = window.document;
        const v11612 = v11611.readyState;
        const v11613 = v11612 === 'complete';
        if (v11613) {
            const v11614 = window.setTimeout(fn);
            v11614;
        } else {
            const v11615 = window.document;
            const v11616 = v11615.addEventListener('DOMContentLoaded', trigger);
            v11616;
            const v11617 = window.addEventListener('load', trigger);
            v11617;
        }
    };
    const v11625 = function () {
        var value = [];
        const v11620 = function (e) {
            const v11618 = '' + e;
            const v11619 = value.push(v11618);
            v11619;
        };
        const v11621 = forEach(this, v11620);
        v11621;
        const v11622 = value.join(', ');
        const v11623 = '[' + v11622;
        const v11624 = v11623 + ']';
        return v11624;
    };
    const v11634 = function (index) {
        const v11626 = index >= 0;
        const v11627 = this[index];
        const v11628 = jqLite(v11627);
        const v11629 = this.length;
        const v11630 = v11629 + index;
        const v11631 = this[v11630];
        const v11632 = jqLite(v11631);
        let v11633;
        if (v11626) {
            v11633 = v11628;
        } else {
            v11633 = v11632;
        }
        return v11633;
    };
    const v11635 = [];
    const v11636 = v11635.sort;
    const v11637 = [];
    const v11638 = v11637.splice;
    const v11639 = {};
    v11639.ready = jqLiteReady;
    v11639.toString = v11625;
    v11639.eq = v11634;
    v11639.length = 0;
    v11639.push = push;
    v11639.sort = v11636;
    v11639.splice = v11638;
    JQLite.prototype = v11639;
    var JQLitePrototype = JQLite.prototype;
    var BOOLEAN_ATTR = {};
    const v11640 = 'multiple,selected,checked,disabled,readOnly,required,open'.split(',');
    const v11642 = function (value) {
        const v11641 = lowercase(value);
        BOOLEAN_ATTR[v11641] = value;
    };
    const v11643 = forEach(v11640, v11642);
    v11643;
    var BOOLEAN_ELEMENTS = {};
    const v11644 = 'input,select,option,textarea,button,form,details'.split(',');
    const v11645 = function (value) {
        BOOLEAN_ELEMENTS[value] = true;
    };
    const v11646 = forEach(v11644, v11645);
    v11646;
    var ALIASED_ATTR = {};
    ALIASED_ATTR['ngMinlength'] = 'minlength';
    ALIASED_ATTR['ngMaxlength'] = 'maxlength';
    ALIASED_ATTR['ngMin'] = 'min';
    ALIASED_ATTR['ngMax'] = 'max';
    ALIASED_ATTR['ngPattern'] = 'pattern';
    ALIASED_ATTR['ngStep'] = 'step';
    const getBooleanAttrName = function (element, name) {
        const v11647 = name.toLowerCase();
        var booleanAttr = BOOLEAN_ATTR[v11647];
        const v11648 = nodeName_(element);
        const v11649 = BOOLEAN_ELEMENTS[v11648];
        const v11650 = booleanAttr && v11649;
        const v11651 = v11650 && booleanAttr;
        return v11651;
    };
    const getAliasedAttrName = function (name) {
        const v11652 = ALIASED_ATTR[name];
        return v11652;
    };
    const v11659 = function jqLiteCleanData(nodes) {
        var i = 0;
        var ii = nodes.length;
        let v11653 = i < ii;
        while (v11653) {
            const v11655 = nodes[i];
            const v11656 = jqLiteRemoveData(v11655);
            v11656;
            const v11657 = nodes[i];
            const v11658 = jqLiteOff(v11657);
            v11658;
            const v11654 = i++;
            v11653 = i < ii;
        }
    };
    const v11660 = {
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: v11659
    };
    const v11661 = function (fn, name) {
        JQLite[name] = fn;
    };
    const v11662 = forEach(v11660, v11661);
    v11662;
    const v11669 = function (element) {
        const v11663 = jqLite.data(element, '$scope');
        const v11664 = element.parentNode;
        const v11665 = v11664 || element;
        const v11666 = [
            '$isolateScope',
            '$scope'
        ];
        const v11667 = jqLiteInheritedData(v11665, v11666);
        const v11668 = v11663 || v11667;
        return v11668;
    };
    const v11673 = function (element) {
        const v11670 = jqLite.data(element, '$isolateScope');
        const v11671 = jqLite.data(element, '$isolateScopeNoTemplate');
        const v11672 = v11670 || v11671;
        return v11672;
    };
    const v11675 = function (element) {
        const v11674 = jqLiteInheritedData(element, '$injector');
        return v11674;
    };
    const v11677 = function (element, name) {
        const v11676 = element.removeAttribute(name);
        v11676;
    };
    const v11682 = function (element, name, value) {
        name = cssKebabToCamel(name);
        const v11678 = isDefined(value);
        if (v11678) {
            const v11679 = element.style;
            v11679[name] = value;
        } else {
            const v11680 = element.style;
            const v11681 = v11680[name];
            return v11681;
        }
    };
    const v11703 = function (element, name, value) {
        var ret;
        var nodeType = element.nodeType;
        const v11683 = nodeType === NODE_TYPE_TEXT;
        const v11684 = nodeType === NODE_TYPE_ATTRIBUTE;
        const v11685 = v11683 || v11684;
        const v11686 = nodeType === NODE_TYPE_COMMENT;
        const v11687 = v11685 || v11686;
        const v11688 = element.getAttribute;
        const v11689 = !v11688;
        const v11690 = v11687 || v11689;
        if (v11690) {
            return;
        }
        var lowercasedName = lowercase(name);
        var isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
        const v11691 = isDefined(value);
        if (v11691) {
            const v11692 = value === null;
            const v11693 = value === false;
            const v11694 = v11693 && isBooleanAttr;
            const v11695 = v11692 || v11694;
            if (v11695) {
                const v11696 = element.removeAttribute(name);
                v11696;
            } else {
                let v11697;
                if (isBooleanAttr) {
                    v11697 = lowercasedName;
                } else {
                    v11697 = value;
                }
                const v11698 = element.setAttribute(name, v11697);
                v11698;
            }
        } else {
            ret = element.getAttribute(name);
            const v11699 = ret !== null;
            const v11700 = isBooleanAttr && v11699;
            if (v11700) {
                ret = lowercasedName;
            }
            const v11701 = ret === null;
            let v11702;
            if (v11701) {
                v11702 = undefined;
            } else {
                v11702 = ret;
            }
            return v11702;
        }
    };
    const v11706 = function (element, name, value) {
        const v11704 = isDefined(value);
        if (v11704) {
            element[name] = value;
        } else {
            const v11705 = element[name];
            return v11705;
        }
    };
    const v11713 = function () {
        getText.$dv = '';
        return getText;
        const getText = function (element, value) {
            const v11707 = isUndefined(value);
            if (v11707) {
                var nodeType = element.nodeType;
                const v11708 = nodeType === NODE_TYPE_ELEMENT;
                const v11709 = nodeType === NODE_TYPE_TEXT;
                const v11710 = v11708 || v11709;
                const v11711 = element.textContent;
                let v11712;
                if (v11710) {
                    v11712 = v11711;
                } else {
                    v11712 = '';
                }
                return v11712;
            }
            element.textContent = value;
        };
    };
    const v11714 = v11713();
    const v11729 = function (element, value) {
        const v11715 = isUndefined(value);
        if (v11715) {
            const v11716 = element.multiple;
            const v11717 = nodeName_(element);
            const v11718 = v11717 === 'select';
            const v11719 = v11716 && v11718;
            if (v11719) {
                var result = [];
                const v11720 = element.options;
                const v11726 = function (option) {
                    const v11721 = option.selected;
                    if (v11721) {
                        const v11722 = option.value;
                        const v11723 = option.text;
                        const v11724 = v11722 || v11723;
                        const v11725 = result.push(v11724);
                        v11725;
                    }
                };
                const v11727 = forEach(v11720, v11726);
                v11727;
                return result;
            }
            const v11728 = element.value;
            return v11728;
        }
        element.value = value;
    };
    const v11733 = function (element, value) {
        const v11730 = isUndefined(value);
        if (v11730) {
            const v11731 = element.innerHTML;
            return v11731;
        }
        const v11732 = jqLiteDealoc(element, true);
        v11732;
        element.innerHTML = value;
    };
    const v11734 = {
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: v11669,
        isolateScope: v11673,
        controller: jqLiteController,
        injector: v11675,
        removeAttr: v11677,
        hasClass: jqLiteHasClass,
        css: v11682,
        attr: v11703,
        prop: v11706,
        text: v11714,
        val: v11729,
        html: v11733,
        empty: jqLiteEmpty
    };
    const v11766 = function (fn, name) {
        const v11735 = JQLite.prototype;
        const v11765 = function (arg1, arg2) {
            var i;
            var key;
            var nodeCount = this.length;
            const v11736 = fn !== jqLiteEmpty;
            const v11737 = fn.length;
            const v11738 = v11737 === 2;
            const v11739 = fn !== jqLiteHasClass;
            const v11740 = fn !== jqLiteController;
            const v11741 = v11739 && v11740;
            const v11742 = v11738 && v11741;
            let v11743;
            if (v11742) {
                v11743 = arg1;
            } else {
                v11743 = arg2;
            }
            const v11744 = isUndefined(v11743);
            const v11745 = v11736 && v11744;
            if (v11745) {
                const v11746 = isObject(arg1);
                if (v11746) {
                    i = 0
                    let v11747 = i < nodeCount;
                    while (v11747) {
                        const v11749 = fn === jqLiteData;
                        if (v11749) {
                            const v11750 = this[i];
                            const v11751 = fn(v11750, arg1);
                            v11751;
                        } else {
                            for (key in arg1) {
                                const v11752 = this[i];
                                const v11753 = arg1[key];
                                const v11754 = fn(v11752, key, v11753);
                                v11754;
                            }
                        }
                        const v11748 = i++;
                        v11747 = i < nodeCount;
                    }
                    return this;
                } else {
                    var value = fn.$dv;
                    let jj;
                    const v11755 = isUndefined(value);
                    const v11756 = Math.min(nodeCount, 1);
                    if (v11755) {
                        jj = v11756;
                    } else {
                        jj = nodeCount;
                    }
                    var j = 0;
                    let v11757 = j < jj;
                    while (v11757) {
                        const v11759 = this[j];
                        var nodeValue = fn(v11759, arg1, arg2);
                        const v11760 = value + nodeValue;
                        if (value) {
                            value = v11760;
                        } else {
                            value = nodeValue;
                        }
                        const v11758 = j++;
                        v11757 = j < jj;
                    }
                    return value;
                }
            } else {
                i = 0
                let v11761 = i < nodeCount;
                while (v11761) {
                    const v11763 = this[i];
                    const v11764 = fn(v11763, arg1, arg2);
                    v11764;
                    const v11762 = i++;
                    v11761 = i < nodeCount;
                }
                return this;
            }
        };
        v11735[name] = v11765;
    };
    const v11767 = forEach(v11734, v11766);
    v11767;
    const createEventHandler = function (element, events) {
        var eventHandler = function (event, type) {
            const v11769 = function () {
                const v11768 = event.defaultPrevented;
                return v11768;
            };
            event.isDefaultPrevented = v11769;
            const v11770 = event.type;
            const v11771 = type || v11770;
            var eventFns = events[v11771];
            let eventFnsLength;
            const v11772 = eventFns.length;
            if (eventFns) {
                eventFnsLength = v11772;
            } else {
                eventFnsLength = 0;
            }
            const v11773 = !eventFnsLength;
            if (v11773) {
                return;
            }
            const v11774 = event.immediatePropagationStopped;
            const v11775 = isUndefined(v11774);
            if (v11775) {
                var originalStopImmediatePropagation = event.stopImmediatePropagation;
                const v11779 = function () {
                    event.immediatePropagationStopped = true;
                    const v11776 = event.stopPropagation;
                    if (v11776) {
                        const v11777 = event.stopPropagation();
                        v11777;
                    }
                    if (originalStopImmediatePropagation) {
                        const v11778 = originalStopImmediatePropagation.call(event);
                        v11778;
                    }
                };
                event.stopImmediatePropagation = v11779;
            }
            const v11782 = function () {
                const v11780 = event.immediatePropagationStopped;
                const v11781 = v11780 === true;
                return v11781;
            };
            event.isImmediatePropagationStopped = v11782;
            const v11783 = eventFns.specialHandlerWrapper;
            var handlerWrapper = v11783 || defaultHandlerWrapper;
            const v11784 = eventFnsLength > 1;
            if (v11784) {
                eventFns = shallowCopy(eventFns);
            }
            var i = 0;
            let v11785 = i < eventFnsLength;
            while (v11785) {
                const v11787 = event.isImmediatePropagationStopped();
                const v11788 = !v11787;
                if (v11788) {
                    const v11789 = eventFns[i];
                    const v11790 = handlerWrapper(element, event, v11789);
                    v11790;
                }
                const v11786 = i++;
                v11785 = i < eventFnsLength;
            }
        };
        eventHandler.elem = element;
        return eventHandler;
    };
    const defaultHandlerWrapper = function (element, event, handler) {
        const v11791 = handler.call(element, event);
        v11791;
    };
    const specialMouseHandlerWrapper = function (target, event, handler) {
        var related = event.relatedTarget;
        const v11792 = !related;
        const v11793 = related !== target;
        const v11794 = jqLiteContains.call(target, related);
        const v11795 = !v11794;
        const v11796 = v11793 && v11795;
        const v11797 = v11792 || v11796;
        if (v11797) {
            const v11798 = handler.call(target, event);
            v11798;
        }
    };
    const v11821 = function jqLiteOn(element, type, fn, unsupported) {
        const v11799 = isDefined(unsupported);
        if (v11799) {
            const v11800 = jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
            throw v11800;
        }
        const v11801 = jqLiteAcceptsData(element);
        const v11802 = !v11801;
        if (v11802) {
            return;
        }
        var expandoStore = jqLiteExpandoStore(element, true);
        var events = expandoStore.events;
        var handle = expandoStore.handle;
        const v11803 = !handle;
        if (v11803) {
            const v11804 = createEventHandler(element, events);
            expandoStore.handle = v11804;
            handle = expandoStore.handle;
        }
        let types;
        const v11805 = type.indexOf(' ');
        const v11806 = v11805 >= 0;
        const v11807 = type.split(' ');
        const v11808 = [type];
        if (v11806) {
            types = v11807;
        } else {
            types = v11808;
        }
        var i = types.length;
        var addHandler = function (type, specialHandlerWrapper, noEventListener) {
            var eventFns = events[type];
            const v11809 = !eventFns;
            if (v11809) {
                events.type = [];
                eventFns = events[type];
                eventFns.specialHandlerWrapper = specialHandlerWrapper;
                const v11810 = type !== '$destroy';
                const v11811 = !noEventListener;
                const v11812 = v11810 && v11811;
                if (v11812) {
                    const v11813 = element.addEventListener(type, handle);
                    v11813;
                }
            }
            const v11814 = eventFns.push(fn);
            v11814;
        };
        let v11815 = i--;
        while (v11815) {
            type = types[i];
            const v11816 = MOUSE_EVENT_MAP[type];
            if (v11816) {
                const v11817 = MOUSE_EVENT_MAP[type];
                const v11818 = addHandler(v11817, specialMouseHandlerWrapper);
                v11818;
                const v11819 = addHandler(type, undefined, true);
                v11819;
            } else {
                const v11820 = addHandler(type);
                v11820;
            }
            v11815 = i--;
        }
    };
    const v11827 = function (element, type, fn) {
        element = jqLite(element);
        const v11824 = function onFn() {
            const v11822 = element.off(type, fn);
            v11822;
            const v11823 = element.off(type, onFn);
            v11823;
        };
        const v11825 = element.on(type, v11824);
        v11825;
        const v11826 = element.on(type, fn);
        v11826;
    };
    const v11835 = function (element, replaceNode) {
        var index;
        var parent = element.parentNode;
        const v11828 = jqLiteDealoc(element);
        v11828;
        const v11829 = new JQLite(replaceNode);
        const v11833 = function (node) {
            if (index) {
                const v11830 = index.nextSibling;
                const v11831 = parent.insertBefore(node, v11830);
                v11831;
            } else {
                const v11832 = parent.replaceChild(node, element);
                v11832;
            }
            index = node;
        };
        const v11834 = forEach(v11829, v11833);
        v11834;
    };
    const v11842 = function (element) {
        var children = [];
        const v11836 = element.childNodes;
        const v11840 = function (element) {
            const v11837 = element.nodeType;
            const v11838 = v11837 === NODE_TYPE_ELEMENT;
            if (v11838) {
                const v11839 = children.push(element);
                v11839;
            }
        };
        const v11841 = forEach(v11836, v11840);
        v11841;
        return children;
    };
    const v11848 = function (element) {
        const v11843 = element.contentDocument;
        const v11844 = element.childNodes;
        const v11845 = v11843 || v11844;
        const v11846 = [];
        const v11847 = v11845 || v11846;
        return v11847;
    };
    const v11855 = function (element, node) {
        var nodeType = element.nodeType;
        const v11849 = nodeType !== NODE_TYPE_ELEMENT;
        const v11850 = nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT;
        const v11851 = v11849 && v11850;
        if (v11851) {
            return;
        }
        node = new JQLite(node);
        var i = 0;
        var ii = node.length;
        let v11852 = i < ii;
        while (v11852) {
            var child = node[i];
            const v11854 = element.appendChild(child);
            v11854;
            const v11853 = i++;
            v11852 = i < ii;
        }
    };
    const v11862 = function (element, node) {
        const v11856 = element.nodeType;
        const v11857 = v11856 === NODE_TYPE_ELEMENT;
        if (v11857) {
            var index = element.firstChild;
            const v11858 = new JQLite(node);
            const v11860 = function (child) {
                const v11859 = element.insertBefore(child, index);
                v11859;
            };
            const v11861 = forEach(v11858, v11860);
            v11861;
        }
    };
    const v11868 = function (element, wrapNode) {
        const v11863 = jqLite(wrapNode);
        const v11864 = v11863.eq(0);
        const v11865 = v11864.clone();
        const v11866 = v11865[0];
        const v11867 = jqLiteWrapNode(element, v11866);
        v11867;
    };
    const v11870 = function (element) {
        const v11869 = jqLiteRemove(element, true);
        v11869;
    };
    const v11875 = function (element, newElement) {
        var index = element;
        var parent = element.parentNode;
        if (parent) {
            newElement = new JQLite(newElement);
            var i = 0;
            var ii = newElement.length;
            let v11871 = i < ii;
            while (v11871) {
                var node = newElement[i];
                const v11873 = index.nextSibling;
                const v11874 = parent.insertBefore(node, v11873);
                v11874;
                index = node;
                const v11872 = i++;
                v11871 = i < ii;
            }
        }
    };
    const v11884 = function (element, selector, condition) {
        if (selector) {
            const v11876 = selector.split(' ');
            const v11882 = function (className) {
                var classCondition = condition;
                const v11877 = isUndefined(classCondition);
                if (v11877) {
                    const v11878 = jqLiteHasClass(element, className);
                    const v11879 = !v11878;
                    classCondition = v11879;
                }
                let v11880;
                if (classCondition) {
                    v11880 = jqLiteAddClass;
                } else {
                    v11880 = jqLiteRemoveClass;
                }
                const v11881 = v11880(element, className);
                v11881;
            };
            const v11883 = forEach(v11876, v11882);
            v11883;
        }
    };
    const v11889 = function (element) {
        var parent = element.parentNode;
        const v11885 = parent.nodeType;
        const v11886 = v11885 !== NODE_TYPE_DOCUMENT_FRAGMENT;
        const v11887 = parent && v11886;
        let v11888;
        if (v11887) {
            v11888 = parent;
        } else {
            v11888 = null;
        }
        return v11888;
    };
    const v11891 = function (element) {
        const v11890 = element.nextElementSibling;
        return v11890;
    };
    const v11895 = function (element, selector) {
        const v11892 = element.getElementsByTagName;
        if (v11892) {
            const v11893 = element.getElementsByTagName(selector);
            return v11893;
        } else {
            const v11894 = [];
            return v11894;
        }
    };
    const v11916 = function (element, event, extraParameters) {
        var dummyEvent;
        var eventFnsCopy;
        var handlerArgs;
        const v11896 = event.type;
        var eventName = v11896 || event;
        var expandoStore = jqLiteExpandoStore(element);
        const v11897 = expandoStore.events;
        var events = expandoStore && v11897;
        const v11898 = events[eventName];
        var eventFns = events && v11898;
        if (eventFns) {
            const v11899 = function () {
                this.defaultPrevented = true;
            };
            const v11902 = function () {
                const v11900 = this.defaultPrevented;
                const v11901 = v11900 === true;
                return v11901;
            };
            const v11903 = function () {
                this.immediatePropagationStopped = true;
            };
            const v11906 = function () {
                const v11904 = this.immediatePropagationStopped;
                const v11905 = v11904 === true;
                return v11905;
            };
            dummyEvent.preventDefault = v11899;
            dummyEvent.isDefaultPrevented = v11902;
            dummyEvent.stopImmediatePropagation = v11903;
            dummyEvent.isImmediatePropagationStopped = v11906;
            dummyEvent.stopPropagation = noop;
            dummyEvent.type = eventName;
            dummyEvent.target = element;
            dummyEvent = {};
            dummyEvent = {};
            const v11907 = event.type;
            if (v11907) {
                dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            const v11908 = [dummyEvent];
            const v11909 = v11908.concat(extraParameters);
            const v11910 = [dummyEvent];
            if (extraParameters) {
                handlerArgs = v11909;
            } else {
                handlerArgs = v11910;
            }
            const v11914 = function (fn) {
                const v11911 = dummyEvent.isImmediatePropagationStopped();
                const v11912 = !v11911;
                if (v11912) {
                    const v11913 = fn.apply(element, handlerArgs);
                    v11913;
                }
            };
            const v11915 = forEach(eventFnsCopy, v11914);
            v11915;
        }
    };
    const v11917 = {
        removeData: jqLiteRemoveData,
        on: v11821,
        off: jqLiteOff,
        one: v11827,
        replaceWith: v11835,
        children: v11842,
        contents: v11848,
        append: v11855,
        prepend: v11862,
        wrap: v11868,
        remove: jqLiteRemove,
        detach: v11870,
        after: v11875,
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: v11884,
        parent: v11889,
        next: v11891,
        find: v11895,
        clone: jqLiteClone,
        triggerHandler: v11916
    };
    const v11930 = function (fn, name) {
        const v11918 = JQLite.prototype;
        const v11929 = function (arg1, arg2, arg3) {
            var value;
            var i = 0;
            var ii = this.length;
            let v11919 = i < ii;
            while (v11919) {
                const v11921 = isUndefined(value);
                if (v11921) {
                    const v11922 = this[i];
                    value = fn(v11922, arg1, arg2, arg3);
                    const v11923 = isDefined(value);
                    if (v11923) {
                        value = jqLite(value);
                    }
                } else {
                    const v11924 = this[i];
                    const v11925 = fn(v11924, arg1, arg2, arg3);
                    const v11926 = jqLiteAddNodes(value, v11925);
                    v11926;
                }
                const v11920 = i++;
                v11919 = i < ii;
            }
            const v11927 = isDefined(value);
            let v11928;
            if (v11927) {
                v11928 = value;
            } else {
                v11928 = this;
            }
            return v11928;
        };
        v11918[name] = v11929;
    };
    const v11931 = forEach(v11917, v11930);
    v11931;
    const v11932 = JQLite.prototype;
    const v11933 = JQLite.prototype;
    const v11934 = v11933.on;
    v11932.bind = v11934;
    const v11935 = JQLite.prototype;
    const v11936 = JQLite.prototype;
    const v11937 = v11936.off;
    v11935.unbind = v11937;
    const $$jqLiteProvider = function () {
        const $$jqLite = function () {
            const v11940 = function (node, classes) {
                const v11938 = node.attr;
                if (v11938) {
                    node = node[0];
                }
                const v11939 = jqLiteHasClass(node, classes);
                return v11939;
            };
            const v11943 = function (node, classes) {
                const v11941 = node.attr;
                if (v11941) {
                    node = node[0];
                }
                const v11942 = jqLiteAddClass(node, classes);
                return v11942;
            };
            const v11946 = function (node, classes) {
                const v11944 = node.attr;
                if (v11944) {
                    node = node[0];
                }
                const v11945 = jqLiteRemoveClass(node, classes);
                return v11945;
            };
            const v11947 = {
                hasClass: v11940,
                addClass: v11943,
                removeClass: v11946
            };
            const v11948 = extend(JQLite, v11947);
            return v11948;
        };
        this.$get = $$jqLite;
    };
    const hashKey = function (obj, nextUidFn) {
        const v11949 = obj.$$hashKey;
        var key = obj && v11949;
        if (key) {
            const v11950 = typeof key;
            const v11951 = v11950 === 'function';
            if (v11951) {
                key = obj.$$hashKey();
            }
            return key;
        }
        const v11952 = typeof obj;
        var objType = v11952;
        const v11953 = objType === 'function';
        const v11954 = objType === 'object';
        const v11955 = obj !== null;
        const v11956 = v11954 && v11955;
        const v11957 = v11953 || v11956;
        if (v11957) {
            const v11958 = objType + ':';
            const v11959 = nextUidFn || nextUid;
            const v11960 = v11959();
            obj.$$hashKey = v11958 + v11960;
            key = obj.$$hashKey;
        } else {
            const v11961 = objType + ':';
            key = v11961 + obj;
        }
        return key;
    };
    var nanKey = Object.create(null);
    const NgMapShim = function () {
        this._keys = [];
        this._values = [];
        this._lastKey = NaN;
        const v11962 = -1;
        this._lastIndex = v11962;
    };
    const v11968 = function (key) {
        const v11963 = this._lastKey;
        const v11964 = key !== v11963;
        if (v11964) {
            this._lastKey = key;
            const v11965 = this._keys;
            const v11966 = v11965.indexOf(key);
            this._lastIndex = v11966;
        }
        const v11967 = this._lastIndex;
        return v11967;
    };
    const v11971 = function (key) {
        const v11969 = isNumberNaN(key);
        let v11970;
        if (v11969) {
            v11970 = nanKey;
        } else {
            v11970 = key;
        }
        return v11970;
    };
    const v11976 = function (key) {
        key = this._transformKey(key);
        var idx = this._idx(key);
        const v11972 = -1;
        const v11973 = idx !== v11972;
        if (v11973) {
            const v11974 = this._values;
            const v11975 = v11974[idx];
            return v11975;
        }
    };
    const v11979 = function (key) {
        key = this._transformKey(key);
        var idx = this._idx(key);
        const v11977 = -1;
        const v11978 = idx !== v11977;
        return v11978;
    };
    const v11986 = function (key, value) {
        key = this._transformKey(key);
        var idx = this._idx(key);
        const v11980 = -1;
        const v11981 = idx === v11980;
        if (v11981) {
            const v11982 = this._keys;
            const v11983 = v11982.length;
            idx = this._lastIndex = v11983;
        }
        const v11984 = this._keys;
        v11984[idx] = key;
        const v11985 = this._values;
        v11985[idx] = value;
    };
    const v11994 = function (key) {
        key = this._transformKey(key);
        var idx = this._idx(key);
        const v11987 = -1;
        const v11988 = idx === v11987;
        if (v11988) {
            return false;
        }
        const v11989 = this._keys;
        const v11990 = v11989.splice(idx, 1);
        v11990;
        const v11991 = this._values;
        const v11992 = v11991.splice(idx, 1);
        v11992;
        this._lastKey = NaN;
        const v11993 = -1;
        this._lastIndex = v11993;
        return true;
    };
    const v11995 = {};
    v11995._idx = v11968;
    v11995._transformKey = v11971;
    v11995.get = v11976;
    v11995.has = v11979;
    v11995.set = v11986;
    v11995.delete = v11994;
    NgMapShim.prototype = v11995;
    var NgMap = NgMapShim;
    const v11997 = function () {
        const v11996 = function () {
            return NgMap;
        };
        this.$get = [v11996];
    };
    var $$MapProvider = [v11997];
    var ARROW_ARG = /^([^(]+?)=>/;
    var FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    var $injectorMinErr = minErr('$injector');
    const stringifyFn = function (fn) {
        const v11998 = Function.prototype;
        const v11999 = v11998.toString;
        const v12000 = v11999.call(fn);
        return v12000;
    };
    const extractArgs = function (fn) {
        const v12001 = stringifyFn(fn);
        var fnText = v12001.replace(STRIP_COMMENTS, '');
        const v12002 = fnText.match(ARROW_ARG);
        const v12003 = fnText.match(FN_ARGS);
        var args = v12002 || v12003;
        return args;
    };
    const anonFn = function (fn) {
        var args = extractArgs(fn);
        if (args) {
            const v12004 = args[1];
            const v12005 = v12004 || '';
            const v12006 = v12005.replace(/[\s\r\n]+/, ' ');
            const v12007 = 'function(' + v12006;
            const v12008 = v12007 + ')';
            return v12008;
        }
        return 'fn';
    };
    const annotate = function (fn, strictDi, name) {
        var $inject;
        var argDecl;
        var last;
        const v12009 = typeof fn;
        const v12010 = v12009 === 'function';
        if (v12010) {
            const v12011 = !($inject = fn.$inject);
            if (v12011) {
                $inject = [];
                const v12012 = fn.length;
                if (v12012) {
                    if (strictDi) {
                        const v12013 = isString(name);
                        const v12014 = !v12013;
                        const v12015 = !name;
                        const v12016 = v12014 || v12015;
                        if (v12016) {
                            const v12017 = fn.name;
                            const v12018 = anonFn(fn);
                            name = v12017 || v12018;
                        }
                        const v12019 = $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
                        throw v12019;
                    }
                    argDecl = extractArgs(fn);
                    const v12020 = argDecl[1];
                    const v12021 = v12020.split(FN_ARG_SPLIT);
                    const v12025 = function (arg) {
                        const v12023 = function (all, underscore, name) {
                            const v12022 = $inject.push(name);
                            v12022;
                        };
                        const v12024 = arg.replace(FN_ARG, v12023);
                        v12024;
                    };
                    const v12026 = forEach(v12021, v12025);
                    v12026;
                }
                fn.$inject = $inject;
            }
        } else {
            const v12027 = isArray(fn);
            if (v12027) {
                const v12028 = fn.length;
                last = v12028 - 1;
                const v12029 = fn[last];
                const v12030 = assertArgFn(v12029, 'fn');
                v12030;
                $inject = fn.slice(0, last);
            } else {
                const v12031 = assertArgFn(fn, 'fn', true);
                v12031;
            }
        }
        return $inject;
    };
    const createInjector = function (modulesToLoad, strictDi) {
        strictDi = strictDi === true;
        var INSTANTIATING = {};
        var providerSuffix = 'Provider';
        var path = [];
        var loadedModules = new NgMap();
        const v12032 = supportObject(provider);
        const v12033 = supportObject(factory);
        const v12034 = supportObject(service);
        const v12035 = supportObject(value);
        const v12036 = supportObject(constant);
        const v12037 = {};
        v12037.provider = v12032;
        v12037.factory = v12033;
        v12037.service = v12034;
        v12037.value = v12035;
        v12037.constant = v12036;
        v12037.decorator = decorator;
        var providerCache = {};
        providerCache.$provide = v12037;
        const v12042 = function (serviceName, caller) {
            const v12038 = angular.isString(caller);
            if (v12038) {
                const v12039 = path.push(caller);
                v12039;
            }
            const v12040 = path.join(' <- ');
            const v12041 = $injectorMinErr('unpr', 'Unknown provider: {0}', v12040);
            throw v12041;
        };
        const v12043 = createInternalInjector(providerCache, v12042);
        providerCache.$injector = v12043;
        var providerInjector = providerCache.$injector;
        var instanceCache = {};
        const v12047 = function (serviceName, caller) {
            const v12044 = serviceName + providerSuffix;
            var provider = providerInjector.get(v12044, caller);
            const v12045 = provider.$get;
            const v12046 = instanceInjector.invoke(v12045, provider, undefined, serviceName);
            return v12046;
        };
        var protoInstanceInjector = createInternalInjector(instanceCache, v12047);
        var instanceInjector = protoInstanceInjector;
        const v12048 = '$injector' + providerSuffix;
        const v12049 = valueFn(protoInstanceInjector);
        const v12050 = {};
        v12050.$get = v12049;
        providerCache[v12048] = v12050;
        const v12051 = createMap();
        providerInjector.modules = v12051;
        instanceInjector.modules = providerInjector.modules;
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get('$injector');
        instanceInjector.strictDi = strictDi;
        const v12053 = function (fn) {
            if (fn) {
                const v12052 = instanceInjector.invoke(fn);
                v12052;
            }
        };
        const v12054 = forEach(runBlocks, v12053);
        v12054;
        const v12059 = function (mods) {
            const v12055 = loadModules(mods);
            const v12057 = function (fn) {
                if (fn) {
                    const v12056 = instanceInjector.invoke(fn);
                    v12056;
                }
            };
            const v12058 = forEach(v12055, v12057);
            v12058;
        };
        instanceInjector.loadNewModules = v12059;
        return instanceInjector;
        const supportObject = function (delegate) {
            const v12064 = function (key, value) {
                const v12060 = isObject(key);
                if (v12060) {
                    const v12061 = reverseParams(delegate);
                    const v12062 = forEach(key, v12061);
                    v12062;
                } else {
                    const v12063 = delegate(key, value);
                    return v12063;
                }
            };
            return v12064;
        };
        const provider = function (name, provider_) {
            const v12065 = assertNotHasOwnProperty(name, 'service');
            v12065;
            const v12066 = isFunction(provider_);
            const v12067 = isArray(provider_);
            const v12068 = v12066 || v12067;
            if (v12068) {
                provider_ = providerInjector.instantiate(provider_);
            }
            const v12069 = provider_.$get;
            const v12070 = !v12069;
            if (v12070) {
                const v12071 = $injectorMinErr('pget', 'Provider \'{0}\' must define $get factory method.', name);
                throw v12071;
            }
            const v12072 = name + providerSuffix;
            return providerCache[v12072] = provider_;
        };
        const enforceReturnValue = function (name, factory) {
            const v12075 = function enforcedReturnValue() {
                var result = instanceInjector.invoke(factory, this);
                const v12073 = isUndefined(result);
                if (v12073) {
                    const v12074 = $injectorMinErr('undef', 'Provider \'{0}\' must return a value from $get factory method.', name);
                    throw v12074;
                }
                return result;
            };
            return v12075;
        };
        const factory = function (name, factoryFn, enforce) {
            const v12076 = enforce !== false;
            const v12077 = enforceReturnValue(name, factoryFn);
            let v12078;
            if (v12076) {
                v12078 = v12077;
            } else {
                v12078 = factoryFn;
            }
            const v12079 = { $get: v12078 };
            const v12080 = provider(name, v12079);
            return v12080;
        };
        const service = function (name, constructor) {
            const v12082 = function ($injector) {
                const v12081 = $injector.instantiate(constructor);
                return v12081;
            };
            const v12083 = [
                '$injector',
                v12082
            ];
            const v12084 = factory(name, v12083);
            return v12084;
        };
        const value = function (name, val) {
            const v12085 = valueFn(val);
            const v12086 = factory(name, v12085, false);
            return v12086;
        };
        const constant = function (name, value) {
            const v12087 = assertNotHasOwnProperty(name, 'constant');
            v12087;
            providerCache[name] = value;
            instanceCache[name] = value;
        };
        const decorator = function (serviceName, decorFn) {
            const v12088 = serviceName + providerSuffix;
            var origProvider = providerInjector.get(v12088);
            var orig$get = origProvider.$get;
            const v12091 = function () {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                const v12089 = { $delegate: origInstance };
                const v12090 = instanceInjector.invoke(decorFn, null, v12089);
                return v12090;
            };
            origProvider.$get = v12091;
        };
        const loadModules = function (modulesToLoad) {
            const v12092 = isUndefined(modulesToLoad);
            const v12093 = isArray(modulesToLoad);
            const v12094 = v12092 || v12093;
            const v12095 = assertArg(v12094, 'modulesToLoad', 'not an array');
            v12095;
            var runBlocks = [];
            var moduleFn;
            const v12142 = function (module) {
                const v12096 = loadedModules.get(module);
                if (v12096) {
                    return;
                }
                const v12097 = loadedModules.set(module, true);
                v12097;
                const runInvokeQueue = function (queue) {
                    var i;
                    var ii;
                    (i = 0, ii = queue.length)
                    let v12098 = i < ii;
                    while (v12098) {
                        var invokeArgs = queue[i];
                        const v12100 = invokeArgs[0];
                        var provider = providerInjector.get(v12100);
                        const v12101 = invokeArgs[1];
                        const v12102 = provider[v12101];
                        const v12103 = invokeArgs[2];
                        const v12104 = v12102.apply(provider, v12103);
                        v12104;
                        const v12099 = i++;
                        v12098 = i < ii;
                    }
                };
                try {
                    const v12105 = isString(module);
                    if (v12105) {
                        moduleFn = angularModule(module);
                        const v12106 = instanceInjector.modules;
                        v12106[module] = moduleFn;
                        const v12107 = moduleFn.requires;
                        const v12108 = loadModules(v12107);
                        const v12109 = runBlocks.concat(v12108);
                        const v12110 = moduleFn._runBlocks;
                        runBlocks = v12109.concat(v12110);
                        const v12111 = moduleFn._invokeQueue;
                        const v12112 = runInvokeQueue(v12111);
                        v12112;
                        const v12113 = moduleFn._configBlocks;
                        const v12114 = runInvokeQueue(v12113);
                        v12114;
                    } else {
                        const v12115 = isFunction(module);
                        if (v12115) {
                            const v12116 = providerInjector.invoke(module);
                            const v12117 = runBlocks.push(v12116);
                            v12117;
                        } else {
                            const v12118 = isArray(module);
                            if (v12118) {
                                const v12119 = providerInjector.invoke(module);
                                const v12120 = runBlocks.push(v12119);
                                v12120;
                            } else {
                                const v12121 = assertArgFn(module, 'module');
                                v12121;
                            }
                        }
                    }
                } catch (e) {
                    const v12122 = isArray(module);
                    if (v12122) {
                        const v12123 = module.length;
                        const v12124 = v12123 - 1;
                        module = module[v12124];
                    }
                    const v12125 = e.message;
                    const v12126 = e.stack;
                    const v12127 = v12125 && v12126;
                    const v12128 = e.stack;
                    const v12129 = e.message;
                    const v12130 = v12128.indexOf(v12129);
                    const v12131 = -1;
                    const v12132 = v12130 === v12131;
                    const v12133 = v12127 && v12132;
                    if (v12133) {
                        const v12134 = e.message;
                        const v12135 = v12134 + '\n';
                        const v12136 = e.stack;
                        e = v12135 + v12136;
                    }
                    const v12137 = e.stack;
                    const v12138 = e.message;
                    const v12139 = v12137 || v12138;
                    const v12140 = v12139 || e;
                    const v12141 = $injectorMinErr('modulerr', 'Failed to instantiate module {0} due to:\n{1}', module, v12140);
                    throw v12141;
                }
            };
            const v12143 = forEach(modulesToLoad, v12142);
            v12143;
            return runBlocks;
        };
        const createInternalInjector = function (cache, factory) {
            const getService = function (serviceName, caller) {
                const v12144 = cache.hasOwnProperty(serviceName);
                if (v12144) {
                    const v12145 = cache[serviceName];
                    const v12146 = v12145 === INSTANTIATING;
                    if (v12146) {
                        const v12147 = serviceName + ' <- ';
                        const v12148 = path.join(' <- ');
                        const v12149 = v12147 + v12148;
                        const v12150 = $injectorMinErr('cdep', 'Circular dependency found: {0}', v12149);
                        throw v12150;
                    }
                    const v12151 = cache[serviceName];
                    return v12151;
                } else {
                    try {
                        const v12152 = path.unshift(serviceName);
                        v12152;
                        cache[serviceName] = INSTANTIATING;
                        const v12153 = factory(serviceName, caller);
                        cache[serviceName] = v12153;
                        const v12154 = cache[serviceName];
                        return v12154;
                    } catch (err) {
                        const v12155 = cache[serviceName];
                        const v12156 = v12155 === INSTANTIATING;
                        if (v12156) {
                            const v12157 = cache[serviceName];
                            const v12158 = delete v12157;
                            v12158;
                        }
                        throw err;
                    } finally {
                        const v12159 = path.shift();
                        v12159;
                    }
                }
            };
            const injectionArgs = function (fn, locals, serviceName) {
                var args = [];
                var $inject = createInjector.$$annotate(fn, strictDi, serviceName);
                var i = 0;
                var length = $inject.length;
                let v12160 = i < length;
                while (v12160) {
                    var key = $inject[i];
                    const v12162 = typeof key;
                    const v12163 = v12162 !== 'string';
                    if (v12163) {
                        const v12164 = $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
                        throw v12164;
                    }
                    const v12165 = locals.hasOwnProperty(key);
                    const v12166 = locals && v12165;
                    const v12167 = locals[key];
                    const v12168 = getService(key, serviceName);
                    let v12169;
                    if (v12166) {
                        v12169 = v12167;
                    } else {
                        v12169 = v12168;
                    }
                    const v12170 = args.push(v12169);
                    v12170;
                    const v12161 = i++;
                    v12160 = i < length;
                }
                return args;
            };
            const isClass = function (func) {
                const v12171 = typeof func;
                const v12172 = v12171 !== 'function';
                const v12173 = msie || v12172;
                if (v12173) {
                    return false;
                }
                var result = func.$$ngIsClass;
                const v12174 = isBoolean(result);
                const v12175 = !v12174;
                if (v12175) {
                    const v12176 = stringifyFn(func);
                    const v12177 = /^class\b/.test(v12176);
                    func.$$ngIsClass = v12177;
                    result = func.$$ngIsClass;
                }
                return result;
            };
            const invoke = function (fn, self, locals, serviceName) {
                const v12178 = typeof locals;
                const v12179 = v12178 === 'string';
                if (v12179) {
                    serviceName = locals;
                    locals = null;
                }
                var args = injectionArgs(fn, locals, serviceName);
                const v12180 = isArray(fn);
                if (v12180) {
                    const v12181 = fn.length;
                    const v12182 = v12181 - 1;
                    fn = fn[v12182];
                }
                const v12183 = isClass(fn);
                const v12184 = !v12183;
                if (v12184) {
                    const v12185 = fn.apply(self, args);
                    return v12185;
                } else {
                    const v12186 = args.unshift(null);
                    v12186;
                    const v12187 = Function.prototype;
                    const v12188 = v12187.bind;
                    const v12189 = v12188.apply(fn, args);
                    const v12190 = new v12189();
                    return v12190;
                }
            };
            const instantiate = function (Type, locals, serviceName) {
                let ctor;
                const v12191 = isArray(Type);
                const v12192 = Type.length;
                const v12193 = v12192 - 1;
                const v12194 = Type[v12193];
                if (v12191) {
                    ctor = v12194;
                } else {
                    ctor = Type;
                }
                var args = injectionArgs(Type, locals, serviceName);
                const v12195 = args.unshift(null);
                v12195;
                const v12196 = Function.prototype;
                const v12197 = v12196.bind;
                const v12198 = v12197.apply(ctor, args);
                const v12199 = new v12198();
                return v12199;
            };
            const v12200 = createInjector.$$annotate;
            const v12205 = function (name) {
                const v12201 = name + providerSuffix;
                const v12202 = providerCache.hasOwnProperty(v12201);
                const v12203 = cache.hasOwnProperty(name);
                const v12204 = v12202 || v12203;
                return v12204;
            };
            const v12206 = {};
            v12206.invoke = invoke;
            v12206.instantiate = instantiate;
            v12206.get = getService;
            v12206.annotate = v12200;
            v12206.has = v12205;
            return v12206;
        };
    };
    createInjector.$$annotate = annotate;
    const $AnchorScrollProvider = function () {
        var autoScrollingEnabled = true;
        const v12207 = function () {
            autoScrollingEnabled = false;
        };
        this.disableAutoScrolling = v12207;
        const v12248 = function ($window, $location, $rootScope) {
            var document = $window.document;
            const getFirstAnchor = function (list) {
                var result = null;
                const v12208 = Array.prototype;
                const v12209 = v12208.some;
                const v12212 = function (element) {
                    const v12210 = nodeName_(element);
                    const v12211 = v12210 === 'a';
                    if (v12211) {
                        result = element;
                        return true;
                    }
                };
                const v12213 = v12209.call(list, v12212);
                v12213;
                return result;
            };
            const getYOffset = function () {
                var offset = scroll.yOffset;
                const v12214 = isFunction(offset);
                if (v12214) {
                    offset = offset();
                } else {
                    const v12215 = isElement(offset);
                    if (v12215) {
                        var elem = offset[0];
                        var style = $window.getComputedStyle(elem);
                        const v12216 = style.position;
                        const v12217 = v12216 !== 'fixed';
                        if (v12217) {
                            offset = 0;
                        } else {
                            const v12218 = elem.getBoundingClientRect();
                            offset = v12218.bottom;
                        }
                    } else {
                        const v12219 = isNumber(offset);
                        const v12220 = !v12219;
                        if (v12220) {
                            offset = 0;
                        }
                    }
                }
                return offset;
            };
            const scrollTo = function (elem) {
                if (elem) {
                    const v12221 = elem.scrollIntoView();
                    v12221;
                    var offset = getYOffset();
                    if (offset) {
                        const v12222 = elem.getBoundingClientRect();
                        var elemTop = v12222.top;
                        const v12223 = elemTop - offset;
                        const v12224 = $window.scrollBy(0, v12223);
                        v12224;
                    }
                } else {
                    const v12225 = $window.scrollTo(0, 0);
                    v12225;
                }
            };
            const scroll = function (hash) {
                const v12226 = isString(hash);
                const v12227 = isNumber(hash);
                const v12228 = hash.toString();
                const v12229 = $location.hash();
                let v12230;
                if (v12227) {
                    v12230 = v12228;
                } else {
                    v12230 = v12229;
                }
                if (v12226) {
                    hash = hash;
                } else {
                    hash = v12230;
                }
                var elm;
                const v12231 = !hash;
                if (v12231) {
                    const v12232 = scrollTo(null);
                    v12232;
                } else {
                    if (elm = document.getElementById(hash)) {
                        const v12233 = scrollTo(elm);
                        v12233;
                    } else {
                        const v12234 = document.getElementsByName(hash);
                        if (elm = getFirstAnchor(v12234)) {
                            const v12235 = scrollTo(elm);
                            v12235;
                        } else {
                            const v12236 = hash === 'top';
                            if (v12236) {
                                const v12237 = scrollTo(null);
                                v12237;
                            }
                        }
                    }
                }
            };
            if (autoScrollingEnabled) {
                const v12239 = function autoScrollWatch() {
                    const v12238 = $location.hash();
                    return v12238;
                };
                const v12246 = function autoScrollWatchAction(newVal, oldVal) {
                    const v12240 = newVal === oldVal;
                    const v12241 = newVal === '';
                    const v12242 = v12240 && v12241;
                    if (v12242) {
                        return;
                    }
                    const v12244 = function () {
                        const v12243 = $rootScope.$evalAsync(scroll);
                        v12243;
                    };
                    const v12245 = jqLiteDocumentLoaded(v12244);
                    v12245;
                };
                const v12247 = $rootScope.$watch(v12239, v12246);
                v12247;
            }
            return scroll;
        };
        this.$get = [
            '$window',
            '$location',
            '$rootScope',
            v12248
        ];
    };
    var $animateMinErr = minErr('$animate');
    var ELEMENT_NODE = 1;
    var NG_ANIMATE_CLASSNAME = 'ng-animate';
    const mergeClasses = function (a, b) {
        const v12249 = !a;
        const v12250 = !b;
        const v12251 = v12249 && v12250;
        if (v12251) {
            return '';
        }
        const v12252 = !a;
        if (v12252) {
            return b;
        }
        const v12253 = !b;
        if (v12253) {
            return a;
        }
        const v12254 = isArray(a);
        if (v12254) {
            a = a.join(' ');
        }
        const v12255 = isArray(b);
        if (v12255) {
            b = b.join(' ');
        }
        const v12256 = a + ' ';
        const v12257 = v12256 + b;
        return v12257;
    };
    const extractElementNode = function (element) {
        var i = 0;
        const v12258 = element.length;
        let v12259 = i < v12258;
        while (v12259) {
            var elm = element[i];
            const v12261 = elm.nodeType;
            const v12262 = v12261 === ELEMENT_NODE;
            if (v12262) {
                return elm;
            }
            const v12260 = i++;
            v12259 = i < v12258;
        }
    };
    const splitClasses = function (classes) {
        const v12263 = isString(classes);
        if (v12263) {
            classes = classes.split(' ');
        }
        var obj = createMap();
        const v12265 = function (klass) {
            const v12264 = klass.length;
            if (v12264) {
                obj[klass] = true;
            }
        };
        const v12266 = forEach(classes, v12265);
        v12266;
        return obj;
    };
    const prepareAnimateOptions = function (options) {
        const v12267 = isObject(options);
        const v12268 = {};
        let v12269;
        if (v12267) {
            v12269 = options;
        } else {
            v12269 = v12268;
        }
        return v12269;
    };
    var $$CoreAnimateJsProvider = function () {
        this.$get = noop;
    };
    var $$CoreAnimateQueueProvider = function () {
        var postDigestQueue = new NgMap();
        var postDigestElements = [];
        const v12320 = function ($$AnimateRunner, $rootScope) {
            const v12285 = function (element, event, options, domOperation) {
                if (domOperation) {
                    const v12270 = domOperation();
                    v12270;
                }
                const v12271 = {};
                options = options || v12271;
                const v12272 = options.from;
                if (v12272) {
                    const v12273 = options.from;
                    const v12274 = element.css(v12273);
                    v12274;
                }
                const v12275 = options.to;
                if (v12275) {
                    const v12276 = options.to;
                    const v12277 = element.css(v12276);
                    v12277;
                }
                const v12278 = options.addClass;
                const v12279 = options.removeClass;
                const v12280 = v12278 || v12279;
                if (v12280) {
                    const v12281 = options.addClass;
                    const v12282 = options.removeClass;
                    const v12283 = addRemoveClassesPostDigest(element, v12281, v12282);
                    v12283;
                }
                var runner = new $$AnimateRunner();
                const v12284 = runner.complete();
                v12284;
                return runner;
            };
            const v12286 = {};
            v12286.enabled = noop;
            v12286.on = noop;
            v12286.off = noop;
            v12286.pin = noop;
            v12286.push = v12285;
            return v12286;
            const updateData = function (data, classes, value) {
                var changed = false;
                if (classes) {
                    const v12287 = isString(classes);
                    const v12288 = classes.split(' ');
                    const v12289 = isArray(classes);
                    const v12290 = [];
                    let v12291;
                    if (v12289) {
                        v12291 = classes;
                    } else {
                        v12291 = v12290;
                    }
                    if (v12287) {
                        classes = v12288;
                    } else {
                        classes = v12291;
                    }
                    const v12292 = function (className) {
                        if (className) {
                            changed = true;
                            data[className] = value;
                        }
                    };
                    const v12293 = forEach(classes, v12292);
                    v12293;
                }
                return changed;
            };
            const handleCSSClassChanges = function () {
                const v12310 = function (element) {
                    var data = postDigestQueue.get(element);
                    if (data) {
                        const v12294 = element.attr('class');
                        var existing = splitClasses(v12294);
                        var toAdd = '';
                        var toRemove = '';
                        const v12303 = function (status, className) {
                            const v12295 = existing[className];
                            const v12296 = !v12295;
                            const v12297 = !v12296;
                            var hasClass = v12297;
                            const v12298 = status !== hasClass;
                            if (v12298) {
                                if (status) {
                                    const v12299 = toAdd.length;
                                    let v12300;
                                    if (v12299) {
                                        v12300 = ' ';
                                    } else {
                                        v12300 = '';
                                    }
                                    toAdd += v12300 + className;
                                } else {
                                    const v12301 = toRemove.length;
                                    let v12302;
                                    if (v12301) {
                                        v12302 = ' ';
                                    } else {
                                        v12302 = '';
                                    }
                                    toRemove += v12302 + className;
                                }
                            }
                        };
                        const v12304 = forEach(data, v12303);
                        v12304;
                        const v12307 = function (elm) {
                            if (toAdd) {
                                const v12305 = jqLiteAddClass(elm, toAdd);
                                v12305;
                            }
                            if (toRemove) {
                                const v12306 = jqLiteRemoveClass(elm, toRemove);
                                v12306;
                            }
                        };
                        const v12308 = forEach(element, v12307);
                        v12308;
                        const v12309 = postDigestQueue.delete(element);
                        v12309;
                    }
                };
                const v12311 = forEach(postDigestElements, v12310);
                v12311;
                postDigestElements.length = 0;
            };
            const addRemoveClassesPostDigest = function (element, add, remove) {
                const v12312 = postDigestQueue.get(element);
                const v12313 = {};
                var data = v12312 || v12313;
                var classesAdded = updateData(data, add, true);
                var classesRemoved = updateData(data, remove, false);
                const v12314 = classesAdded || classesRemoved;
                if (v12314) {
                    const v12315 = postDigestQueue.set(element, data);
                    v12315;
                    const v12316 = postDigestElements.push(element);
                    v12316;
                    const v12317 = postDigestElements.length;
                    const v12318 = v12317 === 1;
                    if (v12318) {
                        const v12319 = $rootScope.$$postDigest(handleCSSClassChanges);
                        v12319;
                    }
                }
            };
        };
        this.$get = [
            '$$AnimateRunner',
            '$rootScope',
            v12320
        ];
    };
    const v12405 = function ($provide) {
        var provider = this;
        var classNameFilter = null;
        var customFilter = null;
        const v12321 = Object.create(null);
        this.$$registeredAnimations = v12321;
        const v12329 = function (name, factory) {
            const v12322 = name.charAt(0);
            const v12323 = v12322 !== '.';
            const v12324 = name && v12323;
            if (v12324) {
                const v12325 = $animateMinErr('notcsel', 'Expecting class selector starting with \'.\' got \'{0}\'.', name);
                throw v12325;
            }
            var key = name + '-animation';
            const v12326 = provider.$$registeredAnimations;
            const v12327 = name.substr(1);
            v12326[v12327] = key;
            const v12328 = $provide.factory(key, factory);
            v12328;
        };
        this.register = v12329;
        const v12333 = function (filterFn) {
            const v12330 = arguments.length;
            const v12331 = v12330 === 1;
            if (v12331) {
                const v12332 = isFunction(filterFn);
                if (v12332) {
                    customFilter = filterFn;
                } else {
                    customFilter = null;
                }
            }
            return customFilter;
        };
        this.customFilter = v12333;
        const v12342 = function (expression) {
            const v12334 = arguments.length;
            const v12335 = v12334 === 1;
            if (v12335) {
                const v12336 = expression instanceof RegExp;
                if (v12336) {
                    classNameFilter = expression;
                } else {
                    classNameFilter = null;
                }
                if (classNameFilter) {
                    const v12337 = '[(\\s|\\/)]' + NG_ANIMATE_CLASSNAME;
                    const v12338 = v12337 + '[(\\s|\\/)]';
                    var reservedRegex = new RegExp(v12338);
                    const v12339 = classNameFilter.toString();
                    const v12340 = reservedRegex.test(v12339);
                    if (v12340) {
                        classNameFilter = null;
                        const v12341 = $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
                        throw v12341;
                    }
                }
            }
            return classNameFilter;
        };
        this.classNameFilter = v12342;
        const v12404 = function ($$animateQueue) {
            const domInsert = function (element, parentElement, afterElement) {
                if (afterElement) {
                    var afterNode = extractElementNode(afterElement);
                    const v12343 = afterNode.parentNode;
                    const v12344 = !v12343;
                    const v12345 = afterNode && v12344;
                    const v12346 = afterNode.previousElementSibling;
                    const v12347 = !v12346;
                    const v12348 = v12345 && v12347;
                    if (v12348) {
                        afterElement = null;
                    }
                }
                if (afterElement) {
                    const v12349 = afterElement.after(element);
                    v12349;
                } else {
                    const v12350 = parentElement.prepend(element);
                    v12350;
                }
            };
            const v12351 = $$animateQueue.on;
            const v12352 = $$animateQueue.off;
            const v12353 = $$animateQueue.pin;
            const v12354 = $$animateQueue.enabled;
            const v12357 = function (runner) {
                const v12355 = runner.cancel;
                if (v12355) {
                    const v12356 = runner.cancel();
                    v12356;
                }
            };
            const v12364 = function (element, parent, after, options) {
                const v12358 = jqLite(parent);
                parent = parent && v12358;
                const v12359 = jqLite(after);
                after = after && v12359;
                const v12360 = after.parent();
                parent = parent || v12360;
                const v12361 = domInsert(element, parent, after);
                v12361;
                const v12362 = prepareAnimateOptions(options);
                const v12363 = $$animateQueue.push(element, 'enter', v12362);
                return v12363;
            };
            const v12371 = function (element, parent, after, options) {
                const v12365 = jqLite(parent);
                parent = parent && v12365;
                const v12366 = jqLite(after);
                after = after && v12366;
                const v12367 = after.parent();
                parent = parent || v12367;
                const v12368 = domInsert(element, parent, after);
                v12368;
                const v12369 = prepareAnimateOptions(options);
                const v12370 = $$animateQueue.push(element, 'move', v12369);
                return v12370;
            };
            const v12376 = function (element, options) {
                const v12372 = prepareAnimateOptions(options);
                const v12374 = function () {
                    const v12373 = element.remove();
                    v12373;
                };
                const v12375 = $$animateQueue.push(element, 'leave', v12372, v12374);
                return v12375;
            };
            const v12380 = function (element, className, options) {
                options = prepareAnimateOptions(options);
                const v12377 = options.addclass;
                const v12378 = mergeClasses(v12377, className);
                options.addClass = v12378;
                const v12379 = $$animateQueue.push(element, 'addClass', options);
                return v12379;
            };
            const v12384 = function (element, className, options) {
                options = prepareAnimateOptions(options);
                const v12381 = options.removeClass;
                const v12382 = mergeClasses(v12381, className);
                options.removeClass = v12382;
                const v12383 = $$animateQueue.push(element, 'removeClass', options);
                return v12383;
            };
            const v12390 = function (element, add, remove, options) {
                options = prepareAnimateOptions(options);
                const v12385 = options.addClass;
                const v12386 = mergeClasses(v12385, add);
                options.addClass = v12386;
                const v12387 = options.removeClass;
                const v12388 = mergeClasses(v12387, remove);
                options.removeClass = v12388;
                const v12389 = $$animateQueue.push(element, 'setClass', options);
                return v12389;
            };
            const v12402 = function (element, from, to, className, options) {
                options = prepareAnimateOptions(options);
                const v12391 = options.from;
                const v12392 = options.from;
                const v12393 = extend(v12392, from);
                let v12394;
                if (v12391) {
                    v12394 = v12393;
                } else {
                    v12394 = from;
                }
                options.from = v12394;
                const v12395 = options.to;
                const v12396 = options.to;
                const v12397 = extend(v12396, to);
                let v12398;
                if (v12395) {
                    v12398 = v12397;
                } else {
                    v12398 = to;
                }
                options.to = v12398;
                className = className || 'ng-inline-animate';
                const v12399 = options.tempClasses;
                const v12400 = mergeClasses(v12399, className);
                options.tempClasses = v12400;
                const v12401 = $$animateQueue.push(element, 'animate', options);
                return v12401;
            };
            const v12403 = {};
            v12403.on = v12351;
            v12403.off = v12352;
            v12403.pin = v12353;
            v12403.enabled = v12354;
            v12403.cancel = v12357;
            v12403.enter = v12364;
            v12403.move = v12371;
            v12403.leave = v12376;
            v12403.addClass = v12380;
            v12403.removeClass = v12384;
            v12403.setClass = v12390;
            v12403.animate = v12402;
            return v12403;
        };
        this.$get = [
            '$$animateQueue',
            v12404
        ];
    };
    var $AnimateProvider = [
        '$provide',
        v12405
    ];
    var $$AnimateAsyncRunFactoryProvider = function () {
        const v12421 = function ($$rAF) {
            var waitQueue = [];
            const waitForTick = function (fn) {
                const v12406 = waitQueue.push(fn);
                v12406;
                const v12407 = waitQueue.length;
                const v12408 = v12407 > 1;
                if (v12408) {
                    return;
                }
                const v12413 = function () {
                    var i = 0;
                    const v12409 = waitQueue.length;
                    let v12410 = i < v12409;
                    while (v12410) {
                        const v12412 = waitQueue[i]();
                        v12412;
                        const v12411 = i++;
                        v12410 = i < v12409;
                    }
                    waitQueue = [];
                };
                const v12414 = $$rAF(v12413);
                v12414;
            };
            const v12420 = function () {
                var passed = false;
                const v12415 = function () {
                    passed = true;
                };
                const v12416 = waitForTick(v12415);
                v12416;
                const v12419 = function (callback) {
                    if (passed) {
                        const v12417 = callback();
                        v12417;
                    } else {
                        const v12418 = waitForTick(callback);
                        v12418;
                    }
                };
                return v12419;
            };
            return v12420;
        };
        this.$get = [
            '$$rAF',
            v12421
        ];
    };
    var $$AnimateRunnerFactoryProvider = function () {
        const v12512 = function ($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
            var INITIAL_STATE = 0;
            var DONE_PENDING_STATE = 1;
            var DONE_COMPLETE_STATE = 2;
            const v12432 = function (chain, callback) {
                var index = 0;
                const v12422 = next();
                v12422;
                const next = function () {
                    const v12423 = chain.length;
                    const v12424 = index === v12423;
                    if (v12424) {
                        const v12425 = callback(true);
                        v12425;
                        return;
                    }
                    const v12430 = function (response) {
                        const v12426 = response === false;
                        if (v12426) {
                            const v12427 = callback(false);
                            v12427;
                            return;
                        }
                        const v12428 = index++;
                        v12428;
                        const v12429 = next();
                        v12429;
                    };
                    const v12431 = chain[index](v12430);
                    v12431;
                };
            };
            AnimateRunner.chain = v12432;
            const v12440 = function (runners, callback) {
                var count = 0;
                var status = true;
                const v12434 = function (runner) {
                    const v12433 = runner.done(onProgress);
                    v12433;
                };
                const v12435 = forEach(runners, v12434);
                v12435;
                const onProgress = function (response) {
                    status = status && response;
                    const v12436 = ++count;
                    const v12437 = runners.length;
                    const v12438 = v12436 === v12437;
                    if (v12438) {
                        const v12439 = callback(status);
                        v12439;
                    }
                };
            };
            AnimateRunner.all = v12440;
            const AnimateRunner = function (host) {
                const v12441 = this.setHost(host);
                v12441;
                var rafTick = $$animateAsyncRun();
                var timeoutTick = function (fn) {
                    const v12442 = $timeout(fn, 0, false);
                    v12442;
                };
                this._doneCallbacks = [];
                const v12446 = function (fn) {
                    const v12443 = $$isDocumentHidden();
                    if (v12443) {
                        const v12444 = timeoutTick(fn);
                        v12444;
                    } else {
                        const v12445 = rafTick(fn);
                        v12445;
                    }
                };
                this._tick = v12446;
                this._state = 0;
            };
            const v12448 = function (host) {
                const v12447 = {};
                this.host = host || v12447;
            };
            const v12454 = function (fn) {
                const v12449 = this._state;
                const v12450 = v12449 === DONE_COMPLETE_STATE;
                if (v12450) {
                    const v12451 = fn();
                    v12451;
                } else {
                    const v12452 = this._doneCallbacks;
                    const v12453 = v12452.push(fn);
                    v12453;
                }
            };
            const v12465 = function () {
                const v12455 = this.promise;
                const v12456 = !v12455;
                if (v12456) {
                    var self = this;
                    const v12462 = function (resolve, reject) {
                        const v12460 = function (status) {
                            const v12457 = status === false;
                            if (v12457) {
                                const v12458 = reject();
                                v12458;
                            } else {
                                const v12459 = resolve();
                                v12459;
                            }
                        };
                        const v12461 = self.done(v12460);
                        v12461;
                    };
                    const v12463 = $q(v12462);
                    this.promise = v12463;
                }
                const v12464 = this.promise;
                return v12464;
            };
            const v12468 = function (resolveHandler, rejectHandler) {
                const v12466 = this.getPromise();
                const v12467 = v12466.then(resolveHandler, rejectHandler);
                return v12467;
            };
            const v12471 = function (handler) {
                const v12469 = this.getPromise();
                const v12470 = v12469['catch'](handler);
                return v12470;
            };
            const v12474 = function (handler) {
                const v12472 = this.getPromise();
                const v12473 = v12472['finally'](handler);
                return v12473;
            };
            const v12479 = function () {
                const v12475 = this.host;
                const v12476 = v12475.pause;
                if (v12476) {
                    const v12477 = this.host;
                    const v12478 = v12477.pause();
                    v12478;
                }
            };
            const v12484 = function () {
                const v12480 = this.host;
                const v12481 = v12480.resume;
                if (v12481) {
                    const v12482 = this.host;
                    const v12483 = v12482.resume();
                    v12483;
                }
            };
            const v12490 = function () {
                const v12485 = this.host;
                const v12486 = v12485.end;
                if (v12486) {
                    const v12487 = this.host;
                    const v12488 = v12487.end();
                    v12488;
                }
                const v12489 = this._resolve(true);
                v12489;
            };
            const v12496 = function () {
                const v12491 = this.host;
                const v12492 = v12491.cancel;
                if (v12492) {
                    const v12493 = this.host;
                    const v12494 = v12493.cancel();
                    v12494;
                }
                const v12495 = this._resolve(false);
                v12495;
            };
            const v12502 = function (response) {
                var self = this;
                const v12497 = self._state;
                const v12498 = v12497 === INITIAL_STATE;
                if (v12498) {
                    self._state = DONE_PENDING_STATE;
                    const v12500 = function () {
                        const v12499 = self._resolve(response);
                        v12499;
                    };
                    const v12501 = self._tick(v12500);
                    v12501;
                }
            };
            const v12510 = function (response) {
                const v12503 = this._state;
                const v12504 = v12503 !== DONE_COMPLETE_STATE;
                if (v12504) {
                    const v12505 = this._doneCallbacks;
                    const v12507 = function (fn) {
                        const v12506 = fn(response);
                        v12506;
                    };
                    const v12508 = forEach(v12505, v12507);
                    v12508;
                    const v12509 = this._doneCallbacks;
                    v12509.length = 0;
                    this._state = DONE_COMPLETE_STATE;
                }
            };
            const v12511 = {};
            v12511.setHost = v12448;
            v12511.done = v12454;
            v12511.progress = noop;
            v12511.getPromise = v12465;
            v12511.then = v12468;
            v12511['catch'] = v12471;
            v12511['finally'] = v12474;
            v12511.pause = v12479;
            v12511.resume = v12484;
            v12511.end = v12490;
            v12511.cancel = v12496;
            v12511.complete = v12502;
            v12511._resolve = v12510;
            AnimateRunner.prototype = v12511;
            return AnimateRunner;
        };
        this.$get = [
            '$q',
            '$sniffer',
            '$$animateAsyncRun',
            '$$isDocumentHidden',
            '$timeout',
            v12512
        ];
    };
    var $CoreAnimateCssProvider = function () {
        const v12536 = function ($$rAF, $q, $$AnimateRunner) {
            const v12535 = function (element, initialOptions) {
                const v12513 = {};
                var options = initialOptions || v12513;
                const v12514 = options.$$prepared;
                const v12515 = !v12514;
                if (v12515) {
                    options = copy(options);
                }
                const v12516 = options.cleanupStyles;
                if (v12516) {
                    options.to = null;
                    options.from = options.to;
                }
                const v12517 = options.from;
                if (v12517) {
                    const v12518 = options.from;
                    const v12519 = element.css(v12518);
                    v12519;
                    options.from = null;
                }
                var closed;
                var runner = new $$AnimateRunner();
                const v12520 = {};
                v12520.start = run;
                v12520.end = run;
                return v12520;
                const run = function () {
                    const v12524 = function () {
                        const v12521 = applyAnimationContents();
                        v12521;
                        const v12522 = !closed;
                        if (v12522) {
                            const v12523 = runner.complete();
                            v12523;
                        }
                        closed = true;
                    };
                    const v12525 = $$rAF(v12524);
                    v12525;
                    return runner;
                };
                const applyAnimationContents = function () {
                    const v12526 = options.addClass;
                    if (v12526) {
                        const v12527 = options.addClass;
                        const v12528 = element.addClass(v12527);
                        v12528;
                        options.addClass = null;
                    }
                    const v12529 = options.removeClass;
                    if (v12529) {
                        const v12530 = options.removeClass;
                        const v12531 = element.removeClass(v12530);
                        v12531;
                        options.removeClass = null;
                    }
                    const v12532 = options.to;
                    if (v12532) {
                        const v12533 = options.to;
                        const v12534 = element.css(v12533);
                        v12534;
                        options.to = null;
                    }
                };
            };
            return v12535;
        };
        this.$get = [
            '$$rAF',
            '$q',
            '$$AnimateRunner',
            v12536
        ];
    };
    const getHash = function (url) {
        var index = url.indexOf('#');
        const v12537 = -1;
        const v12538 = index === v12537;
        const v12539 = url.substr(index);
        let v12540;
        if (v12538) {
            v12540 = '';
        } else {
            v12540 = v12539;
        }
        return v12540;
    };
    const trimEmptyHash = function (url) {
        const v12541 = url.replace(/#$/, '');
        return v12541;
    };
    const Browser = function (window, document, $log, $sniffer, $$taskTrackerFactory) {
        var self = this;
        var location = window.location;
        var history = window.history;
        var setTimeout = window.setTimeout;
        var clearTimeout = window.clearTimeout;
        var pendingDeferIds = {};
        var taskTracker = $$taskTrackerFactory($log);
        self.isMock = false;
        const v12542 = taskTracker.completeTask;
        self.$$completeOutstandingRequest = v12542;
        const v12543 = taskTracker.incTaskCount;
        self.$$incOutstandingRequestCount = v12543;
        const v12544 = taskTracker.notifyWhenNoPendingTasks;
        self.notifyWhenNoOutstandingRequests = v12544;
        var cachedState;
        var lastHistoryState;
        var lastBrowserUrl = location.href;
        var baseElement = document.find('base');
        var pendingLocation = null;
        let getCurrentState;
        const v12545 = $sniffer.history;
        const v12546 = !v12545;
        const v12548 = function getCurrentState() {
            try {
                const v12547 = history.state;
                return v12547;
            } catch (e) {
            }
        };
        if (v12546) {
            getCurrentState = noop;
        } else {
            getCurrentState = v12548;
        }
        const v12549 = cacheState();
        v12549;
        const v12581 = function (url, replace, state) {
            const v12550 = isUndefined(state);
            if (v12550) {
                state = null;
            }
            const v12551 = window.location;
            const v12552 = location !== v12551;
            if (v12552) {
                location = window.location;
            }
            const v12553 = window.history;
            const v12554 = history !== v12553;
            if (v12554) {
                history = window.history;
            }
            if (url) {
                var sameState = lastHistoryState === state;
                const v12555 = urlResolve(url);
                url = v12555.href;
                const v12556 = lastBrowserUrl === url;
                const v12557 = $sniffer.history;
                const v12558 = !v12557;
                const v12559 = v12558 || sameState;
                const v12560 = v12556 && v12559;
                if (v12560) {
                    return self;
                }
                const v12561 = stripHash(lastBrowserUrl);
                const v12562 = stripHash(url);
                const v12563 = v12561 === v12562;
                var sameBase = lastBrowserUrl && v12563;
                lastBrowserUrl = url;
                lastHistoryState = state;
                const v12564 = $sniffer.history;
                const v12565 = !sameBase;
                const v12566 = !sameState;
                const v12567 = v12565 || v12566;
                const v12568 = v12564 && v12567;
                if (v12568) {
                    let v12569;
                    if (replace) {
                        v12569 = 'replaceState';
                    } else {
                        v12569 = 'pushState';
                    }
                    const v12570 = history[v12569](state, '', url);
                    v12570;
                    const v12571 = cacheState();
                    v12571;
                } else {
                    const v12572 = !sameBase;
                    if (v12572) {
                        pendingLocation = url;
                    }
                    if (replace) {
                        const v12573 = location.replace(url);
                        v12573;
                    } else {
                        const v12574 = !sameBase;
                        if (v12574) {
                            location.href = url;
                        } else {
                            const v12575 = getHash(url);
                            location.hash = v12575;
                        }
                    }
                    const v12576 = location.href;
                    const v12577 = v12576 !== url;
                    if (v12577) {
                        pendingLocation = url;
                    }
                }
                if (pendingLocation) {
                    pendingLocation = url;
                }
                return self;
            } else {
                const v12578 = location.href;
                const v12579 = pendingLocation || v12578;
                const v12580 = trimEmptyHash(v12579);
                return v12580;
            }
        };
        self.url = v12581;
        const v12582 = function () {
            return cachedState;
        };
        self.state = v12582;
        var urlChangeListeners = [];
        var urlChangeInit = false;
        const cacheStateAndFireUrlChange = function () {
            pendingLocation = null;
            const v12583 = fireStateOrUrlChange();
            v12583;
        };
        var lastCachedState = null;
        const cacheState = function () {
            cachedState = getCurrentState();
            const v12584 = isUndefined(cachedState);
            if (v12584) {
                cachedState = null;
            } else {
                cachedState = cachedState;
            }
            const v12585 = equals(cachedState, lastCachedState);
            if (v12585) {
                cachedState = lastCachedState;
            }
            lastCachedState = cachedState;
            lastHistoryState = cachedState;
        };
        const fireStateOrUrlChange = function () {
            var prevLastHistoryState = lastHistoryState;
            const v12586 = cacheState();
            v12586;
            const v12587 = self.url();
            const v12588 = lastBrowserUrl === v12587;
            const v12589 = prevLastHistoryState === cachedState;
            const v12590 = v12588 && v12589;
            if (v12590) {
                return;
            }
            lastBrowserUrl = self.url();
            lastHistoryState = cachedState;
            const v12593 = function (listener) {
                const v12591 = self.url();
                const v12592 = listener(v12591, cachedState);
                v12592;
            };
            const v12594 = forEach(urlChangeListeners, v12593);
            v12594;
        };
        const v12602 = function (callback) {
            const v12595 = !urlChangeInit;
            if (v12595) {
                const v12596 = $sniffer.history;
                if (v12596) {
                    const v12597 = jqLite(window);
                    const v12598 = v12597.on('popstate', cacheStateAndFireUrlChange);
                    v12598;
                }
                const v12599 = jqLite(window);
                const v12600 = v12599.on('hashchange', cacheStateAndFireUrlChange);
                v12600;
                urlChangeInit = true;
            }
            const v12601 = urlChangeListeners.push(callback);
            v12601;
            return callback;
        };
        self.onUrlChange = v12602;
        const v12605 = function () {
            const v12603 = jqLite(window);
            const v12604 = v12603.off('hashchange popstate', cacheStateAndFireUrlChange);
            v12604;
        };
        self.$$applicationDestroyed = v12605;
        self.$$checkUrlChange = fireStateOrUrlChange;
        const v12608 = function () {
            var href = baseElement.attr('href');
            const v12606 = href.replace(/^(https?:)?\/\/[^/]*/, '');
            let v12607;
            if (href) {
                v12607 = v12606;
            } else {
                v12607 = '';
            }
            return v12607;
        };
        self.baseHref = v12608;
        const v12615 = function (fn, delay, taskType) {
            var timeoutId;
            delay = delay || 0;
            const v12609 = taskTracker.DEFAULT_TASK_TYPE;
            taskType = taskType || v12609;
            const v12610 = taskTracker.incTaskCount(taskType);
            v12610;
            const v12614 = function () {
                const v12611 = pendingDeferIds[timeoutId];
                const v12612 = delete v12611;
                v12612;
                const v12613 = taskTracker.completeTask(fn, taskType);
                v12613;
            };
            timeoutId = setTimeout(v12614, delay);
            pendingDeferIds[timeoutId] = taskType;
            return timeoutId;
        };
        self.defer = v12615;
        const v12616 = self.defer;
        const v12622 = function (deferId) {
            const v12617 = pendingDeferIds.hasOwnProperty(deferId);
            if (v12617) {
                var taskType = pendingDeferIds[deferId];
                const v12618 = pendingDeferIds[deferId];
                const v12619 = delete v12618;
                v12619;
                const v12620 = clearTimeout(deferId);
                v12620;
                const v12621 = taskTracker.completeTask(noop, taskType);
                v12621;
                return true;
            }
            return false;
        };
        v12616.cancel = v12622;
    };
    const $BrowserProvider = function () {
        const v12624 = function ($window, $log, $sniffer, $document, $$taskTrackerFactory) {
            const v12623 = new Browser($window, $document, $log, $sniffer, $$taskTrackerFactory);
            return v12623;
        };
        this.$get = [
            '$window',
            '$log',
            '$sniffer',
            '$document',
            '$$taskTrackerFactory',
            v12624
        ];
    };
    const $CacheFactoryProvider = function () {
        const v12691 = function () {
            var caches = {};
            const cacheFactory = function (cacheId, options) {
                const v12625 = cacheId in caches;
                if (v12625) {
                    const v12626 = minErr('$cacheFactory');
                    const v12627 = v12626('iid', 'CacheId \'{0}\' is already taken!', cacheId);
                    throw v12627;
                }
                var size = 0;
                const v12628 = {};
                const v12629 = { id: cacheId };
                var stats = extend(v12628, options, v12629);
                var data = createMap();
                const v12630 = options.capacity;
                const v12631 = options && v12630;
                const v12632 = Number.MAX_VALUE;
                var capacity = v12631 || v12632;
                var lruHash = createMap();
                var freshEnd = null;
                var staleEnd = null;
                const v12645 = function (key, value) {
                    const v12633 = isUndefined(value);
                    if (v12633) {
                        return;
                    }
                    const v12634 = Number.MAX_VALUE;
                    const v12635 = capacity < v12634;
                    if (v12635) {
                        const v12636 = lruHash[key];
                        const v12637 = {};
                        v12637.key = key;
                        var lruEntry = v12636 || (lruHash[key] = v12637);
                        const v12638 = refresh(lruEntry);
                        v12638;
                    }
                    const v12639 = key in data;
                    const v12640 = !v12639;
                    if (v12640) {
                        const v12641 = size++;
                        v12641;
                    }
                    data[key] = value;
                    const v12642 = size > capacity;
                    if (v12642) {
                        const v12643 = staleEnd.key;
                        const v12644 = this.remove(v12643);
                        v12644;
                    }
                    return value;
                };
                const v12651 = function (key) {
                    const v12646 = Number.MAX_VALUE;
                    const v12647 = capacity < v12646;
                    if (v12647) {
                        var lruEntry = lruHash[key];
                        const v12648 = !lruEntry;
                        if (v12648) {
                            return;
                        }
                        const v12649 = refresh(lruEntry);
                        v12649;
                    }
                    const v12650 = data[key];
                    return v12650;
                };
                const v12667 = function (key) {
                    const v12652 = Number.MAX_VALUE;
                    const v12653 = capacity < v12652;
                    if (v12653) {
                        var lruEntry = lruHash[key];
                        const v12654 = !lruEntry;
                        if (v12654) {
                            return;
                        }
                        const v12655 = lruEntry === freshEnd;
                        if (v12655) {
                            freshEnd = lruEntry.p;
                        }
                        const v12656 = lruEntry === staleEnd;
                        if (v12656) {
                            staleEnd = lruEntry.n;
                        }
                        const v12657 = lruEntry.n;
                        const v12658 = lruEntry.p;
                        const v12659 = link(v12657, v12658);
                        v12659;
                        const v12660 = lruHash[key];
                        const v12661 = delete v12660;
                        v12661;
                    }
                    const v12662 = key in data;
                    const v12663 = !v12662;
                    if (v12663) {
                        return;
                    }
                    const v12664 = data[key];
                    const v12665 = delete v12664;
                    v12665;
                    const v12666 = size--;
                    v12666;
                };
                const v12668 = function () {
                    data = createMap();
                    size = 0;
                    lruHash = createMap();
                    staleEnd = null;
                    freshEnd = staleEnd;
                };
                const v12671 = function () {
                    data = null;
                    stats = null;
                    lruHash = null;
                    const v12669 = caches[cacheId];
                    const v12670 = delete v12669;
                    v12670;
                };
                const v12675 = function () {
                    const v12672 = {};
                    const v12673 = { size: size };
                    const v12674 = extend(v12672, stats, v12673);
                    return v12674;
                };
                const v12676 = {};
                v12676.put = v12645;
                v12676.get = v12651;
                v12676.remove = v12667;
                v12676.removeAll = v12668;
                v12676.destroy = v12671;
                v12676.info = v12675;
                return caches[cacheId] = v12676;
                const refresh = function (entry) {
                    const v12677 = entry !== freshEnd;
                    if (v12677) {
                        const v12678 = !staleEnd;
                        if (v12678) {
                            staleEnd = entry;
                        } else {
                            const v12679 = staleEnd === entry;
                            if (v12679) {
                                staleEnd = entry.n;
                            }
                        }
                        const v12680 = entry.n;
                        const v12681 = entry.p;
                        const v12682 = link(v12680, v12681);
                        v12682;
                        const v12683 = link(entry, freshEnd);
                        v12683;
                        freshEnd = entry;
                        freshEnd.n = null;
                    }
                };
                const link = function (nextEntry, prevEntry) {
                    const v12684 = nextEntry !== prevEntry;
                    if (v12684) {
                        if (nextEntry) {
                            nextEntry.p = prevEntry;
                        }
                        if (prevEntry) {
                            prevEntry.n = nextEntry;
                        }
                    }
                };
            };
            const v12688 = function () {
                var info = {};
                const v12686 = function (cache, cacheId) {
                    const v12685 = cache.info();
                    info[cacheId] = v12685;
                };
                const v12687 = forEach(caches, v12686);
                v12687;
                return info;
            };
            cacheFactory.info = v12688;
            const v12690 = function (cacheId) {
                const v12689 = caches[cacheId];
                return v12689;
            };
            cacheFactory.get = v12690;
            return cacheFactory;
        };
        this.$get = v12691;
    };
    const $TemplateCacheProvider = function () {
        const v12693 = function ($cacheFactory) {
            const v12692 = $cacheFactory('templates');
            return v12692;
        };
        this.$get = [
            '$cacheFactory',
            v12693
        ];
    };
    var $compileMinErr = minErr('$compile');
    const UNINITIALIZED_VALUE = function () {
    };
    var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
    $CompileProvider.$inject = [
        '$provide',
        '$$sanitizeUriProvider'
    ];
    const $CompileProvider = function ($provide, $$sanitizeUriProvider) {
        var hasDirectives = {};
        var Suffix = 'Directive';
        var COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/;
        var CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/;
        var ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset');
        var REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        var bindingCache = createMap();
        const parseIsolateBindings = function (scope, directiveName, isController) {
            var LOCAL_REGEXP = /^([@&]|[=<](\*?))(\??)\s*([\w$]*)$/;
            var bindings = createMap();
            const v12711 = function (definition, scopeName) {
                definition = definition.trim();
                const v12694 = definition in bindingCache;
                if (v12694) {
                    const v12695 = bindingCache[definition];
                    bindings[scopeName] = v12695;
                    return;
                }
                var match = definition.match(LOCAL_REGEXP);
                const v12696 = !match;
                if (v12696) {
                    const v12697 = 'Invalid {3} for directive \'{0}\'.' + ' Definition: {... {1}: \'{2}\' ...}';
                    let v12698;
                    if (isController) {
                        v12698 = 'controller bindings definition';
                    } else {
                        v12698 = 'isolate scope definition';
                    }
                    const v12699 = $compileMinErr('iscp', v12697, directiveName, scopeName, definition, v12698);
                    throw v12699;
                }
                const v12700 = match[1];
                const v12701 = v12700[0];
                const v12702 = match[2];
                const v12703 = v12702 === '*';
                const v12704 = match[3];
                const v12705 = v12704 === '?';
                const v12706 = match[4];
                const v12707 = v12706 || scopeName;
                const v12708 = {};
                v12708.mode = v12701;
                v12708.collection = v12703;
                v12708.optional = v12705;
                v12708.attrName = v12707;
                bindings[scopeName] = v12708;
                const v12709 = match[4];
                if (v12709) {
                    const v12710 = bindings[scopeName];
                    bindingCache[definition] = v12710;
                }
            };
            const v12712 = forEach(scope, v12711);
            v12712;
            return bindings;
        };
        const parseDirectiveBindings = function (directive, directiveName) {
            var bindings = {};
            bindings.isolateScope = null;
            bindings.bindToController = null;
            const v12713 = directive.scope;
            const v12714 = isObject(v12713);
            if (v12714) {
                const v12715 = directive.bindToController;
                const v12716 = v12715 === true;
                if (v12716) {
                    const v12717 = directive.scope;
                    const v12718 = parseIsolateBindings(v12717, directiveName, true);
                    bindings.bindToController = v12718;
                    const v12719 = {};
                    bindings.isolateScope = v12719;
                } else {
                    const v12720 = directive.scope;
                    const v12721 = parseIsolateBindings(v12720, directiveName, false);
                    bindings.isolateScope = v12721;
                }
            }
            const v12722 = directive.bindToController;
            const v12723 = isObject(v12722);
            if (v12723) {
                const v12724 = directive.bindToController;
                const v12725 = parseIsolateBindings(v12724, directiveName, true);
                bindings.bindToController = v12725;
            }
            const v12726 = bindings.bindToController;
            const v12727 = directive.controller;
            const v12728 = !v12727;
            const v12729 = v12726 && v12728;
            if (v12729) {
                const v12730 = $compileMinErr('noctrl', 'Cannot bind to controller without directive \'{0}\'s controller.', directiveName);
                throw v12730;
            }
            return bindings;
        };
        const assertValidDirectiveName = function (name) {
            var letter = name.charAt(0);
            const v12731 = !letter;
            const v12732 = lowercase(letter);
            const v12733 = letter !== v12732;
            const v12734 = v12731 || v12733;
            if (v12734) {
                const v12735 = $compileMinErr('baddir', 'Directive/Component name \'{0}\' is invalid. The first character must be a lowercase letter', name);
                throw v12735;
            }
            const v12736 = name.trim();
            const v12737 = name !== v12736;
            if (v12737) {
                const v12738 = $compileMinErr('baddir', 'Directive/Component name \'{0}\' is invalid. The name should not contain leading or trailing whitespaces', name);
                throw v12738;
            }
        };
        const getDirectiveRequire = function (directive) {
            const v12739 = directive.require;
            const v12740 = directive.controller;
            const v12741 = directive.name;
            const v12742 = v12740 && v12741;
            var require = v12739 || v12742;
            const v12743 = isArray(require);
            const v12744 = !v12743;
            const v12745 = isObject(require);
            const v12746 = v12744 && v12745;
            if (v12746) {
                const v12751 = function (value, key) {
                    var match = value.match(REQUIRE_PREFIX_REGEXP);
                    const v12747 = match[0];
                    const v12748 = v12747.length;
                    var name = value.substring(v12748);
                    const v12749 = !name;
                    if (v12749) {
                        const v12750 = match[0];
                        require[key] = v12750 + key;
                    }
                };
                const v12752 = forEach(require, v12751);
                v12752;
            }
            return require;
        };
        const getDirectiveRestrict = function (restrict, name) {
            const v12753 = isString(restrict);
            const v12754 = /[EACM]/.test(restrict);
            const v12755 = v12753 && v12754;
            const v12756 = !v12755;
            const v12757 = restrict && v12756;
            if (v12757) {
                const v12758 = $compileMinErr('badrestrict', 'Restrict property \'{0}\' of directive \'{1}\' is invalid', restrict, name);
                throw v12758;
            }
            const v12759 = restrict || 'EA';
            return v12759;
        };
        const registerDirective = function (name, directiveFactory) {
            const v12760 = assertArg(name, 'name');
            v12760;
            const v12761 = assertNotHasOwnProperty(name, 'directive');
            v12761;
            const v12762 = isString(name);
            if (v12762) {
                const v12763 = assertValidDirectiveName(name);
                v12763;
                const v12764 = assertArg(directiveFactory, 'directiveFactory');
                v12764;
                const v12765 = hasDirectives.hasOwnProperty(name);
                const v12766 = !v12765;
                if (v12766) {
                    hasDirectives[name] = [];
                    const v12767 = name + Suffix;
                    const v12787 = function ($injector, $exceptionHandler) {
                        var directives = [];
                        const v12768 = hasDirectives[name];
                        const v12785 = function (directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                const v12769 = isFunction(directive);
                                if (v12769) {
                                    const v12770 = valueFn(directive);
                                    directive.compile = v12770;
                                    directive = {};
                                    directive = {};
                                } else {
                                    const v12771 = directive.compile;
                                    const v12772 = !v12771;
                                    const v12773 = directive.link;
                                    const v12774 = v12772 && v12773;
                                    if (v12774) {
                                        const v12775 = directive.link;
                                        const v12776 = valueFn(v12775);
                                        directive.compile = v12776;
                                    }
                                }
                                const v12777 = directive.priority;
                                directive.priority = v12777 || 0;
                                directive.index = index;
                                const v12778 = directive.name;
                                directive.name = v12778 || name;
                                const v12779 = getDirectiveRequire(directive);
                                directive.require = v12779;
                                const v12780 = directive.restrict;
                                const v12781 = getDirectiveRestrict(v12780, name);
                                directive.restrict = v12781;
                                const v12782 = directiveFactory.$$moduleName;
                                directive.$$moduleName = v12782;
                                const v12783 = directives.push(directive);
                                v12783;
                            } catch (e) {
                                const v12784 = $exceptionHandler(e);
                                v12784;
                            }
                        };
                        const v12786 = forEach(v12768, v12785);
                        v12786;
                        return directives;
                    };
                    const v12788 = [
                        '$injector',
                        '$exceptionHandler',
                        v12787
                    ];
                    const v12789 = $provide.factory(v12767, v12788);
                    v12789;
                }
                const v12790 = hasDirectives[name];
                const v12791 = v12790.push(directiveFactory);
                v12791;
            } else {
                const v12792 = reverseParams(registerDirective);
                const v12793 = forEach(name, v12792);
                v12793;
            }
            return this;
        };
        this.directive = registerDirective;
        const registerComponent = function (name, options) {
            const v12794 = isString(name);
            const v12795 = !v12794;
            if (v12795) {
                const v12796 = bind(this, registerComponent);
                const v12797 = reverseParams(v12796);
                const v12798 = forEach(name, v12797);
                v12798;
                return this;
            }
            const v12799 = options.controller;
            const v12800 = function () {
            };
            var controller = v12799 || v12800;
            const factory = function ($injector) {
                const makeInjectable = function (fn) {
                    const v12801 = isFunction(fn);
                    const v12802 = isArray(fn);
                    const v12803 = v12801 || v12802;
                    if (v12803) {
                        const v12806 = function (tElement, tAttrs) {
                            const v12804 = {
                                $element: tElement,
                                $attrs: tAttrs
                            };
                            const v12805 = $injector.invoke(fn, this, v12804);
                            return v12805;
                        };
                        return v12806;
                    } else {
                        return fn;
                    }
                };
                let template;
                const v12807 = options.template;
                const v12808 = !v12807;
                const v12809 = options.templateUrl;
                const v12810 = !v12809;
                const v12811 = v12808 && v12810;
                const v12812 = options.template;
                if (v12811) {
                    template = '';
                } else {
                    template = v12812;
                }
                const v12813 = options.controller;
                const v12814 = identifierForController(v12813);
                const v12815 = options.controllerAs;
                const v12816 = v12814 || v12815;
                const v12817 = v12816 || '$ctrl';
                const v12818 = makeInjectable(template);
                const v12819 = options.templateUrl;
                const v12820 = makeInjectable(v12819);
                const v12821 = options.transclude;
                const v12822 = {};
                const v12823 = options.bindings;
                const v12824 = {};
                const v12825 = v12823 || v12824;
                const v12826 = options.require;
                var ddo = {};
                ddo.controller = controller;
                ddo.controllerAs = v12817;
                ddo.template = v12818;
                ddo.templateUrl = v12820;
                ddo.transclude = v12821;
                ddo.scope = v12822;
                ddo.bindToController = v12825;
                ddo.restrict = 'E';
                ddo.require = v12826;
                const v12829 = function (val, key) {
                    const v12827 = key.charAt(0);
                    const v12828 = v12827 === '$';
                    if (v12828) {
                        ddo[key] = val;
                    }
                };
                const v12830 = forEach(options, v12829);
                v12830;
                return ddo;
            };
            const v12834 = function (val, key) {
                const v12831 = key.charAt(0);
                const v12832 = v12831 === '$';
                if (v12832) {
                    factory[key] = val;
                    const v12833 = isFunction(controller);
                    if (v12833) {
                        controller[key] = val;
                    }
                }
            };
            const v12835 = forEach(options, v12834);
            v12835;
            factory.$inject = ['$injector'];
            const v12836 = this.directive(name, factory);
            return v12836;
        };
        this.component = registerComponent;
        const v12840 = function (regexp) {
            const v12837 = isDefined(regexp);
            if (v12837) {
                const v12838 = $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                v12838;
                return this;
            } else {
                const v12839 = $$sanitizeUriProvider.aHrefSanitizationWhitelist();
                return v12839;
            }
        };
        this.aHrefSanitizationWhitelist = v12840;
        const v12844 = function (regexp) {
            const v12841 = isDefined(regexp);
            if (v12841) {
                const v12842 = $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                v12842;
                return this;
            } else {
                const v12843 = $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
                return v12843;
            }
        };
        this.imgSrcSanitizationWhitelist = v12844;
        var debugInfoEnabled = true;
        const v12846 = function (enabled) {
            const v12845 = isDefined(enabled);
            if (v12845) {
                debugInfoEnabled = enabled;
                return this;
            }
            return debugInfoEnabled;
        };
        this.debugInfoEnabled = v12846;
        var strictComponentBindingsEnabled = false;
        const v12848 = function (enabled) {
            const v12847 = isDefined(enabled);
            if (v12847) {
                strictComponentBindingsEnabled = enabled;
                return this;
            }
            return strictComponentBindingsEnabled;
        };
        this.strictComponentBindingsEnabled = v12848;
        var TTL = 10;
        const v12850 = function (value) {
            const v12849 = arguments.length;
            if (v12849) {
                TTL = value;
                return this;
            }
            return TTL;
        };
        this.onChangesTtl = v12850;
        var commentDirectivesEnabledConfig = true;
        const v12852 = function (value) {
            const v12851 = arguments.length;
            if (v12851) {
                commentDirectivesEnabledConfig = value;
                return this;
            }
            return commentDirectivesEnabledConfig;
        };
        this.commentDirectivesEnabled = v12852;
        var cssClassDirectivesEnabledConfig = true;
        const v12854 = function (value) {
            const v12853 = arguments.length;
            if (v12853) {
                cssClassDirectivesEnabledConfig = value;
                return this;
            }
            return cssClassDirectivesEnabledConfig;
        };
        this.cssClassDirectivesEnabled = v12854;
        var PROP_CONTEXTS = createMap();
        const v12864 = function (elementName, propertyName, ctx) {
            const v12855 = elementName.toLowerCase();
            const v12856 = v12855 + '|';
            const v12857 = propertyName.toLowerCase();
            var key = v12856 + v12857;
            const v12858 = key in PROP_CONTEXTS;
            const v12859 = PROP_CONTEXTS[key];
            const v12860 = v12859 !== ctx;
            const v12861 = v12858 && v12860;
            if (v12861) {
                const v12862 = PROP_CONTEXTS[key];
                const v12863 = $compileMinErr('ctxoverride', 'Property context \'{0}.{1}\' already set to \'{2}\', cannot override to \'{3}\'.', elementName, propertyName, v12862, ctx);
                throw v12863;
            }
            PROP_CONTEXTS[key] = ctx;
            return this;
        };
        this.addPropertySecurityContext = v12864;
        const v12883 = function registerNativePropertyContexts() {
            const registerContext = function (ctx, values) {
                const v12866 = function (v) {
                    const v12865 = v.toLowerCase();
                    PROP_CONTEXTS[v12865] = ctx;
                };
                const v12867 = forEach(values, v12866);
                v12867;
            };
            const v12868 = SCE_CONTEXTS.HTML;
            const v12869 = [
                'iframe|srcdoc',
                '*|innerHTML',
                '*|outerHTML'
            ];
            const v12870 = registerContext(v12868, v12869);
            v12870;
            const v12871 = SCE_CONTEXTS.CSS;
            const v12872 = ['*|style'];
            const v12873 = registerContext(v12871, v12872);
            v12873;
            const v12874 = SCE_CONTEXTS.URL;
            const v12875 = [
                'area|href',
                'area|ping',
                'a|href',
                'a|ping',
                'blockquote|cite',
                'body|background',
                'del|cite',
                'input|src',
                'ins|cite',
                'q|cite'
            ];
            const v12876 = registerContext(v12874, v12875);
            v12876;
            const v12877 = SCE_CONTEXTS.MEDIA_URL;
            const v12878 = [
                'audio|src',
                'img|src',
                'img|srcset',
                'source|src',
                'source|srcset',
                'track|src',
                'video|src',
                'video|poster'
            ];
            const v12879 = registerContext(v12877, v12878);
            v12879;
            const v12880 = SCE_CONTEXTS.RESOURCE_URL;
            const v12881 = [
                '*|formAction',
                'applet|code',
                'applet|codebase',
                'base|href',
                'embed|src',
                'frame|src',
                'form|action',
                'head|profile',
                'html|manifest',
                'iframe|src',
                'link|href',
                'media|src',
                'object|codebase',
                'object|data',
                'script|src'
            ];
            const v12882 = registerContext(v12880, v12881);
            v12882;
        };
        const v12884 = v12883();
        v12884;
        const v13970 = function ($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate) {
            var SIMPLE_ATTR_NAME = /^\w/;
            const v12885 = window.document;
            var specialAttrHolder = v12885.createElement('div');
            var commentDirectivesEnabled = commentDirectivesEnabledConfig;
            var cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig;
            var onChangesTtl = TTL;
            var onChangesQueue;
            const flushOnChangesQueue = function () {
                try {
                    const v12886 = --onChangesTtl;
                    const v12887 = !v12886;
                    if (v12887) {
                        onChangesQueue = undefined;
                        const v12888 = $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
                        throw v12888;
                    }
                    const v12893 = function () {
                        var i = 0;
                        var ii = onChangesQueue.length;
                        let v12889 = i < ii;
                        while (v12889) {
                            try {
                                const v12891 = onChangesQueue[i]();
                                v12891;
                            } catch (e) {
                                const v12892 = $exceptionHandler(e);
                                v12892;
                            }
                            const v12890 = ++i;
                            v12889 = i < ii;
                        }
                        onChangesQueue = undefined;
                    };
                    const v12894 = $rootScope.$apply(v12893);
                    v12894;
                } finally {
                    const v12895 = onChangesTtl++;
                    v12895;
                }
            };
            const sanitizeSrcset = function (value, invokeType) {
                const v12896 = !value;
                if (v12896) {
                    return value;
                }
                const v12897 = isString(value);
                const v12898 = !v12897;
                if (v12898) {
                    const v12899 = value.toString();
                    const v12900 = $compileMinErr('srcset', 'Can\'t pass trusted values to `{0}`: "{1}"', invokeType, v12899);
                    throw v12900;
                }
                var result = '';
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                let pattern;
                const v12901 = /\s/.test(trimmedSrcset);
                if (v12901) {
                    pattern = srcPattern;
                } else {
                    pattern = /(,)/;
                }
                var rawUris = trimmedSrcset.split(pattern);
                const v12902 = rawUris.length;
                const v12903 = v12902 / 2;
                var nbrUrisWith2parts = Math.floor(v12903);
                var i = 0;
                let v12904 = i < nbrUrisWith2parts;
                while (v12904) {
                    var innerIdx = i * 2;
                    const v12906 = rawUris[innerIdx];
                    const v12907 = trim(v12906);
                    result += $sce.getTrustedMediaUrl(v12907);
                    const v12908 = innerIdx + 1;
                    const v12909 = rawUris[v12908];
                    const v12910 = trim(v12909);
                    result += ' ' + v12910;
                    const v12905 = i++;
                    v12904 = i < nbrUrisWith2parts;
                }
                const v12911 = i * 2;
                const v12912 = rawUris[v12911];
                const v12913 = trim(v12912);
                var lastTuple = v12913.split(/\s/);
                const v12914 = lastTuple[0];
                const v12915 = trim(v12914);
                result += $sce.getTrustedMediaUrl(v12915);
                const v12916 = lastTuple.length;
                const v12917 = v12916 === 2;
                if (v12917) {
                    const v12918 = lastTuple[1];
                    const v12919 = trim(v12918);
                    result += ' ' + v12919;
                }
                return result;
            };
            const Attributes = function (element, attributesToCopy) {
                if (attributesToCopy) {
                    var keys = Object.keys(attributesToCopy);
                    var i;
                    var l;
                    var key;
                    (i = 0, l = keys.length)
                    let v12920 = i < l;
                    while (v12920) {
                        key = keys[i];
                        const v12922 = attributesToCopy[key];
                        this[key] = v12922;
                        const v12921 = i++;
                        v12920 = i < l;
                    }
                } else {
                    const v12923 = {};
                    this.$attr = v12923;
                }
                this.$$element = element;
            };
            const v12929 = function (classVal) {
                const v12924 = classVal.length;
                const v12925 = v12924 > 0;
                const v12926 = classVal && v12925;
                if (v12926) {
                    const v12927 = this.$$element;
                    const v12928 = $animate.addClass(v12927, classVal);
                    v12928;
                }
            };
            const v12935 = function (classVal) {
                const v12930 = classVal.length;
                const v12931 = v12930 > 0;
                const v12932 = classVal && v12931;
                if (v12932) {
                    const v12933 = this.$$element;
                    const v12934 = $animate.removeClass(v12933, classVal);
                    v12934;
                }
            };
            const v12944 = function (newClasses, oldClasses) {
                var toAdd = tokenDifference(newClasses, oldClasses);
                const v12936 = toAdd.length;
                const v12937 = toAdd && v12936;
                if (v12937) {
                    const v12938 = this.$$element;
                    const v12939 = $animate.addClass(v12938, toAdd);
                    v12939;
                }
                var toRemove = tokenDifference(oldClasses, newClasses);
                const v12940 = toRemove.length;
                const v12941 = toRemove && v12940;
                if (v12941) {
                    const v12942 = this.$$element;
                    const v12943 = $animate.removeClass(v12942, toRemove);
                    v12943;
                }
            };
            const v12977 = function (key, value, writeAttr, attrName) {
                const v12945 = this.$$element;
                var node = v12945[0];
                var booleanKey = getBooleanAttrName(node, key);
                var aliasedKey = getAliasedAttrName(key);
                var observer = key;
                var nodeName;
                if (booleanKey) {
                    const v12946 = this.$$element;
                    const v12947 = v12946.prop(key, value);
                    v12947;
                    attrName = booleanKey;
                } else {
                    if (aliasedKey) {
                        this[aliasedKey] = value;
                        observer = aliasedKey;
                    }
                }
                this[key] = value;
                if (attrName) {
                    const v12948 = this.$attr;
                    v12948[key] = attrName;
                } else {
                    const v12949 = this.$attr;
                    attrName = v12949[key];
                    const v12950 = !attrName;
                    if (v12950) {
                        const v12951 = this.$attr;
                        attrName = snake_case(key, '-');
                        v12951[key] = attrName;
                    }
                }
                const v12952 = this.$$element;
                nodeName = nodeName_(v12952);
                const v12953 = nodeName === 'img';
                const v12954 = key === 'srcset';
                const v12955 = v12953 && v12954;
                if (v12955) {
                    value = sanitizeSrcset(value, '$set(\'srcset\', value)');
                    this[key] = value;
                }
                const v12956 = writeAttr !== false;
                if (v12956) {
                    const v12957 = value === null;
                    const v12958 = isUndefined(value);
                    const v12959 = v12957 || v12958;
                    if (v12959) {
                        const v12960 = this.$$element;
                        const v12961 = v12960.removeAttr(attrName);
                        v12961;
                    } else {
                        const v12962 = SIMPLE_ATTR_NAME.test(attrName);
                        if (v12962) {
                            const v12963 = value === false;
                            const v12964 = booleanKey && v12963;
                            if (v12964) {
                                const v12965 = this.$$element;
                                const v12966 = v12965.removeAttr(attrName);
                                v12966;
                            } else {
                                const v12967 = this.$$element;
                                const v12968 = v12967.attr(attrName, value);
                                v12968;
                            }
                        } else {
                            const v12969 = this.$$element;
                            const v12970 = v12969[0];
                            const v12971 = setSpecialAttr(v12970, attrName, value);
                            v12971;
                        }
                    }
                }
                var $$observers = this.$$observers;
                if ($$observers) {
                    const v12972 = $$observers[observer];
                    const v12975 = function (fn) {
                        try {
                            const v12973 = fn(value);
                            v12973;
                        } catch (e) {
                            const v12974 = $exceptionHandler(e);
                            v12974;
                        }
                    };
                    const v12976 = forEach(v12972, v12975);
                    v12976;
                }
            };
            const v12996 = function (key, fn) {
                var attrs = this;
                const v12978 = attrs.$$observers;
                const v12979 = createMap();
                var $$observers = v12978 || (attrs.$$observers = v12979);
                const v12980 = $$observers[key];
                var listeners = v12980 || ($$observers[key] = []);
                const v12981 = listeners.push(fn);
                v12981;
                const v12992 = function () {
                    const v12982 = listeners.$$inter;
                    const v12983 = !v12982;
                    const v12984 = attrs.hasOwnProperty(key);
                    const v12985 = v12983 && v12984;
                    const v12986 = attrs[key];
                    const v12987 = isUndefined(v12986);
                    const v12988 = !v12987;
                    const v12989 = v12985 && v12988;
                    if (v12989) {
                        const v12990 = attrs[key];
                        const v12991 = fn(v12990);
                        v12991;
                    }
                };
                const v12993 = $rootScope.$evalAsync(v12992);
                v12993;
                const v12995 = function () {
                    const v12994 = arrayRemove(listeners, fn);
                    v12994;
                };
                return v12995;
            };
            const v12997 = {};
            v12997.$normalize = directiveNormalize;
            v12997.$addClass = v12929;
            v12997.$removeClass = v12935;
            v12997.$updateClass = v12944;
            v12997.$set = v12977;
            v12997.$observe = v12996;
            Attributes.prototype = v12997;
            const setSpecialAttr = function (element, attrName, value) {
                const v12998 = '<span ' + attrName;
                specialAttrHolder.innerHTML = v12998 + '>';
                const v12999 = specialAttrHolder.firstChild;
                var attributes = v12999.attributes;
                var attribute = attributes[0];
                const v13000 = attribute.name;
                const v13001 = attributes.removeNamedItem(v13000);
                v13001;
                attribute.value = value;
                const v13002 = element.attributes;
                const v13003 = v13002.setNamedItem(attribute);
                v13003;
            };
            const safeAddClass = function ($element, className) {
                try {
                    const v13004 = $element.addClass(className);
                    v13004;
                } catch (e) {
                }
            };
            var startSymbol = $interpolate.startSymbol();
            var endSymbol = $interpolate.endSymbol();
            let denormalizeTemplate;
            const v13005 = startSymbol === '{{';
            const v13006 = endSymbol === '}}';
            const v13007 = v13005 && v13006;
            const v13010 = function denormalizeTemplate(template) {
                const v13008 = template.replace(/\{\{/g, startSymbol);
                const v13009 = v13008.replace(/}}/g, endSymbol);
                return v13009;
            };
            if (v13007) {
                denormalizeTemplate = identity;
            } else {
                denormalizeTemplate = v13010;
            }
            var NG_PREFIX_BINDING = /^ng(Attr|Prop|On)([A-Z].*)$/;
            var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
            const v13016 = function $$addBindingInfo($element, binding) {
                const v13011 = $element.data('$binding');
                const v13012 = [];
                var bindings = v13011 || v13012;
                const v13013 = isArray(binding);
                if (v13013) {
                    bindings = bindings.concat(binding);
                } else {
                    const v13014 = bindings.push(binding);
                    v13014;
                }
                const v13015 = $element.data('$binding', bindings);
                v13015;
            };
            let v13017;
            if (debugInfoEnabled) {
                v13017 = v13016;
            } else {
                v13017 = noop;
            }
            compile.$$addBindingInfo = v13017;
            const v13019 = function $$addBindingClass($element) {
                const v13018 = safeAddClass($element, 'ng-binding');
                v13018;
            };
            let v13020;
            if (debugInfoEnabled) {
                v13020 = v13019;
            } else {
                v13020 = noop;
            }
            compile.$$addBindingClass = v13020;
            const v13023 = function $$addScopeInfo($element, scope, isolated, noTemplate) {
                let dataName;
                let v13021;
                if (noTemplate) {
                    v13021 = '$isolateScopeNoTemplate';
                } else {
                    v13021 = '$isolateScope';
                }
                if (isolated) {
                    dataName = v13021;
                } else {
                    dataName = '$scope';
                }
                const v13022 = $element.data(dataName, scope);
                v13022;
            };
            let v13024;
            if (debugInfoEnabled) {
                v13024 = v13023;
            } else {
                v13024 = noop;
            }
            compile.$$addScopeInfo = v13024;
            const v13027 = function $$addScopeClass($element, isolated) {
                let v13025;
                if (isolated) {
                    v13025 = 'ng-isolate-scope';
                } else {
                    v13025 = 'ng-scope';
                }
                const v13026 = safeAddClass($element, v13025);
                v13026;
            };
            let v13028;
            if (debugInfoEnabled) {
                v13028 = v13027;
            } else {
                v13028 = noop;
            }
            compile.$$addScopeClass = v13028;
            const v13033 = function (directiveName, comment) {
                var content = '';
                if (debugInfoEnabled) {
                    const v13029 = directiveName || '';
                    const v13030 = ' ' + v13029;
                    content = v13030 + ': ';
                    if (comment) {
                        content += comment + ' ';
                    }
                }
                const v13031 = window.document;
                const v13032 = v13031.createComment(content);
                return v13032;
            };
            compile.$$createComment = v13033;
            return compile;
            const compile = function ($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                const v13034 = $compileNodes instanceof jqLite;
                const v13035 = !v13034;
                if (v13035) {
                    $compileNodes = jqLite($compileNodes);
                }
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                const v13036 = compile.$$addScopeClass($compileNodes);
                v13036;
                var namespace = null;
                const v13062 = function publicLinkFn(scope, cloneConnectFn, options) {
                    const v13037 = !$compileNodes;
                    if (v13037) {
                        const v13038 = $compileMinErr('multilink', 'This element has already been linked.');
                        throw v13038;
                    }
                    const v13039 = assertArg(scope, 'scope');
                    v13039;
                    const v13040 = previousCompileContext.needsNewScope;
                    const v13041 = previousCompileContext && v13040;
                    if (v13041) {
                        const v13042 = scope.$parent;
                        scope = v13042.$new();
                    }
                    const v13043 = {};
                    options = options || v13043;
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn;
                    var transcludeControllers = options.transcludeControllers;
                    var futureParentElement = options.futureParentElement;
                    const v13044 = parentBoundTranscludeFn.$$boundTransclude;
                    const v13045 = parentBoundTranscludeFn && v13044;
                    if (v13045) {
                        parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                    }
                    const v13046 = !namespace;
                    if (v13046) {
                        namespace = detectNamespaceForChildElements(futureParentElement);
                    }
                    var $linkNode;
                    const v13047 = namespace !== 'html';
                    if (v13047) {
                        const v13048 = jqLite('<div></div>');
                        const v13049 = v13048.append($compileNodes);
                        const v13050 = v13049.html();
                        const v13051 = wrapTemplate(namespace, v13050);
                        $linkNode = jqLite(v13051);
                    } else {
                        if (cloneConnectFn) {
                            const v13052 = JQLitePrototype.clone;
                            $linkNode = v13052.call($compileNodes);
                        } else {
                            $linkNode = $compileNodes;
                        }
                    }
                    if (transcludeControllers) {
                        let controllerName;
                        for (controllerName in transcludeControllers) {
                            const v13053 = '$' + controllerName;
                            const v13054 = v13053 + 'Controller';
                            const v13055 = transcludeControllers[controllerName];
                            const v13056 = v13055.instance;
                            const v13057 = $linkNode.data(v13054, v13056);
                            v13057;
                        }
                    }
                    const v13058 = compile.$$addScopeInfo($linkNode, scope);
                    v13058;
                    if (cloneConnectFn) {
                        const v13059 = cloneConnectFn($linkNode, scope);
                        v13059;
                    }
                    if (compositeLinkFn) {
                        const v13060 = compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                        v13060;
                    }
                    const v13061 = !cloneConnectFn;
                    if (v13061) {
                        compositeLinkFn = null;
                        $compileNodes = compositeLinkFn;
                    }
                    return $linkNode;
                };
                return v13062;
            };
            const detectNamespaceForChildElements = function (parentElement) {
                const v13063 = parentElement[0];
                var node = parentElement && v13063;
                const v13064 = !node;
                if (v13064) {
                    return 'html';
                } else {
                    const v13065 = nodeName_(node);
                    const v13066 = v13065 !== 'foreignobject';
                    const v13067 = toString.call(node);
                    const v13068 = v13067.match(/SVG/);
                    const v13069 = v13066 && v13068;
                    let v13070;
                    if (v13069) {
                        v13070 = 'svg';
                    } else {
                        v13070 = 'html';
                    }
                    return v13070;
                }
            };
            const compileNodes = function (nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                var linkFns = [];
                const v13071 = isArray(nodeList);
                const v13072 = nodeList instanceof jqLite;
                var notLiveList = v13071 || v13072;
                var attrs;
                var directives;
                var nodeLinkFn;
                var childNodes;
                var childLinkFn;
                var linkFnFound;
                var nodeLinkFnFound;
                var i = 0;
                const v13073 = nodeList.length;
                let v13074 = i < v13073;
                while (v13074) {
                    attrs = new Attributes();
                    const v13076 = msie === 11;
                    if (v13076) {
                        const v13077 = mergeConsecutiveTextNodes(nodeList, i, notLiveList);
                        v13077;
                    }
                    const v13078 = nodeList[i];
                    const v13079 = [];
                    const v13080 = i === 0;
                    let v13081;
                    if (v13080) {
                        v13081 = maxPriority;
                    } else {
                        v13081 = undefined;
                    }
                    directives = collectDirectives(v13078, v13079, attrs, v13081, ignoreDirective);
                    const v13082 = directives.length;
                    const v13083 = nodeList[i];
                    const v13084 = [];
                    const v13085 = [];
                    const v13086 = applyDirectivesToNode(directives, v13083, attrs, transcludeFn, $rootElement, null, v13084, v13085, previousCompileContext);
                    if (v13082) {
                        nodeLinkFn = v13086;
                    } else {
                        nodeLinkFn = null;
                    }
                    const v13087 = nodeLinkFn.scope;
                    const v13088 = nodeLinkFn && v13087;
                    if (v13088) {
                        const v13089 = attrs.$$element;
                        const v13090 = compile.$$addScopeClass(v13089);
                        v13090;
                    }
                    const v13091 = nodeLinkFn.terminal;
                    const v13092 = nodeLinkFn && v13091;
                    const v13093 = nodeList[i];
                    const v13094 = !(childNodes = v13093.childNodes);
                    const v13095 = v13092 || v13094;
                    const v13096 = childNodes.length;
                    const v13097 = !v13096;
                    const v13098 = v13095 || v13097;
                    const v13099 = nodeLinkFn.transcludeOnThisElement;
                    const v13100 = nodeLinkFn.templateOnThisElement;
                    const v13101 = !v13100;
                    const v13102 = v13099 || v13101;
                    const v13103 = nodeLinkFn.transclude;
                    const v13104 = v13102 && v13103;
                    let v13105;
                    if (nodeLinkFn) {
                        v13105 = v13104;
                    } else {
                        v13105 = transcludeFn;
                    }
                    const v13106 = compileNodes(childNodes, v13105);
                    if (v13098) {
                        childLinkFn = null;
                    } else {
                        childLinkFn = v13106;
                    }
                    const v13107 = nodeLinkFn || childLinkFn;
                    if (v13107) {
                        const v13108 = linkFns.push(i, nodeLinkFn, childLinkFn);
                        v13108;
                        linkFnFound = true;
                        nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                    }
                    previousCompileContext = null;
                    const v13075 = i++;
                    v13074 = i < v13073;
                }
                let v13109;
                if (linkFnFound) {
                    v13109 = compositeLinkFn;
                } else {
                    v13109 = null;
                }
                return v13109;
                const compositeLinkFn = function (scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn;
                    var childLinkFn;
                    var node;
                    var childScope;
                    var i;
                    var ii;
                    var idx;
                    var childBoundTranscludeFn;
                    var stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        stableNodeList = new Array(nodeListLength);
                        i = 0
                        const v13110 = linkFns.length;
                        let v13111 = i < v13110;
                        while (v13111) {
                            idx = linkFns[i];
                            const v13112 = nodeList[idx];
                            stableNodeList[idx] = v13112;
                            v13111 = i < v13110;
                        }
                    } else {
                        stableNodeList = nodeList;
                    }
                    (i = 0, ii = linkFns.length)
                    let v13113 = i < ii;
                    while (v13113) {
                        const v13114 = i++;
                        const v13115 = linkFns[v13114];
                        node = stableNodeList[v13115];
                        const v13116 = i++;
                        nodeLinkFn = linkFns[v13116];
                        const v13117 = i++;
                        childLinkFn = linkFns[v13117];
                        if (nodeLinkFn) {
                            const v13118 = nodeLinkFn.scope;
                            if (v13118) {
                                childScope = scope.$new();
                                const v13119 = jqLite(node);
                                const v13120 = compile.$$addScopeInfo(v13119, childScope);
                                v13120;
                            } else {
                                childScope = scope;
                            }
                            const v13121 = nodeLinkFn.transcludeOnThisElement;
                            if (v13121) {
                                const v13122 = nodeLinkFn.transclude;
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, v13122, parentBoundTranscludeFn);
                            } else {
                                const v13123 = nodeLinkFn.templateOnThisElement;
                                const v13124 = !v13123;
                                const v13125 = v13124 && parentBoundTranscludeFn;
                                if (v13125) {
                                    childBoundTranscludeFn = parentBoundTranscludeFn;
                                } else {
                                    const v13126 = !parentBoundTranscludeFn;
                                    const v13127 = v13126 && transcludeFn;
                                    if (v13127) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                                    } else {
                                        childBoundTranscludeFn = null;
                                    }
                                }
                            }
                            const v13128 = nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                            v13128;
                        } else {
                            if (childLinkFn) {
                                const v13129 = node.childNodes;
                                const v13130 = childLinkFn(scope, v13129, undefined, parentBoundTranscludeFn);
                                v13130;
                            }
                        }
                        v13113 = i < ii;
                    }
                };
            };
            const mergeConsecutiveTextNodes = function (nodeList, idx, notLiveList) {
                var node = nodeList[idx];
                var parent = node.parentNode;
                var sibling;
                const v13131 = node.nodeType;
                const v13132 = v13131 !== NODE_TYPE_TEXT;
                if (v13132) {
                    return;
                }
                while (true) {
                    const v13133 = node.nextSibling;
                    const v13134 = idx + 1;
                    const v13135 = nodeList[v13134];
                    if (parent) {
                        sibling = v13133;
                    } else {
                        sibling = v13135;
                    }
                    const v13136 = !sibling;
                    const v13137 = sibling.nodeType;
                    const v13138 = v13137 !== NODE_TYPE_TEXT;
                    const v13139 = v13136 || v13138;
                    if (v13139) {
                        break;
                    }
                    const v13140 = node.nodeValue;
                    const v13141 = sibling.nodeValue;
                    node.nodeValue = v13140 + v13141;
                    const v13142 = sibling.parentNode;
                    if (v13142) {
                        const v13143 = sibling.parentNode;
                        const v13144 = v13143.removeChild(sibling);
                        v13144;
                    }
                    const v13145 = idx + 1;
                    const v13146 = nodeList[v13145];
                    const v13147 = sibling === v13146;
                    const v13148 = notLiveList && v13147;
                    if (v13148) {
                        const v13149 = idx + 1;
                        const v13150 = nodeList.splice(v13149, 1);
                        v13150;
                    }
                }
            };
            const createBoundTranscludeFn = function (scope, transcludeFn, previousBoundTranscludeFn) {
                const boundTranscludeFn = function (transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    const v13151 = !transcludedScope;
                    if (v13151) {
                        transcludedScope = scope.$new(false, containingScope);
                        transcludedScope.$$transcluded = true;
                    }
                    const v13152 = {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    };
                    const v13153 = transcludeFn(transcludedScope, cloneFn, v13152);
                    return v13153;
                };
                const v13154 = createMap();
                boundTranscludeFn.$$slots = v13154;
                var boundSlots = boundTranscludeFn.$$slots;
                let slotName;
                const v13155 = transcludeFn.$$slots;
                for (slotName in v13155) {
                    const v13156 = transcludeFn.$$slots;
                    const v13157 = v13156[slotName];
                    if (v13157) {
                        const v13158 = transcludeFn.$$slots;
                        const v13159 = v13158[slotName];
                        const v13160 = createBoundTranscludeFn(scope, v13159, previousBoundTranscludeFn);
                        boundSlots[slotName] = v13160;
                    } else {
                        boundSlots[slotName] = null;
                    }
                }
                return boundTranscludeFn;
            };
            const collectDirectives = function (node, directives, attrs, maxPriority, ignoreDirective) {
                var nodeType = node.nodeType;
                var attrsMap = attrs.$attr;
                var match;
                var nodeName;
                var className;
                switch (nodeType) {
                case NODE_TYPE_ELEMENT:
                    nodeName = nodeName_(node);
                    const v13161 = directiveNormalize(nodeName);
                    const v13162 = addDirective(directives, v13161, 'E', maxPriority, ignoreDirective);
                    v13162;
                    var attr;
                    var name;
                    var nName;
                    var value;
                    var ngPrefixMatch;
                    var nAttrs = node.attributes;
                    var j = 0;
                    const v13163 = nAttrs.length;
                    var jj = nAttrs && v13163;
                    let v13164 = j < jj;
                    while (v13164) {
                        var attrStartName = false;
                        var attrEndName = false;
                        var isNgAttr = false;
                        var isNgProp = false;
                        var isNgEvent = false;
                        var multiElementMatch;
                        attr = nAttrs[j];
                        name = attr.name;
                        value = attr.value;
                        const v13166 = name.toLowerCase();
                        nName = directiveNormalize(v13166);
                        if (ngPrefixMatch = nName.match(NG_PREFIX_BINDING)) {
                            const v13167 = ngPrefixMatch[1];
                            isNgAttr = v13167 === 'Attr';
                            const v13168 = ngPrefixMatch[1];
                            isNgProp = v13168 === 'Prop';
                            const v13169 = ngPrefixMatch[1];
                            isNgEvent = v13169 === 'On';
                            const v13170 = name.replace(PREFIX_REGEXP, '');
                            const v13171 = v13170.toLowerCase();
                            const v13172 = ngPrefixMatch[1];
                            const v13173 = v13172.length;
                            const v13174 = 4 + v13173;
                            const v13175 = v13171.substr(v13174);
                            const v13177 = function (match, letter) {
                                const v13176 = letter.toUpperCase();
                                return v13176;
                            };
                            name = v13175.replace(/_(.)/g, v13177);
                        } else {
                            const v13178 = multiElementMatch[1];
                            const v13179 = directiveIsMultiElement(v13178);
                            const v13180 = (multiElementMatch = nName.match(MULTI_ELEMENT_DIR_RE)) && v13179;
                            if (v13180) {
                                attrStartName = name;
                                const v13181 = name.length;
                                const v13182 = v13181 - 5;
                                const v13183 = name.substr(0, v13182);
                                attrEndName = v13183 + 'end';
                                const v13184 = name.length;
                                const v13185 = v13184 - 6;
                                name = name.substr(0, v13185);
                            }
                        }
                        const v13186 = isNgProp || isNgEvent;
                        if (v13186) {
                            attrs[nName] = value;
                            const v13187 = attr.name;
                            attrsMap[nName] = v13187;
                            if (isNgProp) {
                                const v13188 = addPropertyDirective(node, directives, nName, name);
                                v13188;
                            } else {
                                const v13189 = addEventDirective(directives, nName, name);
                                v13189;
                            }
                        } else {
                            const v13190 = name.toLowerCase();
                            nName = directiveNormalize(v13190);
                            attrsMap[nName] = name;
                            const v13191 = attrs.hasOwnProperty(nName);
                            const v13192 = !v13191;
                            const v13193 = isNgAttr || v13192;
                            if (v13193) {
                                attrs[nName] = value;
                                const v13194 = getBooleanAttrName(node, nName);
                                if (v13194) {
                                    attrs[nName] = true;
                                }
                            }
                            const v13195 = addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                            v13195;
                            const v13196 = addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                            v13196;
                        }
                        const v13165 = j++;
                        v13164 = j < jj;
                    }
                    const v13197 = nodeName === 'input';
                    const v13198 = node.getAttribute('type');
                    const v13199 = v13198 === 'hidden';
                    const v13200 = v13197 && v13199;
                    if (v13200) {
                        const v13201 = node.setAttribute('autocomplete', 'off');
                        v13201;
                    }
                    const v13202 = !cssClassDirectivesEnabled;
                    if (v13202) {
                        break;
                    }
                    className = node.className;
                    const v13203 = isObject(className);
                    if (v13203) {
                        className = className.animVal;
                    }
                    const v13204 = isString(className);
                    const v13205 = className !== '';
                    const v13206 = v13204 && v13205;
                    if (v13206) {
                        while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                            const v13207 = match[2];
                            nName = directiveNormalize(v13207);
                            const v13208 = addDirective(directives, nName, 'C', maxPriority, ignoreDirective);
                            if (v13208) {
                                const v13209 = match[3];
                                const v13210 = trim(v13209);
                                attrs[nName] = v13210;
                            }
                            const v13211 = match.index;
                            const v13212 = match[0];
                            const v13213 = v13212.length;
                            const v13214 = v13211 + v13213;
                            className = className.substr(v13214);
                        }
                    }
                    break;
                case NODE_TYPE_TEXT:
                    const v13215 = node.nodeValue;
                    const v13216 = addTextInterpolateDirective(directives, v13215);
                    v13216;
                    break;
                case NODE_TYPE_COMMENT:
                    const v13217 = !commentDirectivesEnabled;
                    if (v13217) {
                        break;
                    }
                    const v13218 = collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                    v13218;
                    break;
                }
                const v13219 = directives.sort(byPriority);
                v13219;
                return directives;
            };
            const collectCommentDirectives = function (node, directives, attrs, maxPriority, ignoreDirective) {
                try {
                    const v13220 = node.nodeValue;
                    var match = COMMENT_DIRECTIVE_REGEXP.exec(v13220);
                    if (match) {
                        const v13221 = match[1];
                        var nName = directiveNormalize(v13221);
                        const v13222 = addDirective(directives, nName, 'M', maxPriority, ignoreDirective);
                        if (v13222) {
                            const v13223 = match[2];
                            const v13224 = trim(v13223);
                            attrs[nName] = v13224;
                        }
                    }
                } catch (e) {
                }
            };
            const groupScan = function (node, attrStart, attrEnd) {
                var nodes = [];
                var depth = 0;
                const v13225 = node.hasAttribute;
                const v13226 = attrStart && v13225;
                const v13227 = node.hasAttribute(attrStart);
                const v13228 = v13226 && v13227;
                if (v13228) {
                    let v13229 = true;
                    while (v13229) {
                        const v13230 = !node;
                        if (v13230) {
                            const v13231 = $compileMinErr('uterdir', 'Unterminated attribute, found \'{0}\' but no matching \'{1}\' found.', attrStart, attrEnd);
                            throw v13231;
                        }
                        const v13232 = node.nodeType;
                        const v13233 = v13232 === NODE_TYPE_ELEMENT;
                        if (v13233) {
                            const v13234 = node.hasAttribute(attrStart);
                            if (v13234) {
                                const v13235 = depth++;
                                v13235;
                            }
                            const v13236 = node.hasAttribute(attrEnd);
                            if (v13236) {
                                const v13237 = depth--;
                                v13237;
                            }
                        }
                        const v13238 = nodes.push(node);
                        v13238;
                        node = node.nextSibling;
                        v13229 = depth > 0;
                    }
                } else {
                    const v13239 = nodes.push(node);
                    v13239;
                }
                const v13240 = jqLite(nodes);
                return v13240;
            };
            const groupElementsLinkFnWrapper = function (linkFn, attrStart, attrEnd) {
                const v13243 = function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
                    const v13241 = element[0];
                    element = groupScan(v13241, attrStart, attrEnd);
                    const v13242 = linkFn(scope, element, attrs, controllers, transcludeFn);
                    return v13242;
                };
                return v13243;
            };
            const compilationGenerator = function (eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                var compiled;
                if (eager) {
                    const v13244 = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                    return v13244;
                }
                const v13247 = function lazyCompilation() {
                    const v13245 = !compiled;
                    if (v13245) {
                        compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                        previousCompileContext = null;
                        transcludeFn = previousCompileContext;
                        $compileNodes = transcludeFn;
                    }
                    const v13246 = compiled.apply(this, arguments);
                    return v13246;
                };
                return v13247;
            };
            const applyDirectivesToNode = function (directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                const v13248 = {};
                previousCompileContext = previousCompileContext || v13248;
                const v13249 = Number.MAX_VALUE;
                const v13250 = -v13249;
                var terminalPriority = v13250;
                var newScopeDirective = previousCompileContext.newScopeDirective;
                var controllerDirectives = previousCompileContext.controllerDirectives;
                var newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective;
                var templateDirective = previousCompileContext.templateDirective;
                var nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective;
                var hasTranscludeDirective = false;
                var hasTemplate = false;
                var hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective;
                const v13251 = jqLite(compileNode);
                templateAttrs.$$element = v13251;
                var $compileNode = templateAttrs.$$element;
                var directive;
                var directiveName;
                var $template;
                var replaceDirective = originalReplaceDirective;
                var childTranscludeFn = transcludeFn;
                var linkFn;
                var didScanForMultipleTransclusion = false;
                var mightHaveMultipleTransclusionError = false;
                var directiveValue;
                var i = 0;
                var ii = directives.length;
                let v13252 = i < ii;
                while (v13252) {
                    directive = directives[i];
                    var attrStart = directive.$$start;
                    var attrEnd = directive.$$end;
                    if (attrStart) {
                        $compileNode = groupScan(compileNode, attrStart, attrEnd);
                    }
                    $template = undefined;
                    const v13254 = directive.priority;
                    const v13255 = terminalPriority > v13254;
                    if (v13255) {
                        break;
                    }
                    directiveValue = directive.scope;
                    if (directiveValue) {
                        const v13256 = directive.templateUrl;
                        const v13257 = !v13256;
                        if (v13257) {
                            const v13258 = isObject(directiveValue);
                            if (v13258) {
                                const v13259 = newIsolateScopeDirective || newScopeDirective;
                                const v13260 = assertNoDuplicate('new/isolated scope', v13259, directive, $compileNode);
                                v13260;
                                newIsolateScopeDirective = directive;
                            } else {
                                const v13261 = assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                                v13261;
                            }
                        }
                        newScopeDirective = newScopeDirective || directive;
                    }
                    directiveName = directive.name;
                    const v13262 = !didScanForMultipleTransclusion;
                    const v13263 = directive.replace;
                    const v13264 = directive.templateUrl;
                    const v13265 = directive.template;
                    const v13266 = v13264 || v13265;
                    const v13267 = v13263 && v13266;
                    const v13268 = directive.transclude;
                    const v13269 = directive.$$tlb;
                    const v13270 = !v13269;
                    const v13271 = v13268 && v13270;
                    const v13272 = v13267 || v13271;
                    const v13273 = v13262 && v13272;
                    if (v13273) {
                        var candidateDirective;
                        var scanningIndex = i + 1;
                        const v13274 = scanningIndex++;
                        while (candidateDirective = directives[v13274]) {
                            const v13275 = candidateDirective.transclude;
                            const v13276 = candidateDirective.$$tlb;
                            const v13277 = !v13276;
                            const v13278 = v13275 && v13277;
                            const v13279 = candidateDirective.replace;
                            const v13280 = candidateDirective.templateUrl;
                            const v13281 = candidateDirective.template;
                            const v13282 = v13280 || v13281;
                            const v13283 = v13279 && v13282;
                            const v13284 = v13278 || v13283;
                            if (v13284) {
                                mightHaveMultipleTransclusionError = true;
                                break;
                            }
                        }
                        didScanForMultipleTransclusion = true;
                    }
                    const v13285 = directive.templateUrl;
                    const v13286 = !v13285;
                    const v13287 = directive.controller;
                    const v13288 = v13286 && v13287;
                    if (v13288) {
                        const v13289 = createMap();
                        controllerDirectives = controllerDirectives || v13289;
                        const v13290 = '\'' + directiveName;
                        const v13291 = v13290 + '\' controller';
                        const v13292 = controllerDirectives[directiveName];
                        const v13293 = assertNoDuplicate(v13291, v13292, directive, $compileNode);
                        v13293;
                        controllerDirectives[directiveName] = directive;
                    }
                    directiveValue = directive.transclude;
                    if (directiveValue) {
                        hasTranscludeDirective = true;
                        const v13294 = directive.$$tlb;
                        const v13295 = !v13294;
                        if (v13295) {
                            const v13296 = assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                            v13296;
                            nonTlbTranscludeDirective = directive;
                        }
                        const v13297 = directiveValue === 'element';
                        if (v13297) {
                            hasElementTranscludeDirective = true;
                            terminalPriority = directive.priority;
                            $template = $compileNode;
                            const v13298 = templateAttrs[directiveName];
                            const v13299 = compile.$$createComment(directiveName, v13298);
                            const v13300 = jqLite(v13299);
                            templateAttrs.$$element = v13300;
                            $compileNode = templateAttrs.$$element;
                            compileNode = $compileNode[0];
                            const v13301 = sliceArgs($template);
                            const v13302 = replaceWith(jqCollection, v13301, compileNode);
                            v13302;
                            const v13303 = replaceDirective.name;
                            const v13304 = replaceDirective && v13303;
                            const v13305 = { nonTlbTranscludeDirective: nonTlbTranscludeDirective };
                            childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, v13304, v13305);
                        } else {
                            var slots = createMap();
                            const v13306 = isObject(directiveValue);
                            const v13307 = !v13306;
                            if (v13307) {
                                const v13308 = jqLiteClone(compileNode);
                                const v13309 = jqLite(v13308);
                                $template = v13309.contents();
                            } else {
                                const v13310 = window.document;
                                $template = v13310.createDocumentFragment();
                                var slotMap = createMap();
                                var filledSlots = createMap();
                                const v13313 = function (elementSelector, slotName) {
                                    const v13311 = elementSelector.charAt(0);
                                    var optional = v13311 === '?';
                                    const v13312 = elementSelector.substring(1);
                                    if (optional) {
                                        elementSelector = v13312;
                                    } else {
                                        elementSelector = elementSelector;
                                    }
                                    slotMap[elementSelector] = slotName;
                                    slots[slotName] = null;
                                    filledSlots[slotName] = optional;
                                };
                                const v13314 = forEach(directiveValue, v13313);
                                v13314;
                                const v13315 = $compileNode.contents();
                                const v13324 = function (node) {
                                    const v13316 = nodeName_(node);
                                    const v13317 = directiveNormalize(v13316);
                                    var slotName = slotMap[v13317];
                                    if (slotName) {
                                        filledSlots[slotName] = true;
                                        const v13318 = slots[slotName];
                                        const v13319 = window.document;
                                        const v13320 = v13319.createDocumentFragment();
                                        slots[slotName] = v13318 || v13320;
                                        const v13321 = slots[slotName];
                                        const v13322 = v13321.appendChild(node);
                                        v13322;
                                    } else {
                                        const v13323 = $template.appendChild(node);
                                        v13323;
                                    }
                                };
                                const v13325 = forEach(v13315, v13324);
                                v13325;
                                const v13328 = function (filled, slotName) {
                                    const v13326 = !filled;
                                    if (v13326) {
                                        const v13327 = $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                                        throw v13327;
                                    }
                                };
                                const v13329 = forEach(filledSlots, v13328);
                                v13329;
                                let slotName;
                                for (slotName in slots) {
                                    const v13330 = slots[slotName];
                                    if (v13330) {
                                        const v13331 = slots[slotName];
                                        const v13332 = v13331.childNodes;
                                        var slotCompileNodes = jqLite(v13332);
                                        const v13333 = compilationGenerator(mightHaveMultipleTransclusionError, slotCompileNodes, transcludeFn);
                                        slots[slotName] = v13333;
                                    }
                                }
                                const v13334 = $template.childNodes;
                                $template = jqLite(v13334);
                            }
                            const v13335 = $compileNode.empty();
                            v13335;
                            const v13336 = directive.$$isolateScope;
                            const v13337 = directive.$$newScope;
                            const v13338 = v13336 || v13337;
                            const v13339 = { needsNewScope: v13338 };
                            childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, v13339);
                            childTranscludeFn.$$slots = slots;
                        }
                    }
                    const v13340 = directive.template;
                    if (v13340) {
                        hasTemplate = true;
                        const v13341 = assertNoDuplicate('template', templateDirective, directive, $compileNode);
                        v13341;
                        templateDirective = directive;
                        const v13342 = directive.template;
                        const v13343 = isFunction(v13342);
                        const v13344 = directive.template($compileNode, templateAttrs);
                        const v13345 = directive.template;
                        if (v13343) {
                            directiveValue = v13344;
                        } else {
                            directiveValue = v13345;
                        }
                        directiveValue = denormalizeTemplate(directiveValue);
                        const v13346 = directive.replace;
                        if (v13346) {
                            replaceDirective = directive;
                            const v13347 = jqLiteIsTextNode(directiveValue);
                            if (v13347) {
                                $template = [];
                            } else {
                                const v13348 = directive.templateNamespace;
                                const v13349 = trim(directiveValue);
                                const v13350 = wrapTemplate(v13348, v13349);
                                $template = removeComments(v13350);
                            }
                            compileNode = $template[0];
                            const v13351 = $template.length;
                            const v13352 = v13351 !== 1;
                            const v13353 = compileNode.nodeType;
                            const v13354 = v13353 !== NODE_TYPE_ELEMENT;
                            const v13355 = v13352 || v13354;
                            if (v13355) {
                                const v13356 = $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', directiveName, '');
                                throw v13356;
                            }
                            const v13357 = replaceWith(jqCollection, $compileNode, compileNode);
                            v13357;
                            const v13358 = {};
                            var newTemplateAttrs = {};
                            newTemplateAttrs.$attr = v13358;
                            const v13359 = [];
                            var templateDirectives = collectDirectives(compileNode, v13359, newTemplateAttrs);
                            const v13360 = i + 1;
                            const v13361 = directives.length;
                            const v13362 = i + 1;
                            const v13363 = v13361 - v13362;
                            var unprocessedDirectives = directives.splice(v13360, v13363);
                            const v13364 = newIsolateScopeDirective || newScopeDirective;
                            if (v13364) {
                                const v13365 = markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                                v13365;
                            }
                            const v13366 = directives.concat(templateDirectives);
                            directives = v13366.concat(unprocessedDirectives);
                            const v13367 = mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                            v13367;
                            ii = directives.length;
                        } else {
                            const v13368 = $compileNode.html(directiveValue);
                            v13368;
                        }
                    }
                    const v13369 = directive.templateUrl;
                    if (v13369) {
                        hasTemplate = true;
                        const v13370 = assertNoDuplicate('template', templateDirective, directive, $compileNode);
                        v13370;
                        templateDirective = directive;
                        const v13371 = directive.replace;
                        if (v13371) {
                            replaceDirective = directive;
                        }
                        const v13372 = directives.length;
                        const v13373 = v13372 - i;
                        const v13374 = directives.splice(i, v13373);
                        const v13375 = hasTranscludeDirective && childTranscludeFn;
                        const v13376 = newScopeDirective !== directive;
                        const v13377 = v13376 && newScopeDirective;
                        const v13378 = {
                            controllerDirectives: controllerDirectives,
                            newScopeDirective: v13377,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        };
                        nodeLinkFn = compileTemplateUrl(v13374, $compileNode, templateAttrs, jqCollection, v13375, preLinkFns, postLinkFns, v13378);
                        ii = directives.length;
                    } else {
                        const v13379 = directive.compile;
                        if (v13379) {
                            try {
                                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                                const v13380 = directive.$$originalDirective;
                                var context = v13380 || directive;
                                const v13381 = isFunction(linkFn);
                                if (v13381) {
                                    const v13382 = bind(context, linkFn);
                                    const v13383 = addLinkFns(null, v13382, attrStart, attrEnd);
                                    v13383;
                                } else {
                                    if (linkFn) {
                                        const v13384 = linkFn.pre;
                                        const v13385 = bind(context, v13384);
                                        const v13386 = linkFn.post;
                                        const v13387 = bind(context, v13386);
                                        const v13388 = addLinkFns(v13385, v13387, attrStart, attrEnd);
                                        v13388;
                                    }
                                }
                            } catch (e) {
                                const v13389 = startingTag($compileNode);
                                const v13390 = $exceptionHandler(e, v13389);
                                v13390;
                            }
                        }
                    }
                    const v13391 = directive.terminal;
                    if (v13391) {
                        nodeLinkFn.terminal = true;
                        const v13392 = directive.priority;
                        terminalPriority = Math.max(terminalPriority, v13392);
                    }
                    const v13253 = i++;
                    v13252 = i < ii;
                }
                const v13393 = newScopeDirective.scope;
                const v13394 = v13393 === true;
                nodeLinkFn.scope = newScopeDirective && v13394;
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                nodeLinkFn.templateOnThisElement = hasTemplate;
                nodeLinkFn.transclude = childTranscludeFn;
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                return nodeLinkFn;
                const addLinkFns = function (pre, post, attrStart, attrEnd) {
                    if (pre) {
                        if (attrStart) {
                            pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                        }
                        const v13395 = directive.require;
                        pre.require = v13395;
                        pre.directiveName = directiveName;
                        const v13396 = newIsolateScopeDirective === directive;
                        const v13397 = directive.$$isolateScope;
                        const v13398 = v13396 || v13397;
                        if (v13398) {
                            const v13399 = { isolateScope: true };
                            pre = cloneAndAnnotateFn(pre, v13399);
                        }
                        const v13400 = preLinkFns.push(pre);
                        v13400;
                    }
                    if (post) {
                        if (attrStart) {
                            post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                        }
                        const v13401 = directive.require;
                        post.require = v13401;
                        post.directiveName = directiveName;
                        const v13402 = newIsolateScopeDirective === directive;
                        const v13403 = directive.$$isolateScope;
                        const v13404 = v13402 || v13403;
                        if (v13404) {
                            const v13405 = { isolateScope: true };
                            post = cloneAndAnnotateFn(post, v13405);
                        }
                        const v13406 = postLinkFns.push(post);
                        v13406;
                    }
                };
                const nodeLinkFn = function (childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    var i;
                    var ii;
                    var linkFn;
                    var isolateScope;
                    var controllerScope;
                    var elementControllers;
                    var transcludeFn;
                    var $element;
                    var attrs;
                    var scopeBindingInfo;
                    const v13407 = compileNode === linkNode;
                    if (v13407) {
                        attrs = templateAttrs;
                        $element = templateAttrs.$$element;
                    } else {
                        $element = jqLite(linkNode);
                        attrs = new Attributes($element, templateAttrs);
                    }
                    controllerScope = scope;
                    if (newIsolateScopeDirective) {
                        isolateScope = scope.$new(true);
                    } else {
                        if (newScopeDirective) {
                            controllerScope = scope.$parent;
                        }
                    }
                    if (boundTranscludeFn) {
                        transcludeFn = controllersBoundTransclude;
                        transcludeFn.$$boundTransclude = boundTranscludeFn;
                        const v13412 = function (slotName) {
                            const v13408 = boundTranscludeFn.$$slots;
                            const v13409 = v13408[slotName];
                            const v13410 = !v13409;
                            const v13411 = !v13410;
                            return v13411;
                        };
                        transcludeFn.isSlotFilled = v13412;
                    }
                    if (controllerDirectives) {
                        elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
                    }
                    if (newIsolateScopeDirective) {
                        const v13413 = templateDirective === newIsolateScopeDirective;
                        const v13414 = newIsolateScopeDirective.$$originalDirective;
                        const v13415 = templateDirective === v13414;
                        const v13416 = v13413 || v13415;
                        const v13417 = templateDirective && v13416;
                        const v13418 = !v13417;
                        const v13419 = compile.$$addScopeInfo($element, isolateScope, true, v13418);
                        v13419;
                        const v13420 = compile.$$addScopeClass($element, true);
                        v13420;
                        const v13421 = newIsolateScopeDirective.$$isolateBindings;
                        isolateScope.$$isolateBindings = v13421;
                        const v13422 = isolateScope.$$isolateBindings;
                        scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, v13422, newIsolateScopeDirective);
                        const v13423 = scopeBindingInfo.removeWatches;
                        if (v13423) {
                            const v13424 = scopeBindingInfo.removeWatches;
                            const v13425 = isolateScope.$on('$destroy', v13424);
                            v13425;
                        }
                    }
                    let name;
                    for (name in elementControllers) {
                        var controllerDirective = controllerDirectives[name];
                        var controller = elementControllers[name];
                        const v13426 = controllerDirective.$$bindings;
                        var bindings = v13426.bindToController;
                        const v13427 = controller();
                        controller.instance = v13427;
                        const v13428 = controllerDirective.name;
                        const v13429 = '$' + v13428;
                        const v13430 = v13429 + 'Controller';
                        const v13431 = controller.instance;
                        const v13432 = $element.data(v13430, v13431);
                        v13432;
                        const v13433 = controller.instance;
                        const v13434 = initializeDirectiveBindings(controllerScope, attrs, v13433, bindings, controllerDirective);
                        controller.bindingInfo = v13434;
                    }
                    const v13445 = function (controllerDirective, name) {
                        var require = controllerDirective.require;
                        const v13435 = controllerDirective.bindToController;
                        const v13436 = isArray(require);
                        const v13437 = !v13436;
                        const v13438 = v13435 && v13437;
                        const v13439 = isObject(require);
                        const v13440 = v13438 && v13439;
                        if (v13440) {
                            const v13441 = elementControllers[name];
                            const v13442 = v13441.instance;
                            const v13443 = getControllers(name, require, $element, elementControllers);
                            const v13444 = extend(v13442, v13443);
                            v13444;
                        }
                    };
                    const v13446 = forEach(controllerDirectives, v13445);
                    v13446;
                    const v13468 = function (controller) {
                        var controllerInstance = controller.instance;
                        const v13447 = controllerInstance.$onChanges;
                        const v13448 = isFunction(v13447);
                        if (v13448) {
                            try {
                                const v13449 = controller.bindingInfo;
                                const v13450 = v13449.initialChanges;
                                const v13451 = controllerInstance.$onChanges(v13450);
                                v13451;
                            } catch (e) {
                                const v13452 = $exceptionHandler(e);
                                v13452;
                            }
                        }
                        const v13453 = controllerInstance.$onInit;
                        const v13454 = isFunction(v13453);
                        if (v13454) {
                            try {
                                const v13455 = controllerInstance.$onInit();
                                v13455;
                            } catch (e) {
                                const v13456 = $exceptionHandler(e);
                                v13456;
                            }
                        }
                        const v13457 = controllerInstance.$doCheck;
                        const v13458 = isFunction(v13457);
                        if (v13458) {
                            const v13460 = function () {
                                const v13459 = controllerInstance.$doCheck();
                                v13459;
                            };
                            const v13461 = controllerScope.$watch(v13460);
                            v13461;
                            const v13462 = controllerInstance.$doCheck();
                            v13462;
                        }
                        const v13463 = controllerInstance.$onDestroy;
                        const v13464 = isFunction(v13463);
                        if (v13464) {
                            const v13466 = function callOnDestroyHook() {
                                const v13465 = controllerInstance.$onDestroy();
                                v13465;
                            };
                            const v13467 = controllerScope.$on('$destroy', v13466);
                            v13467;
                        }
                    };
                    const v13469 = forEach(elementControllers, v13468);
                    v13469;
                    (i = 0, ii = preLinkFns.length)
                    let v13470 = i < ii;
                    while (v13470) {
                        linkFn = preLinkFns[i];
                        const v13472 = linkFn.isolateScope;
                        let v13473;
                        if (v13472) {
                            v13473 = isolateScope;
                        } else {
                            v13473 = scope;
                        }
                        const v13474 = linkFn.require;
                        const v13475 = linkFn.directiveName;
                        const v13476 = linkFn.require;
                        const v13477 = getControllers(v13475, v13476, $element, elementControllers);
                        const v13478 = v13474 && v13477;
                        const v13479 = invokeLinkFn(linkFn, v13473, $element, attrs, v13478, transcludeFn);
                        v13479;
                        const v13471 = i++;
                        v13470 = i < ii;
                    }
                    var scopeToChild = scope;
                    const v13480 = newIsolateScopeDirective.template;
                    const v13481 = newIsolateScopeDirective.templateUrl;
                    const v13482 = v13481 === null;
                    const v13483 = v13480 || v13482;
                    const v13484 = newIsolateScopeDirective && v13483;
                    if (v13484) {
                        scopeToChild = isolateScope;
                    }
                    if (childLinkFn) {
                        const v13485 = linkNode.childNodes;
                        const v13486 = childLinkFn(scopeToChild, v13485, undefined, boundTranscludeFn);
                        v13486;
                    }
                    const v13487 = postLinkFns.length;
                    let v13488 = i >= 0;
                    while (v13488) {
                        linkFn = postLinkFns[i];
                        const v13490 = linkFn.isolateScope;
                        let v13491;
                        if (v13490) {
                            v13491 = isolateScope;
                        } else {
                            v13491 = scope;
                        }
                        const v13492 = linkFn.require;
                        const v13493 = linkFn.directiveName;
                        const v13494 = linkFn.require;
                        const v13495 = getControllers(v13493, v13494, $element, elementControllers);
                        const v13496 = v13492 && v13495;
                        const v13497 = invokeLinkFn(linkFn, v13491, $element, attrs, v13496, transcludeFn);
                        v13497;
                        const v13489 = i--;
                        v13488 = i >= 0;
                    }
                    const v13501 = function (controller) {
                        var controllerInstance = controller.instance;
                        const v13498 = controllerInstance.$postLink;
                        const v13499 = isFunction(v13498);
                        if (v13499) {
                            const v13500 = controllerInstance.$postLink();
                            v13500;
                        }
                    };
                    const v13502 = forEach(elementControllers, v13501);
                    v13502;
                    const controllersBoundTransclude = function (scope, cloneAttachFn, futureParentElement, slotName) {
                        var transcludeControllers;
                        const v13503 = isScope(scope);
                        const v13504 = !v13503;
                        if (v13504) {
                            slotName = futureParentElement;
                            futureParentElement = cloneAttachFn;
                            cloneAttachFn = scope;
                            scope = undefined;
                        }
                        if (hasElementTranscludeDirective) {
                            transcludeControllers = elementControllers;
                        }
                        const v13505 = !futureParentElement;
                        if (v13505) {
                            const v13506 = $element.parent();
                            if (hasElementTranscludeDirective) {
                                futureParentElement = v13506;
                            } else {
                                futureParentElement = $element;
                            }
                        }
                        if (slotName) {
                            const v13507 = boundTranscludeFn.$$slots;
                            var slotTranscludeFn = v13507[slotName];
                            if (slotTranscludeFn) {
                                const v13508 = slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                return v13508;
                            } else {
                                const v13509 = isUndefined(slotTranscludeFn);
                                if (v13509) {
                                    const v13510 = 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}';
                                    const v13511 = startingTag($element);
                                    const v13512 = $compileMinErr('noslot', v13510, slotName, v13511);
                                    throw v13512;
                                }
                            }
                        } else {
                            const v13513 = boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                            return v13513;
                        }
                    };
                };
            };
            const getControllers = function (directiveName, require, $element, elementControllers) {
                var value;
                const v13514 = isString(require);
                if (v13514) {
                    var match = require.match(REQUIRE_PREFIX_REGEXP);
                    const v13515 = match[0];
                    const v13516 = v13515.length;
                    var name = require.substring(v13516);
                    const v13517 = match[1];
                    const v13518 = match[3];
                    var inheritType = v13517 || v13518;
                    const v13519 = match[2];
                    var optional = v13519 === '?';
                    const v13520 = inheritType === '^^';
                    if (v13520) {
                        $element = $element.parent();
                    } else {
                        const v13521 = elementControllers[name];
                        value = elementControllers && v13521;
                        const v13522 = value.instance;
                        value = value && v13522;
                    }
                    const v13523 = !value;
                    if (v13523) {
                        const v13524 = '$' + name;
                        var dataName = v13524 + 'Controller';
                        const v13525 = inheritType === '^^';
                        const v13526 = $element[0];
                        const v13527 = v13525 && v13526;
                        const v13528 = $element[0];
                        const v13529 = v13528.nodeType;
                        const v13530 = v13529 === NODE_TYPE_DOCUMENT;
                        const v13531 = v13527 && v13530;
                        if (v13531) {
                            value = null;
                        } else {
                            const v13532 = $element.inheritedData(dataName);
                            const v13533 = $element.data(dataName);
                            if (inheritType) {
                                value = v13532;
                            } else {
                                value = v13533;
                            }
                        }
                    }
                    const v13534 = !value;
                    const v13535 = !optional;
                    const v13536 = v13534 && v13535;
                    if (v13536) {
                        const v13537 = $compileMinErr('ctreq', 'Controller \'{0}\', required by directive \'{1}\', can\'t be found!', name, directiveName);
                        throw v13537;
                    }
                } else {
                    const v13538 = isArray(require);
                    if (v13538) {
                        value = [];
                        var i = 0;
                        var ii = require.length;
                        let v13539 = i < ii;
                        while (v13539) {
                            const v13541 = require[i];
                            const v13542 = getControllers(directiveName, v13541, $element, elementControllers);
                            value[i] = v13542;
                            const v13540 = i++;
                            v13539 = i < ii;
                        }
                    } else {
                        const v13543 = isObject(require);
                        if (v13543) {
                            value = {};
                            const v13545 = function (controller, property) {
                                const v13544 = getControllers(directiveName, controller, $element, elementControllers);
                                value[property] = v13544;
                            };
                            const v13546 = forEach(require, v13545);
                            v13546;
                        }
                    }
                }
                const v13547 = value || null;
                return v13547;
            };
            const setupControllers = function ($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                var elementControllers = createMap();
                let controllerKey;
                for (controllerKey in controllerDirectives) {
                    var directive = controllerDirectives[controllerKey];
                    const v13548 = directive === newIsolateScopeDirective;
                    const v13549 = directive.$$isolateScope;
                    const v13550 = v13548 || v13549;
                    let v13551;
                    if (v13550) {
                        v13551 = isolateScope;
                    } else {
                        v13551 = scope;
                    }
                    var locals = {};
                    locals.$scope = v13551;
                    locals.$element = $element;
                    locals.$attrs = attrs;
                    locals.$transclude = transcludeFn;
                    var controller = directive.controller;
                    const v13552 = controller === '@';
                    if (v13552) {
                        const v13553 = directive.name;
                        controller = attrs[v13553];
                    }
                    const v13554 = directive.controllerAs;
                    var controllerInstance = $controller(controller, locals, true, v13554);
                    const v13555 = directive.name;
                    elementControllers[v13555] = controllerInstance;
                    const v13556 = directive.name;
                    const v13557 = '$' + v13556;
                    const v13558 = v13557 + 'Controller';
                    const v13559 = controllerInstance.instance;
                    const v13560 = $element.data(v13558, v13559);
                    v13560;
                }
                return elementControllers;
            };
            const markDirectiveScope = function (directives, isolateScope, newScope) {
                var j = 0;
                var jj = directives.length;
                let v13561 = j < jj;
                while (v13561) {
                    const v13563 = directives[j];
                    const v13564 = {
                        $$isolateScope: isolateScope,
                        $$newScope: newScope
                    };
                    const v13565 = inherit(v13563, v13564);
                    directives[j] = v13565;
                    const v13562 = j++;
                    v13561 = j < jj;
                }
            };
            const addDirective = function (tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                const v13566 = name === ignoreDirective;
                if (v13566) {
                    return null;
                }
                var match = null;
                const v13567 = hasDirectives.hasOwnProperty(name);
                if (v13567) {
                    var directive;
                    const v13568 = name + Suffix;
                    var directives = $injector.get(v13568);
                    var i = 0;
                    var ii = directives.length;
                    let v13569 = i < ii;
                    while (v13569) {
                        directive = directives[i];
                        const v13571 = isUndefined(maxPriority);
                        const v13572 = directive.priority;
                        const v13573 = maxPriority > v13572;
                        const v13574 = v13571 || v13573;
                        const v13575 = directive.restrict;
                        const v13576 = v13575.indexOf(location);
                        const v13577 = -1;
                        const v13578 = v13576 !== v13577;
                        const v13579 = v13574 && v13578;
                        if (v13579) {
                            if (startAttrName) {
                                const v13580 = {
                                    $$start: startAttrName,
                                    $$end: endAttrName
                                };
                                directive = inherit(directive, v13580);
                            }
                            const v13581 = directive.$$bindings;
                            const v13582 = !v13581;
                            if (v13582) {
                                const v13583 = directive.name;
                                const v13584 = parseDirectiveBindings(directive, v13583);
                                directive.$$bindings = v13584;
                                var bindings = directive.$$bindings;
                                const v13585 = bindings.isolateScope;
                                const v13586 = isObject(v13585);
                                if (v13586) {
                                    const v13587 = bindings.isolateScope;
                                    directive.$$isolateBindings = v13587;
                                }
                            }
                            const v13588 = tDirectives.push(directive);
                            v13588;
                            match = directive;
                        }
                        const v13570 = i++;
                        v13569 = i < ii;
                    }
                }
                return match;
            };
            const directiveIsMultiElement = function (name) {
                const v13589 = hasDirectives.hasOwnProperty(name);
                if (v13589) {
                    var directive;
                    const v13590 = name + Suffix;
                    var directives = $injector.get(v13590);
                    var i = 0;
                    var ii = directives.length;
                    let v13591 = i < ii;
                    while (v13591) {
                        directive = directives[i];
                        const v13593 = directive.multiElement;
                        if (v13593) {
                            return true;
                        }
                        const v13592 = i++;
                        v13591 = i < ii;
                    }
                }
                return false;
            };
            const mergeTemplateAttributes = function (dst, src) {
                var srcAttr = src.$attr;
                var dstAttr = dst.$attr;
                const v13606 = function (value, key) {
                    const v13594 = key.charAt(0);
                    const v13595 = v13594 !== '$';
                    if (v13595) {
                        const v13596 = src[key];
                        const v13597 = src[key];
                        const v13598 = v13597 !== value;
                        const v13599 = v13596 && v13598;
                        if (v13599) {
                            const v13600 = value.length;
                            if (v13600) {
                                const v13601 = key === 'style';
                                let v13602;
                                if (v13601) {
                                    v13602 = ';';
                                } else {
                                    v13602 = ' ';
                                }
                                const v13603 = src[key];
                                value += v13602 + v13603;
                            } else {
                                value = src[key];
                            }
                        }
                        const v13604 = srcAttr[key];
                        const v13605 = dst.$set(key, value, true, v13604);
                        v13605;
                    }
                };
                const v13607 = forEach(dst, v13606);
                v13607;
                const v13617 = function (value, key) {
                    const v13608 = dst.hasOwnProperty(key);
                    const v13609 = !v13608;
                    const v13610 = key.charAt(0);
                    const v13611 = v13610 !== '$';
                    const v13612 = v13609 && v13611;
                    if (v13612) {
                        dst[key] = value;
                        const v13613 = key !== 'class';
                        const v13614 = key !== 'style';
                        const v13615 = v13613 && v13614;
                        if (v13615) {
                            const v13616 = srcAttr[key];
                            dstAttr[key] = v13616;
                        }
                    }
                };
                const v13618 = forEach(src, v13617);
                v13618;
            };
            const compileTemplateUrl = function (directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var linkQueue = [];
                var afterTemplateNodeLinkFn;
                var afterTemplateChildLinkFn;
                var beforeTemplateCompileNode = $compileNode[0];
                var origAsyncDirective = directives.shift();
                const v13619 = {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                };
                var derivedSyncDirective = inherit(origAsyncDirective, v13619);
                let templateUrl;
                const v13620 = origAsyncDirective.templateUrl;
                const v13621 = isFunction(v13620);
                const v13622 = origAsyncDirective.templateUrl($compileNode, tAttrs);
                const v13623 = origAsyncDirective.templateUrl;
                if (v13621) {
                    templateUrl = v13622;
                } else {
                    templateUrl = v13623;
                }
                var templateNamespace = origAsyncDirective.templateNamespace;
                const v13624 = $compileNode.empty();
                v13624;
                const v13625 = $templateRequest(templateUrl);
                const v13666 = function (content) {
                    var compileNode;
                    var tempTemplateAttrs;
                    var $template;
                    var childBoundTranscludeFn;
                    content = denormalizeTemplate(content);
                    const v13626 = origAsyncDirective.replace;
                    if (v13626) {
                        const v13627 = jqLiteIsTextNode(content);
                        if (v13627) {
                            $template = [];
                        } else {
                            const v13628 = trim(content);
                            const v13629 = wrapTemplate(templateNamespace, v13628);
                            $template = removeComments(v13629);
                        }
                        compileNode = $template[0];
                        const v13630 = $template.length;
                        const v13631 = v13630 !== 1;
                        const v13632 = compileNode.nodeType;
                        const v13633 = v13632 !== NODE_TYPE_ELEMENT;
                        const v13634 = v13631 || v13633;
                        if (v13634) {
                            const v13635 = origAsyncDirective.name;
                            const v13636 = $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', v13635, templateUrl);
                            throw v13636;
                        }
                        const v13637 = {};
                        tempTemplateAttrs.$attr = v13637;
                        tempTemplateAttrs = {};
                        tempTemplateAttrs = {};
                        const v13638 = replaceWith($rootElement, $compileNode, compileNode);
                        v13638;
                        const v13639 = [];
                        var templateDirectives = collectDirectives(compileNode, v13639, tempTemplateAttrs);
                        const v13640 = origAsyncDirective.scope;
                        const v13641 = isObject(v13640);
                        if (v13641) {
                            const v13642 = markDirectiveScope(templateDirectives, true);
                            v13642;
                        }
                        directives = templateDirectives.concat(directives);
                        const v13643 = mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                        v13643;
                    } else {
                        compileNode = beforeTemplateCompileNode;
                        const v13644 = $compileNode.html(content);
                        v13644;
                    }
                    const v13645 = directives.unshift(derivedSyncDirective);
                    v13645;
                    afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                    const v13648 = function (node, i) {
                        const v13646 = node === compileNode;
                        if (v13646) {
                            const v13647 = $compileNode[0];
                            $rootElement[i] = v13647;
                        }
                    };
                    const v13649 = forEach($rootElement, v13648);
                    v13649;
                    const v13650 = $compileNode[0];
                    const v13651 = v13650.childNodes;
                    afterTemplateChildLinkFn = compileNodes(v13651, childTranscludeFn);
                    let v13652 = linkQueue.length;
                    while (v13652) {
                        var scope = linkQueue.shift();
                        var beforeTemplateLinkNode = linkQueue.shift();
                        var linkRootElement = linkQueue.shift();
                        var boundTranscludeFn = linkQueue.shift();
                        var linkNode = $compileNode[0];
                        const v13653 = scope.$$destroyed;
                        if (v13653) {
                            continue;
                        }
                        const v13654 = beforeTemplateLinkNode !== beforeTemplateCompileNode;
                        if (v13654) {
                            var oldClasses = beforeTemplateLinkNode.className;
                            const v13655 = previousCompileContext.hasElementTranscludeDirective;
                            const v13656 = origAsyncDirective.replace;
                            const v13657 = v13655 && v13656;
                            const v13658 = !v13657;
                            if (v13658) {
                                linkNode = jqLiteClone(compileNode);
                            }
                            const v13659 = jqLite(beforeTemplateLinkNode);
                            const v13660 = replaceWith(linkRootElement, v13659, linkNode);
                            v13660;
                            const v13661 = jqLite(linkNode);
                            const v13662 = safeAddClass(v13661, oldClasses);
                            v13662;
                        }
                        const v13663 = afterTemplateNodeLinkFn.transcludeOnThisElement;
                        if (v13663) {
                            const v13664 = afterTemplateNodeLinkFn.transclude;
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, v13664, boundTranscludeFn);
                        } else {
                            childBoundTranscludeFn = boundTranscludeFn;
                        }
                        const v13665 = afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                        v13665;
                        v13652 = linkQueue.length;
                    }
                    linkQueue = null;
                };
                const v13667 = v13625.then(v13666);
                const v13670 = function (error) {
                    const v13668 = isError(error);
                    if (v13668) {
                        const v13669 = $exceptionHandler(error);
                        v13669;
                    }
                };
                const v13671 = v13667.catch(v13670);
                v13671;
                const v13677 = function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    const v13672 = scope.$$destroyed;
                    if (v13672) {
                        return;
                    }
                    if (linkQueue) {
                        const v13673 = linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                        v13673;
                    } else {
                        const v13674 = afterTemplateNodeLinkFn.transcludeOnThisElement;
                        if (v13674) {
                            const v13675 = afterTemplateNodeLinkFn.transclude;
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, v13675, boundTranscludeFn);
                        }
                        const v13676 = afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                        v13676;
                    }
                };
                return v13677;
            };
            const byPriority = function (a, b) {
                const v13678 = b.priority;
                const v13679 = a.priority;
                var diff = v13678 - v13679;
                const v13680 = diff !== 0;
                if (v13680) {
                    return diff;
                }
                const v13681 = a.name;
                const v13682 = b.name;
                const v13683 = v13681 !== v13682;
                if (v13683) {
                    const v13684 = a.name;
                    const v13685 = b.name;
                    const v13686 = v13684 < v13685;
                    const v13687 = -1;
                    let v13688;
                    if (v13686) {
                        v13688 = v13687;
                    } else {
                        v13688 = 1;
                    }
                    return v13688;
                }
                const v13689 = a.index;
                const v13690 = b.index;
                const v13691 = v13689 - v13690;
                return v13691;
            };
            const assertNoDuplicate = function (what, previousDirective, directive, element) {
                const wrapModuleNameIfDefined = function (moduleName) {
                    const v13692 = ' (module: ' + moduleName;
                    const v13693 = v13692 + ')';
                    let v13694;
                    if (moduleName) {
                        v13694 = v13693;
                    } else {
                        v13694 = '';
                    }
                    return v13694;
                };
                if (previousDirective) {
                    const v13695 = previousDirective.name;
                    const v13696 = previousDirective.$$moduleName;
                    const v13697 = wrapModuleNameIfDefined(v13696);
                    const v13698 = directive.name;
                    const v13699 = directive.$$moduleName;
                    const v13700 = wrapModuleNameIfDefined(v13699);
                    const v13701 = startingTag(element);
                    const v13702 = $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', v13695, v13697, v13698, v13700, what, v13701);
                    throw v13702;
                }
            };
            const addTextInterpolateDirective = function (directives, text) {
                var interpolateFn = $interpolate(text, true);
                if (interpolateFn) {
                    const v13715 = function textInterpolateCompileFn(templateNode) {
                        var templateNodeParent = templateNode.parent();
                        const v13703 = templateNodeParent.length;
                        const v13704 = !v13703;
                        const v13705 = !v13704;
                        var hasCompileParent = v13705;
                        if (hasCompileParent) {
                            const v13706 = compile.$$addBindingClass(templateNodeParent);
                            v13706;
                        }
                        const v13714 = function textInterpolateLinkFn(scope, node) {
                            var parent = node.parent();
                            const v13707 = !hasCompileParent;
                            if (v13707) {
                                const v13708 = compile.$$addBindingClass(parent);
                                v13708;
                            }
                            const v13709 = interpolateFn.expressions;
                            const v13710 = compile.$$addBindingInfo(parent, v13709);
                            v13710;
                            const v13712 = function interpolateFnWatchAction(value) {
                                const v13711 = node[0];
                                v13711.nodeValue = value;
                            };
                            const v13713 = scope.$watch(interpolateFn, v13712);
                            v13713;
                        };
                        return v13714;
                    };
                    const v13716 = {
                        priority: 0,
                        compile: v13715
                    };
                    const v13717 = directives.push(v13716);
                    v13717;
                }
            };
            const wrapTemplate = function (type, template) {
                const v13718 = type || 'html';
                type = lowercase(v13718);
                switch (type) {
                case 'svg':
                case 'math':
                    const v13719 = window.document;
                    var wrapper = v13719.createElement('div');
                    const v13720 = '<' + type;
                    const v13721 = v13720 + '>';
                    const v13722 = v13721 + template;
                    const v13723 = v13722 + '</';
                    const v13724 = v13723 + type;
                    wrapper.innerHTML = v13724 + '>';
                    const v13725 = wrapper.childNodes;
                    const v13726 = v13725[0];
                    const v13727 = v13726.childNodes;
                    return v13727;
                default:
                    return template;
                }
            };
            const getTrustedAttrContext = function (nodeName, attrNormalizedName) {
                const v13728 = attrNormalizedName === 'srcdoc';
                if (v13728) {
                    const v13729 = $sce.HTML;
                    return v13729;
                }
                const v13730 = attrNormalizedName === 'src';
                const v13731 = attrNormalizedName === 'ngSrc';
                const v13732 = v13730 || v13731;
                if (v13732) {
                    const v13733 = [
                        'img',
                        'video',
                        'audio',
                        'source',
                        'track'
                    ];
                    const v13734 = v13733.indexOf(nodeName);
                    const v13735 = -1;
                    const v13736 = v13734 === v13735;
                    if (v13736) {
                        const v13737 = $sce.RESOURCE_URL;
                        return v13737;
                    }
                    const v13738 = $sce.MEDIA_URL;
                    return v13738;
                } else {
                    const v13739 = attrNormalizedName === 'xlinkHref';
                    if (v13739) {
                        const v13740 = nodeName === 'image';
                        if (v13740) {
                            const v13741 = $sce.MEDIA_URL;
                            return v13741;
                        }
                        const v13742 = nodeName === 'a';
                        if (v13742) {
                            const v13743 = $sce.URL;
                            return v13743;
                        }
                        const v13744 = $sce.RESOURCE_URL;
                        return v13744;
                    } else {
                        const v13745 = nodeName === 'form';
                        const v13746 = attrNormalizedName === 'action';
                        const v13747 = v13745 && v13746;
                        const v13748 = nodeName === 'base';
                        const v13749 = attrNormalizedName === 'href';
                        const v13750 = v13748 && v13749;
                        const v13751 = v13747 || v13750;
                        const v13752 = nodeName === 'link';
                        const v13753 = attrNormalizedName === 'href';
                        const v13754 = v13752 && v13753;
                        const v13755 = v13751 || v13754;
                        if (v13755) {
                            const v13756 = $sce.RESOURCE_URL;
                            return v13756;
                        } else {
                            const v13757 = nodeName === 'a';
                            const v13758 = attrNormalizedName === 'href';
                            const v13759 = attrNormalizedName === 'ngHref';
                            const v13760 = v13758 || v13759;
                            const v13761 = v13757 && v13760;
                            if (v13761) {
                                const v13762 = $sce.URL;
                                return v13762;
                            }
                        }
                    }
                }
            };
            const getTrustedPropContext = function (nodeName, propNormalizedName) {
                var prop = propNormalizedName.toLowerCase();
                const v13763 = nodeName + '|';
                const v13764 = v13763 + prop;
                const v13765 = PROP_CONTEXTS[v13764];
                const v13766 = '*|' + prop;
                const v13767 = PROP_CONTEXTS[v13766];
                const v13768 = v13765 || v13767;
                return v13768;
            };
            const sanitizeSrcsetPropertyValue = function (value) {
                const v13769 = $sce.valueOf(value);
                const v13770 = sanitizeSrcset(v13769, 'ng-prop-srcset');
                return v13770;
            };
            const addPropertyDirective = function (node, directives, attrName, propName) {
                const v13771 = EVENT_HANDLER_ATTR_REGEXP.test(propName);
                if (v13771) {
                    const v13772 = $compileMinErr('nodomevents', 'Property bindings for HTML DOM event properties are disallowed');
                    throw v13772;
                }
                var nodeName = nodeName_(node);
                var trustedContext = getTrustedPropContext(nodeName, propName);
                var sanitizer = identity;
                const v13773 = propName === 'srcset';
                const v13774 = nodeName === 'img';
                const v13775 = nodeName === 'source';
                const v13776 = v13774 || v13775;
                const v13777 = v13773 && v13776;
                if (v13777) {
                    sanitizer = sanitizeSrcsetPropertyValue;
                } else {
                    if (trustedContext) {
                        const v13778 = $sce.getTrusted;
                        sanitizer = v13778.bind($sce, trustedContext);
                    }
                }
                const v13789 = function ngPropCompileFn(_, attr) {
                    const v13779 = attr[attrName];
                    var ngPropGetter = $parse(v13779);
                    const v13780 = attr[attrName];
                    const v13782 = function sceValueOf(val) {
                        const v13781 = $sce.valueOf(val);
                        return v13781;
                    };
                    var ngPropWatch = $parse(v13780, v13782);
                    const v13787 = function ngPropPreLinkFn(scope, $element) {
                        const applyPropValue = function () {
                            var propValue = ngPropGetter(scope);
                            const v13784 = sanitizer(propValue);
                            v13783[propName] = v13784;
                        };
                        const v13785 = applyPropValue();
                        v13785;
                        const v13786 = scope.$watch(ngPropWatch, applyPropValue);
                        v13786;
                    };
                    const v13788 = {};
                    v13788.pre = v13787;
                    return v13788;
                };
                const v13790 = {
                    priority: 100,
                    compile: v13789
                };
                const v13791 = directives.push(v13790);
                v13791;
            };
            const addEventDirective = function (directives, attrName, eventName) {
                const v13792 = createEventDirective($parse, $rootScope, $exceptionHandler, attrName, eventName, false);
                const v13793 = directives.push(v13792);
                v13793;
            };
            const addAttrInterpolateDirective = function (node, directives, value, name, isNgAttr) {
                var nodeName = nodeName_(node);
                var trustedContext = getTrustedAttrContext(nodeName, name);
                const v13794 = !isNgAttr;
                var mustHaveExpression = v13794;
                const v13795 = ALL_OR_NOTHING_ATTRS[name];
                var allOrNothing = v13795 || isNgAttr;
                var interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                const v13796 = !interpolateFn;
                if (v13796) {
                    return;
                }
                const v13797 = name === 'multiple';
                const v13798 = nodeName === 'select';
                const v13799 = v13797 && v13798;
                if (v13799) {
                    const v13800 = startingTag(node);
                    const v13801 = $compileMinErr('selmulti', 'Binding to the \'multiple\' attribute is not supported. Element: {0}', v13800);
                    throw v13801;
                }
                const v13802 = EVENT_HANDLER_ATTR_REGEXP.test(name);
                if (v13802) {
                    const v13803 = $compileMinErr('nodomevents', 'Interpolations for HTML DOM event attributes are disallowed');
                    throw v13803;
                }
                const v13827 = function () {
                    const v13825 = function attrInterpolatePreLinkFn(scope, element, attr) {
                        const v13804 = attr.$$observers;
                        const v13805 = createMap();
                        var $$observers = v13804 || (attr.$$observers = v13805);
                        var newValue = attr[name];
                        const v13806 = newValue !== value;
                        if (v13806) {
                            const v13807 = $interpolate(newValue, true, trustedContext, allOrNothing);
                            interpolateFn = newValue && v13807;
                            value = newValue;
                        }
                        const v13808 = !interpolateFn;
                        if (v13808) {
                            return;
                        }
                        const v13809 = interpolateFn(scope);
                        attr[name] = v13809;
                        const v13810 = $$observers[name];
                        const v13811 = v13810 || ($$observers[name] = []);
                        v13811.$$inter = true;
                        const v13812 = attr.$$observers;
                        const v13813 = attr.$$observers;
                        const v13814 = v13813[name];
                        const v13815 = v13814.$$scope;
                        const v13816 = v13812 && v13815;
                        const v13817 = v13816 || scope;
                        const v13823 = function interpolateFnWatchAction(newValue, oldValue) {
                            const v13818 = name === 'class';
                            const v13819 = newValue !== oldValue;
                            const v13820 = v13818 && v13819;
                            if (v13820) {
                                const v13821 = attr.$updateClass(newValue, oldValue);
                                v13821;
                            } else {
                                const v13822 = attr.$set(name, newValue);
                                v13822;
                            }
                        };
                        const v13824 = v13817.$watch(interpolateFn, v13823);
                        v13824;
                    };
                    const v13826 = {};
                    v13826.pre = v13825;
                    return v13826;
                };
                const v13828 = {
                    priority: 100,
                    compile: v13827
                };
                const v13829 = directives.push(v13828);
                v13829;
            };
            const replaceWith = function ($rootElement, elementsToRemove, newNode) {
                var firstElementToRemove = elementsToRemove[0];
                var removeCount = elementsToRemove.length;
                var parent = firstElementToRemove.parentNode;
                var i;
                var ii;
                if ($rootElement) {
                    (i = 0, ii = $rootElement.length)
                    let v13830 = i < ii;
                    while (v13830) {
                        const v13832 = $rootElement[i];
                        const v13833 = v13832 === firstElementToRemove;
                        if (v13833) {
                            const v13834 = i++;
                            $rootElement[v13834] = newNode;
                            var j = i;
                            const v13835 = j + removeCount;
                            var j2 = v13835 - 1;
                            var jj = $rootElement.length;
                            let v13836 = j < jj;
                            while (v13836) {
                                const v13839 = j2 < jj;
                                if (v13839) {
                                    const v13840 = $rootElement[j2];
                                    $rootElement[j] = v13840;
                                } else {
                                    const v13841 = $rootElement[j];
                                    const v13842 = delete v13841;
                                    v13842;
                                }
                                const v13837 = j++;
                                const v13838 = j2++;
                                v13836 = j < jj;
                            }
                            $rootElement.length -= removeCount - 1;
                            const v13843 = $rootElement.context;
                            const v13844 = v13843 === firstElementToRemove;
                            if (v13844) {
                                $rootElement.context = newNode;
                            }
                            break;
                        }
                        const v13831 = i++;
                        v13830 = i < ii;
                    }
                }
                if (parent) {
                    const v13845 = parent.replaceChild(newNode, firstElementToRemove);
                    v13845;
                }
                const v13846 = window.document;
                var fragment = v13846.createDocumentFragment();
                (i = 0)
                let v13847 = i < removeCount;
                while (v13847) {
                    const v13849 = elementsToRemove[i];
                    const v13850 = fragment.appendChild(v13849);
                    v13850;
                    const v13848 = i++;
                    v13847 = i < removeCount;
                }
                const v13851 = jqLite.hasData(firstElementToRemove);
                if (v13851) {
                    const v13852 = jqLite.data(firstElementToRemove);
                    const v13853 = jqLite.data(newNode, v13852);
                    v13853;
                    const v13854 = jqLite(firstElementToRemove);
                    const v13855 = v13854.off('$destroy');
                    v13855;
                }
                const v13856 = fragment.querySelectorAll('*');
                const v13857 = jqLite.cleanData(v13856);
                v13857;
                (i = 1)
                let v13858 = i < removeCount;
                while (v13858) {
                    const v13860 = elementsToRemove[i];
                    const v13861 = delete v13860;
                    v13861;
                    const v13859 = i++;
                    v13858 = i < removeCount;
                }
                elementsToRemove[0] = newNode;
                elementsToRemove.length = 1;
            };
            const cloneAndAnnotateFn = function (fn, annotation) {
                const v13863 = function () {
                    const v13862 = fn.apply(null, arguments);
                    return v13862;
                };
                const v13864 = extend(v13863, fn, annotation);
                return v13864;
            };
            const invokeLinkFn = function (linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    const v13865 = linkFn(scope, $element, attrs, controllers, transcludeFn);
                    v13865;
                } catch (e) {
                    const v13866 = startingTag($element);
                    const v13867 = $exceptionHandler(e, v13866);
                    v13867;
                }
            };
            const strictBindingsCheck = function (attrName, directiveName) {
                if (strictComponentBindingsEnabled) {
                    const v13868 = $compileMinErr('missingattr', 'Attribute \'{0}\' of \'{1}\' is non-optional and must be set!', attrName, directiveName);
                    throw v13868;
                }
            };
            const initializeDirectiveBindings = function (scope, attrs, destination, bindings, directive) {
                var removeWatchCollection = [];
                var initialChanges = {};
                var changes;
                const v13949 = function initializeBinding(definition, scopeName) {
                    var attrName = definition.attrName;
                    var optional = definition.optional;
                    var mode = definition.mode;
                    var lastValue;
                    var parentGet;
                    var parentSet;
                    var compare;
                    var removeWatch;
                    switch (mode) {
                    case '@':
                        const v13869 = !optional;
                        const v13870 = hasOwnProperty.call(attrs, attrName);
                        const v13871 = !v13870;
                        const v13872 = v13869 && v13871;
                        if (v13872) {
                            const v13873 = directive.name;
                            const v13874 = strictBindingsCheck(attrName, v13873);
                            v13874;
                            attrs.attrName = undefined;
                            destination[scopeName] = attrs[attrName];
                        }
                        const v13879 = function (value) {
                            const v13875 = isString(value);
                            const v13876 = isBoolean(value);
                            const v13877 = v13875 || v13876;
                            if (v13877) {
                                var oldValue = destination[scopeName];
                                const v13878 = recordChanges(scopeName, value, oldValue);
                                v13878;
                                destination[scopeName] = value;
                            }
                        };
                        removeWatch = attrs.$observe(attrName, v13879);
                        const v13880 = attrs.$$observers;
                        const v13881 = v13880[attrName];
                        v13881.$$scope = scope;
                        lastValue = attrs[attrName];
                        const v13882 = isString(lastValue);
                        if (v13882) {
                            const v13883 = $interpolate(lastValue);
                            const v13884 = v13883(scope);
                            destination[scopeName] = v13884;
                        } else {
                            const v13885 = isBoolean(lastValue);
                            if (v13885) {
                                destination[scopeName] = lastValue;
                            }
                        }
                        const v13886 = destination[scopeName];
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, v13886);
                        const v13887 = removeWatchCollection.push(removeWatch);
                        v13887;
                        break;
                    case '=':
                        const v13888 = hasOwnProperty.call(attrs, attrName);
                        const v13889 = !v13888;
                        if (v13889) {
                            if (optional) {
                                break;
                            }
                            const v13890 = directive.name;
                            const v13891 = strictBindingsCheck(attrName, v13890);
                            v13891;
                            attrs[attrName] = undefined;
                        }
                        const v13892 = attrs[attrName];
                        const v13893 = !v13892;
                        const v13894 = optional && v13893;
                        if (v13894) {
                            break;
                        }
                        const v13895 = attrs[attrName];
                        parentGet = $parse(v13895);
                        const v13896 = parentGet.literal;
                        if (v13896) {
                            compare = equals;
                        } else {
                            compare = simpleCompare;
                        }
                        const v13897 = parentGet.assign;
                        const v13902 = function () {
                            const v13898 = parentGet(scope);
                            destination.scopeName = v13898;
                            lastValue = destination[scopeName];
                            const v13899 = attrs[attrName];
                            const v13900 = directive.name;
                            const v13901 = $compileMinErr('nonassign', 'Expression \'{0}\' in attribute \'{1}\' used with directive \'{2}\' is non-assignable!', v13899, attrName, v13900);
                            throw v13901;
                        };
                        parentSet = v13897 || v13902;
                        const v13903 = parentGet(scope);
                        destination.scopeName = v13903;
                        lastValue = destination[scopeName];
                        var parentValueWatch = function parentValueWatch(parentValue) {
                            const v13904 = destination[scopeName];
                            const v13905 = compare(parentValue, v13904);
                            const v13906 = !v13905;
                            if (v13906) {
                                const v13907 = compare(parentValue, lastValue);
                                const v13908 = !v13907;
                                if (v13908) {
                                    destination[scopeName] = parentValue;
                                } else {
                                    parentValue = destination[scopeName];
                                    const v13909 = parentSet(scope, parentValue);
                                    v13909;
                                }
                            }
                            lastValue = parentValue;
                            return lastValue;
                        };
                        parentValueWatch.$stateful = true;
                        const v13910 = definition.collection;
                        if (v13910) {
                            const v13911 = attrs[attrName];
                            removeWatch = scope.$watchCollection(v13911, parentValueWatch);
                        } else {
                            const v13912 = attrs[attrName];
                            const v13913 = $parse(v13912, parentValueWatch);
                            const v13914 = parentGet.literal;
                            removeWatch = scope.$watch(v13913, null, v13914);
                        }
                        const v13915 = removeWatchCollection.push(removeWatch);
                        v13915;
                        break;
                    case '<':
                        const v13916 = hasOwnProperty.call(attrs, attrName);
                        const v13917 = !v13916;
                        if (v13917) {
                            if (optional) {
                                break;
                            }
                            const v13918 = directive.name;
                            const v13919 = strictBindingsCheck(attrName, v13918);
                            v13919;
                            attrs[attrName] = undefined;
                        }
                        const v13920 = attrs[attrName];
                        const v13921 = !v13920;
                        const v13922 = optional && v13921;
                        if (v13922) {
                            break;
                        }
                        const v13923 = attrs[attrName];
                        parentGet = $parse(v13923);
                        var isLiteral = parentGet.literal;
                        const v13924 = parentGet(scope);
                        destination[scopeName] = v13924;
                        var initialValue = destination[scopeName];
                        const v13925 = destination[scopeName];
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, v13925);
                        const v13926 = definition.collection;
                        let v13927;
                        if (v13926) {
                            v13927 = '$watchCollection';
                        } else {
                            v13927 = '$watch';
                        }
                        const v13934 = function parentValueWatchAction(newValue, oldValue) {
                            const v13928 = oldValue === newValue;
                            if (v13928) {
                                const v13929 = oldValue === initialValue;
                                const v13930 = equals(oldValue, initialValue);
                                const v13931 = isLiteral && v13930;
                                const v13932 = v13929 || v13931;
                                if (v13932) {
                                    return;
                                }
                                oldValue = initialValue;
                            }
                            const v13933 = recordChanges(scopeName, newValue, oldValue);
                            v13933;
                            destination[scopeName] = newValue;
                        };
                        removeWatch = scope[v13927](parentGet, v13934);
                        const v13935 = removeWatchCollection.push(removeWatch);
                        v13935;
                        break;
                    case '&':
                        const v13936 = !optional;
                        const v13937 = hasOwnProperty.call(attrs, attrName);
                        const v13938 = !v13937;
                        const v13939 = v13936 && v13938;
                        if (v13939) {
                            const v13940 = directive.name;
                            const v13941 = strictBindingsCheck(attrName, v13940);
                            v13941;
                        }
                        const v13942 = attrs.hasOwnProperty(attrName);
                        const v13943 = attrs[attrName];
                        const v13944 = $parse(v13943);
                        if (v13942) {
                            parentGet = v13944;
                        } else {
                            parentGet = noop;
                        }
                        const v13945 = parentGet === noop;
                        const v13946 = v13945 && optional;
                        if (v13946) {
                            break;
                        }
                        const v13948 = function (locals) {
                            const v13947 = parentGet(scope, locals);
                            return v13947;
                        };
                        destination[scopeName] = v13948;
                        break;
                    }
                };
                const v13950 = forEach(bindings, v13949);
                v13950;
                const recordChanges = function (key, currentValue, previousValue) {
                    const v13951 = destination.$onChanges;
                    const v13952 = isFunction(v13951);
                    const v13953 = simpleCompare(currentValue, previousValue);
                    const v13954 = !v13953;
                    const v13955 = v13952 && v13954;
                    if (v13955) {
                        const v13956 = !onChangesQueue;
                        if (v13956) {
                            const v13957 = scope.$$postDigest(flushOnChangesQueue);
                            v13957;
                            onChangesQueue = [];
                        }
                        const v13958 = !changes;
                        if (v13958) {
                            changes = {};
                            const v13959 = onChangesQueue.push(triggerOnChangesHook);
                            v13959;
                        }
                        const v13960 = changes[key];
                        if (v13960) {
                            const v13961 = changes[key];
                            previousValue = v13961.previousValue;
                        }
                        changes[key] = new SimpleChange(previousValue, currentValue);
                    }
                };
                const triggerOnChangesHook = function () {
                    const v13962 = destination.$onChanges(changes);
                    v13962;
                    changes = undefined;
                };
                const v13963 = removeWatchCollection.length;
                const v13967 = function removeWatches() {
                    var i = 0;
                    var ii = removeWatchCollection.length;
                    let v13964 = i < ii;
                    while (v13964) {
                        const v13966 = removeWatchCollection[i]();
                        v13966;
                        const v13965 = ++i;
                        v13964 = i < ii;
                    }
                };
                const v13968 = v13963 && v13967;
                const v13969 = {};
                v13969.initialChanges = initialChanges;
                v13969.removeWatches = v13968;
                return v13969;
            };
        };
        this.$get = [
            '$injector',
            '$interpolate',
            '$exceptionHandler',
            '$templateRequest',
            '$parse',
            '$controller',
            '$rootScope',
            '$sce',
            '$animate',
            v13970
        ];
    };
    const SimpleChange = function (previous, current) {
        this.previousValue = previous;
        this.currentValue = current;
    };
    const v13971 = SimpleChange.prototype;
    const v13974 = function () {
        const v13972 = this.previousValue;
        const v13973 = v13972 === _UNINITIALIZED_VALUE;
        return v13973;
    };
    v13971.isFirstChange = v13974;
    var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i;
    var SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;
    const directiveNormalize = function (name) {
        const v13975 = name.replace(PREFIX_REGEXP, '');
        const v13978 = function (_, letter, offset) {
            const v13976 = letter.toUpperCase();
            let v13977;
            if (offset) {
                v13977 = v13976;
            } else {
                v13977 = letter;
            }
            return v13977;
        };
        const v13979 = v13975.replace(SPECIAL_CHARS_REGEXP, v13978);
        return v13979;
    };
    const nodesetLinkingFn = function (scope, nodeList, rootElement, boundTranscludeFn) {
    };
    const directiveLinkingFn = function (nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
    };
    const tokenDifference = function (str1, str2) {
        var values = '';
        var tokens1 = str1.split(/\s+/);
        var tokens2 = str2.split(/\s+/);
        outer: {
            var i = 0;
            const v13980 = tokens1.length;
            let v13981 = i < v13980;
            while (v13981) {
                var token = tokens1[i];
                var j = 0;
                const v13983 = tokens2.length;
                let v13984 = j < v13983;
                while (v13984) {
                    const v13986 = tokens2[j];
                    const v13987 = token === v13986;
                    if (v13987) {
                        continue outer;
                    }
                    const v13985 = j++;
                    v13984 = j < v13983;
                }
                const v13988 = values.length;
                const v13989 = v13988 > 0;
                let v13990;
                if (v13989) {
                    v13990 = ' ';
                } else {
                    v13990 = '';
                }
                values += v13990 + token;
                const v13982 = i++;
                v13981 = i < v13980;
            }
        }
        return values;
    };
    const removeComments = function (jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        const v13991 = i <= 1;
        if (v13991) {
            return jqNodes;
        }
        let v13992 = i--;
        while (v13992) {
            var node = jqNodes[i];
            const v13993 = node.nodeType;
            const v13994 = v13993 === NODE_TYPE_COMMENT;
            const v13995 = node.nodeType;
            const v13996 = v13995 === NODE_TYPE_TEXT;
            const v13997 = node.nodeValue;
            const v13998 = v13997.trim();
            const v13999 = v13998 === '';
            const v14000 = v13996 && v13999;
            const v14001 = v13994 || v14000;
            if (v14001) {
                const v14002 = splice.call(jqNodes, i, 1);
                v14002;
            }
            v13992 = i--;
        }
        return jqNodes;
    };
    var $controllerMinErr = minErr('$controller');
    var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
    const identifierForController = function (controller, ident) {
        const v14003 = isString(ident);
        const v14004 = ident && v14003;
        if (v14004) {
            return ident;
        }
        const v14005 = isString(controller);
        if (v14005) {
            var match = CNTRL_REG.exec(controller);
            if (match) {
                const v14006 = match[3];
                return v14006;
            }
        }
    };
    const $ControllerProvider = function () {
        var controllers = {};
        const v14008 = function (name) {
            const v14007 = controllers.hasOwnProperty(name);
            return v14007;
        };
        this.has = v14008;
        const v14012 = function (name, constructor) {
            const v14009 = assertNotHasOwnProperty(name, 'controller');
            v14009;
            const v14010 = isObject(name);
            if (v14010) {
                const v14011 = extend(controllers, name);
                v14011;
            } else {
                controllers[name] = constructor;
            }
        };
        this.register = v14012;
        const v14058 = function ($injector) {
            const v14050 = function $controller(expression, locals, later, ident) {
                var instance;
                var match;
                var constructor;
                var identifier;
                later = later === true;
                const v14013 = isString(ident);
                const v14014 = ident && v14013;
                if (v14014) {
                    identifier = ident;
                }
                const v14015 = isString(expression);
                if (v14015) {
                    match = expression.match(CNTRL_REG);
                    const v14016 = !match;
                    if (v14016) {
                        const v14017 = 'Badly formed controller string \'{0}\'. ' + 'Must match `__name__ as __id__` or `__name__`.';
                        const v14018 = $controllerMinErr('ctrlfmt', v14017, expression);
                        throw v14018;
                    }
                    constructor = match[1];
                    const v14019 = match[3];
                    identifier = identifier || v14019;
                    const v14020 = controllers.hasOwnProperty(constructor);
                    const v14021 = controllers[constructor];
                    const v14022 = locals.$scope;
                    const v14023 = getter(v14022, constructor, true);
                    if (v14020) {
                        expression = v14021;
                    } else {
                        expression = v14023;
                    }
                    const v14024 = !expression;
                    if (v14024) {
                        const v14025 = $controllerMinErr('ctrlreg', 'The controller with the name \'{0}\' is not registered.', constructor);
                        throw v14025;
                    }
                    const v14026 = assertArgFn(expression, constructor, true);
                    v14026;
                }
                if (later) {
                    const v14027 = isArray(expression);
                    const v14028 = expression.length;
                    const v14029 = v14028 - 1;
                    const v14030 = expression[v14029];
                    let v14031;
                    if (v14027) {
                        v14031 = v14030;
                    } else {
                        v14031 = expression;
                    }
                    var controllerPrototype = v14031.prototype;
                    const v14032 = controllerPrototype || null;
                    instance = Object.create(v14032);
                    if (identifier) {
                        const v14033 = expression.name;
                        const v14034 = constructor || v14033;
                        const v14035 = addIdentifier(locals, identifier, instance, v14034);
                        v14035;
                    }
                    const v14044 = function $controllerInit() {
                        var result = $injector.invoke(expression, instance, locals, constructor);
                        const v14036 = result !== instance;
                        const v14037 = isObject(result);
                        const v14038 = isFunction(result);
                        const v14039 = v14037 || v14038;
                        const v14040 = v14036 && v14039;
                        if (v14040) {
                            instance = result;
                            if (identifier) {
                                const v14041 = expression.name;
                                const v14042 = constructor || v14041;
                                const v14043 = addIdentifier(locals, identifier, instance, v14042);
                                v14043;
                            }
                        }
                        return instance;
                    };
                    const v14045 = {
                        instance: instance,
                        identifier: identifier
                    };
                    const v14046 = extend(v14044, v14045);
                    return v14046;
                }
                instance = $injector.instantiate(expression, locals, constructor);
                if (identifier) {
                    const v14047 = expression.name;
                    const v14048 = constructor || v14047;
                    const v14049 = addIdentifier(locals, identifier, instance, v14048);
                    v14049;
                }
                return instance;
            };
            return v14050;
            const addIdentifier = function (locals, identifier, instance, name) {
                const v14051 = locals.$scope;
                const v14052 = isObject(v14051);
                const v14053 = locals && v14052;
                const v14054 = !v14053;
                if (v14054) {
                    const v14055 = minErr('$controller');
                    const v14056 = v14055('noscp', 'Cannot export controller \'{0}\' as \'{1}\'! No $scope object provided via `locals`.', name, identifier);
                    throw v14056;
                }
                const v14057 = locals.$scope;
                v14057[identifier] = instance;
            };
        };
        this.$get = [
            '$injector',
            v14058
        ];
    };
    const $DocumentProvider = function () {
        const v14061 = function (window) {
            const v14059 = window.document;
            const v14060 = jqLite(v14059);
            return v14060;
        };
        this.$get = [
            '$window',
            v14061
        ];
    };
    const $$IsDocumentHiddenProvider = function () {
        const v14068 = function ($document, $rootScope) {
            var doc = $document[0];
            const v14062 = doc.hidden;
            var hidden = doc && v14062;
            const v14063 = $document.on('visibilitychange', changeListener);
            v14063;
            const v14065 = function () {
                const v14064 = $document.off('visibilitychange', changeListener);
                v14064;
            };
            const v14066 = $rootScope.$on('$destroy', v14065);
            v14066;
            const changeListener = function () {
                hidden = doc.hidden;
            };
            const v14067 = function () {
                return hidden;
            };
            return v14067;
        };
        this.$get = [
            '$document',
            '$rootScope',
            v14068
        ];
    };
    const $ExceptionHandlerProvider = function () {
        const v14072 = function ($log) {
            const v14071 = function (exception, cause) {
                const v14069 = $log.error;
                const v14070 = v14069.apply($log, arguments);
                v14070;
            };
            return v14071;
        };
        this.$get = [
            '$log',
            v14072
        ];
    };
    var $$ForceReflowProvider = function () {
        const v14081 = function ($document) {
            const v14080 = function (domNode) {
                if (domNode) {
                    const v14073 = domNode.nodeType;
                    const v14074 = !v14073;
                    const v14075 = domNode instanceof jqLite;
                    const v14076 = v14074 && v14075;
                    if (v14076) {
                        domNode = domNode[0];
                    }
                } else {
                    const v14077 = $document[0];
                    domNode = v14077.body;
                }
                const v14078 = domNode.offsetWidth;
                const v14079 = v14078 + 1;
                return v14079;
            };
            return v14080;
        };
        this.$get = [
            '$document',
            v14081
        ];
    };
    var APPLICATION_JSON = 'application/json';
    const v14082 = APPLICATION_JSON + ';charset=utf-8';
    var CONTENT_TYPE_APPLICATION_JSON = {};
    CONTENT_TYPE_APPLICATION_JSON['Content-Type'] = v14082;
    var JSON_START = /^\[|^\{(?!\{)/;
    var JSON_ENDS = {};
    JSON_ENDS['['] = /]$/;
    JSON_ENDS['{'] = /}$/;
    var JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;
    var $httpMinErr = minErr('$http');
    const serializeValue = function (v) {
        const v14083 = isObject(v);
        if (v14083) {
            const v14084 = isDate(v);
            const v14085 = v.toISOString();
            const v14086 = toJson(v);
            let v14087;
            if (v14084) {
                v14087 = v14085;
            } else {
                v14087 = v14086;
            }
            return v14087;
        }
        return v;
    };
    const $HttpParamSerializerProvider = function () {
        const v14113 = function () {
            const v14112 = function ngParamSerializer(params) {
                const v14088 = !params;
                if (v14088) {
                    return '';
                }
                var parts = [];
                const v14109 = function (value, key) {
                    const v14089 = value === null;
                    const v14090 = isUndefined(value);
                    const v14091 = v14089 || v14090;
                    const v14092 = isFunction(value);
                    const v14093 = v14091 || v14092;
                    if (v14093) {
                        return;
                    }
                    const v14094 = isArray(value);
                    if (v14094) {
                        const v14101 = function (v) {
                            const v14095 = encodeUriQuery(key);
                            const v14096 = v14095 + '=';
                            const v14097 = serializeValue(v);
                            const v14098 = encodeUriQuery(v14097);
                            const v14099 = v14096 + v14098;
                            const v14100 = parts.push(v14099);
                            v14100;
                        };
                        const v14102 = forEach(value, v14101);
                        v14102;
                    } else {
                        const v14103 = encodeUriQuery(key);
                        const v14104 = v14103 + '=';
                        const v14105 = serializeValue(value);
                        const v14106 = encodeUriQuery(v14105);
                        const v14107 = v14104 + v14106;
                        const v14108 = parts.push(v14107);
                        v14108;
                    }
                };
                const v14110 = forEachSorted(params, v14109);
                v14110;
                const v14111 = parts.join('&');
                return v14111;
            };
            return v14112;
        };
        this.$get = v14113;
    };
    const $HttpParamSerializerJQLikeProvider = function () {
        const v14148 = function () {
            const v14147 = function jQueryLikeParamSerializer(params) {
                const v14114 = !params;
                if (v14114) {
                    return '';
                }
                var parts = [];
                const v14115 = serialize(params, '', true);
                v14115;
                const v14116 = parts.join('&');
                return v14116;
                const serialize = function (toSerialize, prefix, topLevel) {
                    const v14117 = isArray(toSerialize);
                    if (v14117) {
                        const v14124 = function (value, index) {
                            const v14118 = prefix + '[';
                            const v14119 = isObject(value);
                            let v14120;
                            if (v14119) {
                                v14120 = index;
                            } else {
                                v14120 = '';
                            }
                            const v14121 = v14118 + v14120;
                            const v14122 = v14121 + ']';
                            const v14123 = serialize(value, v14122);
                            v14123;
                        };
                        const v14125 = forEach(toSerialize, v14124);
                        v14125;
                    } else {
                        const v14126 = isObject(toSerialize);
                        const v14127 = isDate(toSerialize);
                        const v14128 = !v14127;
                        const v14129 = v14126 && v14128;
                        if (v14129) {
                            const v14136 = function (value, key) {
                                let v14130;
                                if (topLevel) {
                                    v14130 = '';
                                } else {
                                    v14130 = '[';
                                }
                                const v14131 = prefix + v14130;
                                const v14132 = v14131 + key;
                                let v14133;
                                if (topLevel) {
                                    v14133 = '';
                                } else {
                                    v14133 = ']';
                                }
                                const v14134 = v14132 + v14133;
                                const v14135 = serialize(value, v14134);
                                v14135;
                            };
                            const v14137 = forEachSorted(toSerialize, v14136);
                            v14137;
                        } else {
                            const v14138 = isFunction(toSerialize);
                            if (v14138) {
                                toSerialize = toSerialize();
                            }
                            const v14139 = encodeUriQuery(prefix);
                            const v14140 = v14139 + '=';
                            const v14141 = toSerialize == null;
                            const v14142 = serializeValue(toSerialize);
                            const v14143 = encodeUriQuery(v14142);
                            let v14144;
                            if (v14141) {
                                v14144 = '';
                            } else {
                                v14144 = v14143;
                            }
                            const v14145 = v14140 + v14144;
                            const v14146 = parts.push(v14145);
                            v14146;
                        }
                    }
                };
            };
            return v14147;
        };
        this.$get = v14148;
    };
    const defaultHttpResponseTransform = function (data, headers) {
        const v14149 = isString(data);
        if (v14149) {
            const v14150 = data.replace(JSON_PROTECTION_PREFIX, '');
            var tempData = v14150.trim();
            if (tempData) {
                var contentType = headers('Content-Type');
                const v14151 = contentType.indexOf(APPLICATION_JSON);
                const v14152 = v14151 === 0;
                var hasJsonContentType = contentType && v14152;
                const v14153 = isJsonLike(tempData);
                const v14154 = hasJsonContentType || v14153;
                if (v14154) {
                    try {
                        data = fromJson(tempData);
                    } catch (e) {
                        const v14155 = !hasJsonContentType;
                        if (v14155) {
                            return data;
                        }
                        const v14156 = 'Data must be a valid JSON object. Received: "{0}". ' + 'Parse error: "{1}"';
                        const v14157 = $httpMinErr('baddata', v14156, data, e);
                        throw v14157;
                    }
                }
            }
        }
        return data;
    };
    const isJsonLike = function (str) {
        var jsonStart = str.match(JSON_START);
        const v14158 = jsonStart[0];
        const v14159 = JSON_ENDS[v14158];
        const v14160 = v14159.test(str);
        const v14161 = jsonStart && v14160;
        return v14161;
    };
    const parseHeaders = function (headers) {
        var parsed = createMap();
        var i;
        const fillInParsed = function (key, val) {
            if (key) {
                const v14162 = parsed[key];
                const v14163 = parsed[key];
                const v14164 = v14163 + ', ';
                const v14165 = v14164 + val;
                let v14166;
                if (v14162) {
                    v14166 = v14165;
                } else {
                    v14166 = val;
                }
                parsed[key] = v14166;
            }
        };
        const v14167 = isString(headers);
        if (v14167) {
            const v14168 = headers.split('\n');
            const v14176 = function (line) {
                i = line.indexOf(':');
                const v14169 = line.substr(0, i);
                const v14170 = trim(v14169);
                const v14171 = lowercase(v14170);
                const v14172 = i + 1;
                const v14173 = line.substr(v14172);
                const v14174 = trim(v14173);
                const v14175 = fillInParsed(v14171, v14174);
                v14175;
            };
            const v14177 = forEach(v14168, v14176);
            v14177;
        } else {
            const v14178 = isObject(headers);
            if (v14178) {
                const v14182 = function (headerVal, headerKey) {
                    const v14179 = lowercase(headerKey);
                    const v14180 = trim(headerVal);
                    const v14181 = fillInParsed(v14179, v14180);
                    v14181;
                };
                const v14183 = forEach(headers, v14182);
                v14183;
            }
        }
        return parsed;
    };
    const headersGetter = function (headers) {
        var headersObj;
        const v14187 = function (name) {
            const v14184 = !headersObj;
            if (v14184) {
                headersObj = parseHeaders(headers);
            }
            if (name) {
                const v14185 = lowercase(name);
                var value = headersObj[v14185];
                const v14186 = value === undefined;
                if (v14186) {
                    value = null;
                }
                return value;
            }
            return headersObj;
        };
        return v14187;
    };
    const transformData = function (data, headers, status, fns) {
        const v14188 = isFunction(fns);
        if (v14188) {
            const v14189 = fns(data, headers, status);
            return v14189;
        }
        const v14190 = function (fn) {
            data = fn(data, headers, status);
        };
        const v14191 = forEach(fns, v14190);
        v14191;
        return data;
    };
    const isSuccess = function (status) {
        const v14192 = 200 <= status;
        const v14193 = status < 300;
        const v14194 = v14192 && v14193;
        return v14194;
    };
    const $HttpProvider = function () {
        const v14195 = [defaultHttpResponseTransform];
        const v14208 = function (d) {
            const v14196 = isObject(d);
            const v14197 = isFile(d);
            const v14198 = !v14197;
            const v14199 = v14196 && v14198;
            const v14200 = isBlob(d);
            const v14201 = !v14200;
            const v14202 = v14199 && v14201;
            const v14203 = isFormData(d);
            const v14204 = !v14203;
            const v14205 = v14202 && v14204;
            const v14206 = toJson(d);
            let v14207;
            if (v14205) {
                v14207 = v14206;
            } else {
                v14207 = d;
            }
            return v14207;
        };
        const v14209 = [v14208];
        const v14210 = {};
        v14210['Accept'] = 'application/json, text/plain, */*';
        const v14211 = shallowCopy(CONTENT_TYPE_APPLICATION_JSON);
        const v14212 = shallowCopy(CONTENT_TYPE_APPLICATION_JSON);
        const v14213 = shallowCopy(CONTENT_TYPE_APPLICATION_JSON);
        const v14214 = {};
        v14214.common = v14210;
        v14214.post = v14211;
        v14214.put = v14212;
        v14214.patch = v14213;
        const v14215 = {};
        v14215.transformResponse = v14195;
        v14215.transformRequest = v14209;
        v14215.headers = v14214;
        v14215.xsrfCookieName = 'XSRF-TOKEN';
        v14215.xsrfHeaderName = 'X-XSRF-TOKEN';
        v14215.paramSerializer = '$httpParamSerializer';
        v14215.jsonpCallbackParam = 'callback';
        this.defaults = v14215;
        var defaults = this.defaults;
        var useApplyAsync = false;
        const v14219 = function (value) {
            const v14216 = isDefined(value);
            if (v14216) {
                const v14217 = !value;
                const v14218 = !v14217;
                useApplyAsync = v14218;
                return this;
            }
            return useApplyAsync;
        };
        this.useApplyAsync = v14219;
        this.interceptors = [];
        var interceptorFactories = this.interceptors;
        this.xsrfWhitelistedOrigins = [];
        var xsrfWhitelistedOrigins = this.xsrfWhitelistedOrigins;
        const v14466 = function ($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
            var defaultCache = $cacheFactory('$http');
            const v14220 = defaults.paramSerializer;
            const v14221 = isString(v14220);
            const v14222 = defaults.paramSerializer;
            const v14223 = $injector.get(v14222);
            const v14224 = defaults.paramSerializer;
            let v14225;
            if (v14221) {
                v14225 = v14223;
            } else {
                v14225 = v14224;
            }
            defaults.paramSerializer = v14225;
            var reversedInterceptors = [];
            const v14231 = function (interceptorFactory) {
                const v14226 = isString(interceptorFactory);
                const v14227 = $injector.get(interceptorFactory);
                const v14228 = $injector.invoke(interceptorFactory);
                let v14229;
                if (v14226) {
                    v14229 = v14227;
                } else {
                    v14229 = v14228;
                }
                const v14230 = reversedInterceptors.unshift(v14229);
                v14230;
            };
            const v14232 = forEach(interceptorFactories, v14231);
            v14232;
            var urlIsAllowedOrigin = urlIsAllowedOriginFactory(xsrfWhitelistedOrigins);
            const $http = function (requestConfig) {
                const v14233 = isObject(requestConfig);
                const v14234 = !v14233;
                if (v14234) {
                    const v14235 = minErr('$http');
                    const v14236 = v14235('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
                    throw v14236;
                }
                const v14237 = requestConfig.url;
                const v14238 = $sce.valueOf(v14237);
                const v14239 = isString(v14238);
                const v14240 = !v14239;
                if (v14240) {
                    const v14241 = minErr('$http');
                    const v14242 = requestConfig.url;
                    const v14243 = v14241('badreq', 'Http request configuration url must be a string or a $sce trusted object.  Received: {0}', v14242);
                    throw v14243;
                }
                const v14244 = defaults.transformRequest;
                const v14245 = defaults.transformResponse;
                const v14246 = defaults.paramSerializer;
                const v14247 = defaults.jsonpCallbackParam;
                const v14248 = {
                    method: 'get',
                    transformRequest: v14244,
                    transformResponse: v14245,
                    paramSerializer: v14246,
                    jsonpCallbackParam: v14247
                };
                var config = extend(v14248, requestConfig);
                const v14249 = mergeHeaders(requestConfig);
                config.headers = v14249;
                const v14250 = config.method;
                const v14251 = uppercase(v14250);
                config.method = v14251;
                const v14252 = config.paramSerializer;
                const v14253 = isString(v14252);
                const v14254 = config.paramSerializer;
                const v14255 = $injector.get(v14254);
                const v14256 = config.paramSerializer;
                let v14257;
                if (v14253) {
                    v14257 = v14255;
                } else {
                    v14257 = v14256;
                }
                config.paramSerializer = v14257;
                const v14258 = $browser.$$incOutstandingRequestCount('$http');
                v14258;
                var requestInterceptors = [];
                var responseInterceptors = [];
                var promise = $q.resolve(config);
                const v14271 = function (interceptor) {
                    const v14259 = interceptor.request;
                    const v14260 = interceptor.requestError;
                    const v14261 = v14259 || v14260;
                    if (v14261) {
                        const v14262 = interceptor.request;
                        const v14263 = interceptor.requestError;
                        const v14264 = requestInterceptors.unshift(v14262, v14263);
                        v14264;
                    }
                    const v14265 = interceptor.response;
                    const v14266 = interceptor.responseError;
                    const v14267 = v14265 || v14266;
                    if (v14267) {
                        const v14268 = interceptor.response;
                        const v14269 = interceptor.responseError;
                        const v14270 = responseInterceptors.push(v14268, v14269);
                        v14270;
                    }
                };
                const v14272 = forEach(reversedInterceptors, v14271);
                v14272;
                promise = chainInterceptors(promise, requestInterceptors);
                promise = promise.then(serverRequest);
                promise = chainInterceptors(promise, responseInterceptors);
                promise = promise.finally(completeOutstandingRequest);
                return promise;
                const chainInterceptors = function (promise, interceptors) {
                    var i = 0;
                    var ii = interceptors.length;
                    let v14273 = i < ii;
                    while (v14273) {
                        const v14274 = i++;
                        var thenFn = interceptors[v14274];
                        const v14275 = i++;
                        var rejectFn = interceptors[v14275];
                        promise = promise.then(thenFn, rejectFn);
                        v14273 = i < ii;
                    }
                    interceptors.length = 0;
                    return promise;
                };
                const completeOutstandingRequest = function () {
                    const v14276 = $browser.$$completeOutstandingRequest(noop, '$http');
                    v14276;
                };
                const executeHeaderFns = function (headers, config) {
                    var headerContent;
                    var processedHeaders = {};
                    const v14279 = function (headerFn, header) {
                        const v14277 = isFunction(headerFn);
                        if (v14277) {
                            headerContent = headerFn(config);
                            const v14278 = headerContent != null;
                            if (v14278) {
                                processedHeaders[header] = headerContent;
                            }
                        } else {
                            processedHeaders[header] = headerFn;
                        }
                    };
                    const v14280 = forEach(headers, v14279);
                    v14280;
                    return processedHeaders;
                };
                const mergeHeaders = function (config) {
                    var defHeaders = defaults.headers;
                    const v14281 = {};
                    const v14282 = config.headers;
                    var reqHeaders = extend(v14281, v14282);
                    var defHeaderName;
                    var lowercaseDefHeaderName;
                    var reqHeaderName;
                    const v14283 = {};
                    const v14284 = defHeaders.common;
                    const v14285 = config.method;
                    const v14286 = lowercase(v14285);
                    const v14287 = defHeaders[v14286];
                    defHeaders = extend(v14283, v14284, v14287);
                    defaultHeadersIteration: {
                        for (defHeaderName in defHeaders) {
                            lowercaseDefHeaderName = lowercase(defHeaderName);
                            for (reqHeaderName in reqHeaders) {
                                const v14288 = lowercase(reqHeaderName);
                                const v14289 = v14288 === lowercaseDefHeaderName;
                                if (v14289) {
                                    continue defaultHeadersIteration;
                                }
                            }
                            const v14290 = defHeaders[defHeaderName];
                            reqHeaders[defHeaderName] = v14290;
                        }
                    }
                    const v14291 = shallowCopy(config);
                    const v14292 = executeHeaderFns(reqHeaders, v14291);
                    return v14292;
                };
                const serverRequest = function (config) {
                    var headers = config.headers;
                    const v14293 = config.data;
                    const v14294 = headersGetter(headers);
                    const v14295 = config.transformRequest;
                    var reqData = transformData(v14293, v14294, undefined, v14295);
                    const v14296 = isUndefined(reqData);
                    if (v14296) {
                        const v14301 = function (value, header) {
                            const v14297 = lowercase(header);
                            const v14298 = v14297 === 'content-type';
                            if (v14298) {
                                const v14299 = headers[header];
                                const v14300 = delete v14299;
                                v14300;
                            }
                        };
                        const v14302 = forEach(headers, v14301);
                        v14302;
                    }
                    const v14303 = config.withCredentials;
                    const v14304 = isUndefined(v14303);
                    const v14305 = defaults.withCredentials;
                    const v14306 = isUndefined(v14305);
                    const v14307 = !v14306;
                    const v14308 = v14304 && v14307;
                    if (v14308) {
                        const v14309 = defaults.withCredentials;
                        config.withCredentials = v14309;
                    }
                    const v14310 = sendReq(config, reqData);
                    const v14311 = v14310.then(transformResponse, transformResponse);
                    return v14311;
                };
                const transformResponse = function (response) {
                    const v14312 = {};
                    var resp = extend(v14312, response);
                    const v14313 = response.data;
                    const v14314 = response.headers;
                    const v14315 = response.status;
                    const v14316 = config.transformResponse;
                    const v14317 = transformData(v14313, v14314, v14315, v14316);
                    resp.data = v14317;
                    const v14318 = response.status;
                    const v14319 = isSuccess(v14318);
                    const v14320 = $q.reject(resp);
                    let v14321;
                    if (v14319) {
                        v14321 = resp;
                    } else {
                        v14321 = v14320;
                    }
                    return v14321;
                };
            };
            $http.pendingRequests = [];
            const v14322 = createShortMethods('get', 'delete', 'head', 'jsonp');
            v14322;
            const v14323 = createShortMethodsWithData('post', 'put', 'patch');
            v14323;
            $http.defaults = defaults;
            return $http;
            const createShortMethods = function (names) {
                const v14331 = function (name) {
                    const v14330 = function (url, config) {
                        const v14324 = {};
                        const v14325 = {};
                        const v14326 = config || v14325;
                        const v14327 = {
                            method: name,
                            url: url
                        };
                        const v14328 = extend(v14324, v14326, v14327);
                        const v14329 = $http(v14328);
                        return v14329;
                    };
                    $http[name] = v14330;
                };
                const v14332 = forEach(arguments, v14331);
                v14332;
            };
            const createShortMethodsWithData = function (name) {
                const v14340 = function (name) {
                    const v14339 = function (url, data, config) {
                        const v14333 = {};
                        const v14334 = {};
                        const v14335 = config || v14334;
                        const v14336 = {
                            method: name,
                            url: url,
                            data: data
                        };
                        const v14337 = extend(v14333, v14335, v14336);
                        const v14338 = $http(v14337);
                        return v14338;
                    };
                    $http[name] = v14339;
                };
                const v14341 = forEach(arguments, v14340);
                v14341;
            };
            const sendReq = function (config, reqData) {
                var deferred = $q.defer();
                var promise = deferred.promise;
                var cache;
                var cachedResp;
                var reqHeaders = config.headers;
                const v14342 = config.method;
                const v14343 = lowercase(v14342);
                var isJsonp = v14343 === 'jsonp';
                var url = config.url;
                if (isJsonp) {
                    url = $sce.getTrustedResourceUrl(url);
                } else {
                    const v14344 = isString(url);
                    const v14345 = !v14344;
                    if (v14345) {
                        url = $sce.valueOf(url);
                    }
                }
                const v14346 = config.params;
                const v14347 = config.paramSerializer(v14346);
                url = buildUrl(url, v14347);
                if (isJsonp) {
                    const v14348 = config.jsonpCallbackParam;
                    url = sanitizeJsonpCallbackParam(url, v14348);
                }
                const v14349 = $http.pendingRequests;
                const v14350 = v14349.push(config);
                v14350;
                const v14351 = promise.then(removePendingReq, removePendingReq);
                v14351;
                const v14352 = config.cache;
                const v14353 = defaults.cache;
                const v14354 = v14352 || v14353;
                const v14355 = config.cache;
                const v14356 = v14355 !== false;
                const v14357 = v14354 && v14356;
                const v14358 = config.method;
                const v14359 = v14358 === 'GET';
                const v14360 = config.method;
                const v14361 = v14360 === 'JSONP';
                const v14362 = v14359 || v14361;
                const v14363 = v14357 && v14362;
                if (v14363) {
                    const v14364 = config.cache;
                    const v14365 = isObject(v14364);
                    const v14366 = config.cache;
                    const v14367 = defaults.cache;
                    const v14368 = isObject(v14367);
                    const v14369 = defaults.cache;
                    let v14370;
                    if (v14368) {
                        v14370 = v14369;
                    } else {
                        v14370 = defaultCache;
                    }
                    if (v14365) {
                        cache = v14366;
                    } else {
                        cache = v14370;
                    }
                }
                if (cache) {
                    cachedResp = cache.get(url);
                    const v14371 = isDefined(cachedResp);
                    if (v14371) {
                        const v14372 = isPromiseLike(cachedResp);
                        if (v14372) {
                            const v14373 = cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                            v14373;
                        } else {
                            const v14374 = isArray(cachedResp);
                            if (v14374) {
                                const v14375 = cachedResp[1];
                                const v14376 = cachedResp[0];
                                const v14377 = cachedResp[2];
                                const v14378 = shallowCopy(v14377);
                                const v14379 = cachedResp[3];
                                const v14380 = cachedResp[4];
                                const v14381 = resolvePromise(v14375, v14376, v14378, v14379, v14380);
                                v14381;
                            } else {
                                const v14382 = {};
                                const v14383 = resolvePromise(cachedResp, 200, v14382, 'OK', 'complete');
                                v14383;
                            }
                        }
                    } else {
                        const v14384 = cache.put(url, promise);
                        v14384;
                    }
                }
                const v14385 = isUndefined(cachedResp);
                if (v14385) {
                    let xsrfValue;
                    const v14386 = config.url;
                    const v14387 = urlIsAllowedOrigin(v14386);
                    const v14388 = $$cookieReader();
                    const v14389 = config.xsrfCookieName;
                    const v14390 = defaults.xsrfCookieName;
                    const v14391 = v14389 || v14390;
                    const v14392 = v14388[v14391];
                    if (v14387) {
                        xsrfValue = v14392;
                    } else {
                        xsrfValue = undefined;
                    }
                    if (xsrfValue) {
                        const v14393 = config.xsrfHeaderName;
                        const v14394 = defaults.xsrfHeaderName;
                        const v14395 = v14393 || v14394;
                        reqHeaders[v14395] = xsrfValue;
                    }
                    const v14396 = config.method;
                    const v14397 = config.timeout;
                    const v14398 = config.withCredentials;
                    const v14399 = config.responseType;
                    const v14400 = config.eventHandlers;
                    const v14401 = createApplyHandlers(v14400);
                    const v14402 = config.uploadEventHandlers;
                    const v14403 = createApplyHandlers(v14402);
                    const v14404 = $httpBackend(v14396, url, reqData, done, reqHeaders, v14397, v14398, v14399, v14401, v14403);
                    v14404;
                }
                return promise;
                const createApplyHandlers = function (eventHandlers) {
                    if (eventHandlers) {
                        var applyHandlers = {};
                        const v14411 = function (eventHandler, key) {
                            const v14410 = function (event) {
                                if (useApplyAsync) {
                                    const v14405 = $rootScope.$applyAsync(callEventHandler);
                                    v14405;
                                } else {
                                    const v14406 = $rootScope.$$phase;
                                    if (v14406) {
                                        const v14407 = callEventHandler();
                                        v14407;
                                    } else {
                                        const v14408 = $rootScope.$apply(callEventHandler);
                                        v14408;
                                    }
                                }
                                const callEventHandler = function () {
                                    const v14409 = eventHandler(event);
                                    v14409;
                                };
                            };
                            applyHandlers[key] = v14410;
                        };
                        const v14412 = forEach(eventHandlers, v14411);
                        v14412;
                        return applyHandlers;
                    }
                };
                const done = function (status, response, headersString, statusText, xhrStatus) {
                    if (cache) {
                        const v14413 = isSuccess(status);
                        if (v14413) {
                            const v14414 = parseHeaders(headersString);
                            const v14415 = [
                                status,
                                response,
                                v14414,
                                statusText,
                                xhrStatus
                            ];
                            const v14416 = cache.put(url, v14415);
                            v14416;
                        } else {
                            const v14417 = cache.remove(url);
                            v14417;
                        }
                    }
                    const resolveHttpPromise = function () {
                        const v14418 = resolvePromise(response, status, headersString, statusText, xhrStatus);
                        v14418;
                    };
                    if (useApplyAsync) {
                        const v14419 = $rootScope.$applyAsync(resolveHttpPromise);
                        v14419;
                    } else {
                        const v14420 = resolveHttpPromise();
                        v14420;
                        const v14421 = $rootScope.$$phase;
                        const v14422 = !v14421;
                        if (v14422) {
                            const v14423 = $rootScope.$apply();
                            v14423;
                        }
                    }
                };
                const resolvePromise = function (response, status, headers, statusText, xhrStatus) {
                    const v14424 = -1;
                    const v14425 = status >= v14424;
                    if (v14425) {
                        status = status;
                    } else {
                        status = 0;
                    }
                    const v14426 = isSuccess(status);
                    const v14427 = deferred.resolve;
                    const v14428 = deferred.reject;
                    let v14429;
                    if (v14426) {
                        v14429 = v14427;
                    } else {
                        v14429 = v14428;
                    }
                    const v14430 = headersGetter(headers);
                    const v14431 = {
                        data: response,
                        status: status,
                        headers: v14430,
                        config: config,
                        statusText: statusText,
                        xhrStatus: xhrStatus
                    };
                    const v14432 = v14429(v14431);
                    v14432;
                };
                const resolvePromiseWithResult = function (result) {
                    const v14433 = result.data;
                    const v14434 = result.status;
                    const v14435 = result.headers();
                    const v14436 = shallowCopy(v14435);
                    const v14437 = result.statusText;
                    const v14438 = result.xhrStatus;
                    const v14439 = resolvePromise(v14433, v14434, v14436, v14437, v14438);
                    v14439;
                };
                const removePendingReq = function () {
                    const v14440 = $http.pendingRequests;
                    var idx = v14440.indexOf(config);
                    const v14441 = -1;
                    const v14442 = idx !== v14441;
                    if (v14442) {
                        const v14443 = $http.pendingRequests;
                        const v14444 = v14443.splice(idx, 1);
                        v14444;
                    }
                };
            };
            const buildUrl = function (url, serializedParams) {
                const v14445 = serializedParams.length;
                const v14446 = v14445 > 0;
                if (v14446) {
                    const v14447 = url.indexOf('?');
                    const v14448 = -1;
                    const v14449 = v14447 === v14448;
                    let v14450;
                    if (v14449) {
                        v14450 = '?';
                    } else {
                        v14450 = '&';
                    }
                    url += v14450 + serializedParams;
                }
                return url;
            };
            const sanitizeJsonpCallbackParam = function (url, cbKey) {
                var parts = url.split('?');
                const v14451 = parts.length;
                const v14452 = v14451 > 2;
                if (v14452) {
                    const v14453 = $httpMinErr('badjsonp', 'Illegal use more than one "?", in url, "{1}"', url);
                    throw v14453;
                }
                const v14454 = parts[1];
                var params = parseKeyValue(v14454);
                const v14459 = function (value, key) {
                    const v14455 = value === 'JSON_CALLBACK';
                    if (v14455) {
                        const v14456 = $httpMinErr('badjsonp', 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                        throw v14456;
                    }
                    const v14457 = key === cbKey;
                    if (v14457) {
                        const v14458 = $httpMinErr('badjsonp', 'Illegal use of callback param, "{0}", in url, "{1}"', cbKey, url);
                        throw v14458;
                    }
                };
                const v14460 = forEach(params, v14459);
                v14460;
                const v14461 = url.indexOf('?');
                const v14462 = -1;
                const v14463 = v14461 === v14462;
                let v14464;
                if (v14463) {
                    v14464 = '?';
                } else {
                    v14464 = '&';
                }
                const v14465 = v14464 + cbKey;
                url += v14465 + '=JSON_CALLBACK';
                return url;
            };
        };
        this.$get = [
            '$browser',
            '$httpBackend',
            '$$cookieReader',
            '$cacheFactory',
            '$rootScope',
            '$q',
            '$injector',
            '$sce',
            v14466
        ];
    };
    const $xhrFactoryProvider = function () {
        const v14469 = function () {
            const v14468 = function createXhr() {
                const v14467 = new window.XMLHttpRequest();
                return v14467;
            };
            return v14468;
        };
        this.$get = v14469;
    };
    const $HttpBackendProvider = function () {
        const v14473 = function ($browser, $jsonpCallbacks, $document, $xhrFactory) {
            const v14470 = $browser.defer;
            const v14471 = $document[0];
            const v14472 = createHttpBackend($browser, $xhrFactory, v14470, $jsonpCallbacks, v14471);
            return v14472;
        };
        this.$get = [
            '$browser',
            '$jsonpCallbacks',
            '$document',
            '$xhrFactory',
            v14473
        ];
    };
    const createHttpBackend = function ($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        const v14534 = function (method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
            const v14474 = $browser.url();
            url = url || v14474;
            const v14475 = lowercase(method);
            const v14476 = v14475 === 'jsonp';
            if (v14476) {
                var callbackPath = callbacks.createCallback(url);
                const v14481 = function (status, text) {
                    const v14477 = status === 200;
                    const v14478 = callbacks.getResponse(callbackPath);
                    var response = v14477 && v14478;
                    const v14479 = completeRequest(callback, status, response, '', text, 'complete');
                    v14479;
                    const v14480 = callbacks.removeCallback(callbackPath);
                    v14480;
                };
                var jsonpDone = jsonpReq(url, callbackPath, v14481);
            } else {
                var xhr = createXhr(method, url);
                var abortedByTimeout = false;
                const v14482 = xhr.open(method, url, true);
                v14482;
                const v14485 = function (value, key) {
                    const v14483 = isDefined(value);
                    if (v14483) {
                        const v14484 = xhr.setRequestHeader(key, value);
                        v14484;
                    }
                };
                const v14486 = forEach(headers, v14485);
                v14486;
                const requestLoaded = function () {
                    const v14487 = xhr.statusText;
                    var statusText = v14487 || '';
                    let response;
                    const v14488 = 'response' in xhr;
                    const v14489 = xhr.response;
                    const v14490 = xhr.responseText;
                    if (v14488) {
                        response = v14489;
                    } else {
                        response = v14490;
                    }
                    let status;
                    const v14491 = xhr.status;
                    const v14492 = v14491 === 1223;
                    const v14493 = xhr.status;
                    if (v14492) {
                        status = 204;
                    } else {
                        status = v14493;
                    }
                    const v14494 = status === 0;
                    if (v14494) {
                        const v14495 = urlResolve(url);
                        const v14496 = v14495.protocol;
                        const v14497 = v14496 === 'file';
                        let v14498;
                        if (v14497) {
                            v14498 = 404;
                        } else {
                            v14498 = 0;
                        }
                        if (response) {
                            status = 200;
                        } else {
                            status = v14498;
                        }
                    }
                    const v14499 = xhr.getAllResponseHeaders();
                    const v14500 = completeRequest(callback, status, response, v14499, statusText, 'complete');
                    v14500;
                };
                xhr.onload = requestLoaded;
                var requestError = function () {
                    const v14501 = -1;
                    const v14502 = completeRequest(callback, v14501, null, null, '', 'error');
                    v14502;
                };
                var requestAborted = function () {
                    const v14503 = -1;
                    let v14504;
                    if (abortedByTimeout) {
                        v14504 = 'timeout';
                    } else {
                        v14504 = 'abort';
                    }
                    const v14505 = completeRequest(callback, v14503, null, null, '', v14504);
                    v14505;
                };
                var requestTimeout = function () {
                    const v14506 = -1;
                    const v14507 = completeRequest(callback, v14506, null, null, '', 'timeout');
                    v14507;
                };
                xhr.onerror = requestError;
                xhr.ontimeout = requestTimeout;
                xhr.onabort = requestAborted;
                const v14509 = function (value, key) {
                    const v14508 = xhr.addEventListener(key, value);
                    v14508;
                };
                const v14510 = forEach(eventHandlers, v14509);
                v14510;
                const v14513 = function (value, key) {
                    const v14511 = xhr.upload;
                    const v14512 = v14511.addEventListener(key, value);
                    v14512;
                };
                const v14514 = forEach(uploadEventHandlers, v14513);
                v14514;
                if (withCredentials) {
                    xhr.withCredentials = true;
                }
                if (responseType) {
                    try {
                        xhr.responseType = responseType;
                    } catch (e) {
                        const v14515 = responseType !== 'json';
                        if (v14515) {
                            throw e;
                        }
                    }
                }
                const v14516 = isUndefined(post);
                let v14517;
                if (v14516) {
                    v14517 = null;
                } else {
                    v14517 = post;
                }
                const v14518 = xhr.send(v14517);
                v14518;
            }
            const v14519 = timeout > 0;
            if (v14519) {
                const v14521 = function () {
                    const v14520 = timeoutRequest('timeout');
                    v14520;
                };
                var timeoutId = $browserDefer(v14521, timeout);
            } else {
                const v14522 = isPromiseLike(timeout);
                if (v14522) {
                    const v14527 = function () {
                        const v14523 = timeout.$$timeoutId;
                        const v14524 = isDefined(v14523);
                        let v14525;
                        if (v14524) {
                            v14525 = 'timeout';
                        } else {
                            v14525 = 'abort';
                        }
                        const v14526 = timeoutRequest(v14525);
                        v14526;
                    };
                    const v14528 = timeout.then(v14527);
                    v14528;
                }
            }
            const timeoutRequest = function (reason) {
                abortedByTimeout = reason === 'timeout';
                if (jsonpDone) {
                    const v14529 = jsonpDone();
                    v14529;
                }
                if (xhr) {
                    const v14530 = xhr.abort();
                    v14530;
                }
            };
            const completeRequest = function (callback, status, response, headersString, statusText, xhrStatus) {
                const v14531 = isDefined(timeoutId);
                if (v14531) {
                    const v14532 = $browserDefer.cancel(timeoutId);
                    v14532;
                }
                xhr = null;
                jsonpDone = xhr;
                const v14533 = callback(status, response, headersString, statusText, xhrStatus);
                v14533;
            };
        };
        return v14534;
        const jsonpReq = function (url, callbackPath, done) {
            url = url.replace('JSON_CALLBACK', callbackPath);
            var script = rawDocument.createElement('script');
            var callback = null;
            script.type = 'text/javascript';
            script.src = url;
            script.async = true;
            const v14548 = function (event) {
                const v14535 = script.removeEventListener('load', callback);
                v14535;
                const v14536 = script.removeEventListener('error', callback);
                v14536;
                const v14537 = rawDocument.body;
                const v14538 = v14537.removeChild(script);
                v14538;
                script = null;
                const v14539 = -1;
                var status = v14539;
                var text = 'unknown';
                if (event) {
                    const v14540 = event.type;
                    const v14541 = v14540 === 'load';
                    const v14542 = callbacks.wasCalled(callbackPath);
                    const v14543 = !v14542;
                    const v14544 = v14541 && v14543;
                    if (v14544) {
                        event.type = 'error';
                        event = {};
                        event = {};
                    }
                    text = event.type;
                    const v14545 = event.type;
                    const v14546 = v14545 === 'error';
                    if (v14546) {
                        status = 404;
                    } else {
                        status = 200;
                    }
                }
                if (done) {
                    const v14547 = done(status, text);
                    v14547;
                }
            };
            callback = v14548;
            const v14549 = script.addEventListener('load', callback);
            v14549;
            const v14550 = script.addEventListener('error', callback);
            v14550;
            const v14551 = rawDocument.body;
            const v14552 = v14551.appendChild(script);
            v14552;
            return callback;
        };
    };
    const v14553 = minErr('$interpolate');
    angular.$interpolateMinErr = v14553;
    var $interpolateMinErr = angular.$interpolateMinErr;
    const v14557 = function (text) {
        const v14554 = 'Error while interpolating: {0}\nStrict Contextual Escaping disallows ' + 'interpolations that concatenate multiple expressions when a trusted value is ';
        const v14555 = v14554 + 'required.  See http://docs.angularjs.org/api/ng.$sce';
        const v14556 = $interpolateMinErr('noconcat', v14555, text);
        throw v14556;
    };
    $interpolateMinErr.throwNoconcat = v14557;
    const v14560 = function (text, err) {
        const v14558 = err.toString();
        const v14559 = $interpolateMinErr('interr', 'Can\'t interpolate: {0}\n{1}', text, v14558);
        return v14559;
    };
    $interpolateMinErr.interr = v14560;
    const $InterpolateProvider = function () {
        var startSymbol = '{{';
        var endSymbol = '}}';
        const v14561 = function (value) {
            if (value) {
                startSymbol = value;
                return this;
            }
            return startSymbol;
        };
        this.startSymbol = v14561;
        const v14562 = function (value) {
            if (value) {
                endSymbol = value;
                return this;
            }
            return endSymbol;
        };
        this.endSymbol = v14562;
        const v14657 = function ($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length;
            var endSymbolLength = endSymbol.length;
            const v14563 = startSymbol.replace(/./g, escape);
            var escapedStartRegexp = new RegExp(v14563, 'g');
            const v14564 = endSymbol.replace(/./g, escape);
            var escapedEndRegexp = new RegExp(v14564, 'g');
            const escape = function (ch) {
                const v14565 = '\\\\\\' + ch;
                return v14565;
            };
            const unescapeText = function (text) {
                const v14566 = text.replace(escapedStartRegexp, startSymbol);
                const v14567 = v14566.replace(escapedEndRegexp, endSymbol);
                return v14567;
            };
            const constantWatchDelegate = function (scope, listener, objectEquality, constantInterp) {
                const v14570 = function constantInterpolateWatch(scope) {
                    const v14568 = unwatch();
                    v14568;
                    const v14569 = constantInterp(scope);
                    return v14569;
                };
                var unwatch = scope.$watch(v14570, listener, objectEquality);
                return unwatch;
            };
            const $interpolate = function (text, mustHaveExpression, trustedContext, allOrNothing) {
                const v14571 = $sce.URL;
                const v14572 = trustedContext === v14571;
                const v14573 = $sce.MEDIA_URL;
                const v14574 = trustedContext === v14573;
                var contextAllowsConcatenation = v14572 || v14574;
                const v14575 = text.length;
                const v14576 = !v14575;
                const v14577 = text.indexOf(startSymbol);
                const v14578 = -1;
                const v14579 = v14577 === v14578;
                const v14580 = v14576 || v14579;
                if (v14580) {
                    if (mustHaveExpression) {
                        return;
                    }
                    var unescapedText = unescapeText(text);
                    if (contextAllowsConcatenation) {
                        unescapedText = $sce.getTrusted(trustedContext, unescapedText);
                    }
                    var constantInterp = valueFn(unescapedText);
                    constantInterp.exp = text;
                    constantInterp.expressions = [];
                    constantInterp.$$watchDelegate = constantWatchDelegate;
                    return constantInterp;
                }
                const v14581 = !allOrNothing;
                const v14582 = !v14581;
                allOrNothing = v14582;
                var startIndex;
                var endIndex;
                var index = 0;
                var expressions = [];
                var parseFns;
                var textLength = text.length;
                var exp;
                var concat = [];
                var expressionPositions = [];
                var singleExpression;
                let v14583 = index < textLength;
                while (v14583) {
                    const v14584 = -1;
                    const v14585 = (startIndex = text.indexOf(startSymbol, index)) !== v14584;
                    const v14586 = startIndex + startSymbolLength;
                    const v14587 = -1;
                    const v14588 = (endIndex = text.indexOf(endSymbol, v14586)) !== v14587;
                    const v14589 = v14585 && v14588;
                    if (v14589) {
                        const v14590 = index !== startIndex;
                        if (v14590) {
                            const v14591 = text.substring(index, startIndex);
                            const v14592 = unescapeText(v14591);
                            const v14593 = concat.push(v14592);
                            v14593;
                        }
                        const v14594 = startIndex + startSymbolLength;
                        exp = text.substring(v14594, endIndex);
                        const v14595 = expressions.push(exp);
                        v14595;
                        index = endIndex + endSymbolLength;
                        const v14596 = concat.length;
                        const v14597 = expressionPositions.push(v14596);
                        v14597;
                        const v14598 = concat.push('');
                        v14598;
                    } else {
                        const v14599 = index !== textLength;
                        if (v14599) {
                            const v14600 = text.substring(index);
                            const v14601 = unescapeText(v14600);
                            const v14602 = concat.push(v14601);
                            v14602;
                        }
                        break;
                    }
                    v14583 = index < textLength;
                }
                const v14603 = concat.length;
                const v14604 = v14603 === 1;
                const v14605 = expressionPositions.length;
                const v14606 = v14605 === 1;
                singleExpression = v14604 && v14606;
                let interceptor;
                const v14607 = contextAllowsConcatenation && singleExpression;
                if (v14607) {
                    interceptor = undefined;
                } else {
                    interceptor = parseStringifyInterceptor;
                }
                const v14609 = function (exp) {
                    const v14608 = $parse(exp, interceptor);
                    return v14608;
                };
                parseFns = expressions.map(v14609);
                const v14610 = !mustHaveExpression;
                const v14611 = expressions.length;
                const v14612 = v14610 || v14611;
                if (v14612) {
                    var compute = function (values) {
                        var i = 0;
                        var ii = expressions.length;
                        let v14613 = i < ii;
                        while (v14613) {
                            const v14615 = values[i];
                            const v14616 = isUndefined(v14615);
                            const v14617 = allOrNothing && v14616;
                            if (v14617) {
                                return;
                            }
                            const v14618 = expressionPositions[i];
                            const v14619 = values[i];
                            concat[v14618] = v14619;
                            const v14614 = i++;
                            v14613 = i < ii;
                        }
                        if (contextAllowsConcatenation) {
                            const v14620 = concat[0];
                            const v14621 = concat.join('');
                            let v14622;
                            if (singleExpression) {
                                v14622 = v14620;
                            } else {
                                v14622 = v14621;
                            }
                            const v14623 = $sce.getTrusted(trustedContext, v14622);
                            return v14623;
                        } else {
                            const v14624 = concat.length;
                            const v14625 = v14624 > 1;
                            const v14626 = trustedContext && v14625;
                            if (v14626) {
                                const v14627 = $interpolateMinErr.throwNoconcat(text);
                                v14627;
                            }
                        }
                        const v14628 = concat.join('');
                        return v14628;
                    };
                    const v14635 = function interpolationFn(context) {
                        var i = 0;
                        var ii = expressions.length;
                        var values = new Array(ii);
                        try {
                            let v14629 = i < ii;
                            while (v14629) {
                                const v14631 = parseFns[i](context);
                                values[i] = v14631;
                                const v14630 = i++;
                                v14629 = i < ii;
                            }
                            const v14632 = compute(values);
                            return v14632;
                        } catch (err) {
                            const v14633 = $interpolateMinErr.interr(text, err);
                            const v14634 = $exceptionHandler(v14633);
                            v14634;
                        }
                    };
                    const v14641 = function (scope, listener) {
                        var lastValue;
                        const v14639 = function interpolateFnWatcher(values, oldValues) {
                            var currValue = compute(values);
                            const v14636 = values !== oldValues;
                            let v14637;
                            if (v14636) {
                                v14637 = lastValue;
                            } else {
                                v14637 = currValue;
                            }
                            const v14638 = listener.call(this, currValue, v14637, scope);
                            v14638;
                            lastValue = currValue;
                        };
                        const v14640 = scope.$watchGroup(parseFns, v14639);
                        return v14640;
                    };
                    const v14642 = {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: v14641
                    };
                    const v14643 = extend(v14635, v14642);
                    return v14643;
                }
                const parseStringifyInterceptor = function (value) {
                    try {
                        const v14644 = !contextAllowsConcatenation;
                        const v14645 = trustedContext && v14644;
                        const v14646 = $sce.getTrusted(trustedContext, value);
                        const v14647 = $sce.valueOf(value);
                        if (v14645) {
                            value = v14646;
                        } else {
                            value = v14647;
                        }
                        const v14648 = isDefined(value);
                        const v14649 = !v14648;
                        const v14650 = allOrNothing && v14649;
                        const v14651 = stringify(value);
                        let v14652;
                        if (v14650) {
                            v14652 = value;
                        } else {
                            v14652 = v14651;
                        }
                        return v14652;
                    } catch (err) {
                        const v14653 = $interpolateMinErr.interr(text, err);
                        const v14654 = $exceptionHandler(v14653);
                        v14654;
                    }
                };
            };
            const v14655 = function () {
                return startSymbol;
            };
            $interpolate.startSymbol = v14655;
            const v14656 = function () {
                return endSymbol;
            };
            $interpolate.endSymbol = v14656;
            return $interpolate;
        };
        this.$get = [
            '$parse',
            '$exceptionHandler',
            '$sce',
            v14657
        ];
    };
    var $intervalMinErr = minErr('$interval');
    const $IntervalProvider = function () {
        const v14673 = function ($$intervalFactory, $window) {
            var intervals = {};
            var setIntervalFn = function (tick, delay, deferred) {
                var id = $window.setInterval(tick, delay);
                intervals[id] = deferred;
                return id;
            };
            var clearIntervalFn = function (id) {
                const v14658 = $window.clearInterval(id);
                v14658;
                const v14659 = intervals[id];
                const v14660 = delete v14659;
                v14660;
            };
            var interval = $$intervalFactory(setIntervalFn, clearIntervalFn);
            const v14672 = function (promise) {
                const v14661 = !promise;
                if (v14661) {
                    return false;
                }
                const v14662 = promise.hasOwnProperty('$$intervalId');
                const v14663 = !v14662;
                if (v14663) {
                    const v14664 = $intervalMinErr('badprom', '`$interval.cancel()` called with a promise that was not generated by `$interval()`.');
                    throw v14664;
                }
                const v14665 = promise.$$intervalId;
                const v14666 = intervals.hasOwnProperty(v14665);
                const v14667 = !v14666;
                if (v14667) {
                    return false;
                }
                var id = promise.$$intervalId;
                var deferred = intervals[id];
                const v14668 = deferred.promise;
                const v14669 = markQExceptionHandled(v14668);
                v14669;
                const v14670 = deferred.reject('canceled');
                v14670;
                const v14671 = clearIntervalFn(id);
                v14671;
                return true;
            };
            interval.cancel = v14672;
            return interval;
        };
        this.$get = [
            '$$intervalFactory',
            '$window',
            v14673
        ];
    };
    const $$IntervalFactoryProvider = function () {
        const v14699 = function ($browser, $q, $$q, $rootScope) {
            const v14698 = function intervalFactory(setIntervalFn, clearIntervalFn) {
                const v14697 = function intervalFn(fn, delay, count, invokeApply) {
                    const v14674 = arguments.length;
                    var hasParams = v14674 > 4;
                    let args;
                    const v14675 = sliceArgs(arguments, 4);
                    const v14676 = [];
                    if (hasParams) {
                        args = v14675;
                    } else {
                        args = v14676;
                    }
                    var iteration = 0;
                    const v14677 = isDefined(invokeApply);
                    const v14678 = !invokeApply;
                    var skipApply = v14677 && v14678;
                    let v14679;
                    if (skipApply) {
                        v14679 = $$q;
                    } else {
                        v14679 = $q;
                    }
                    var deferred = v14679.defer();
                    var promise = deferred.promise;
                    const v14680 = isDefined(count);
                    if (v14680) {
                        count = count;
                    } else {
                        count = 0;
                    }
                    const callback = function () {
                        const v14681 = !hasParams;
                        if (v14681) {
                            const v14682 = fn(iteration);
                            v14682;
                        } else {
                            const v14683 = fn.apply(null, args);
                            v14683;
                        }
                    };
                    const tick = function () {
                        if (skipApply) {
                            const v14684 = $browser.defer(callback);
                            v14684;
                        } else {
                            const v14685 = $rootScope.$evalAsync(callback);
                            v14685;
                        }
                        const v14686 = iteration++;
                        const v14687 = deferred.notify(v14686);
                        v14687;
                        const v14688 = count > 0;
                        const v14689 = iteration >= count;
                        const v14690 = v14688 && v14689;
                        if (v14690) {
                            const v14691 = deferred.resolve(iteration);
                            v14691;
                            const v14692 = promise.$$intervalId;
                            const v14693 = clearIntervalFn(v14692);
                            v14693;
                        }
                        const v14694 = !skipApply;
                        if (v14694) {
                            const v14695 = $rootScope.$apply();
                            v14695;
                        }
                    };
                    const v14696 = setIntervalFn(tick, delay, deferred, skipApply);
                    promise.$$intervalId = v14696;
                    return promise;
                };
                return v14697;
            };
            return v14698;
        };
        this.$get = [
            '$browser',
            '$q',
            '$$q',
            '$rootScope',
            v14699
        ];
    };
    var $jsonpCallbacksProvider = function () {
        const v14717 = function () {
            var callbacks = angular.callbacks;
            var callbackMap = {};
            const createCallback = function (callbackId) {
                var callback = function (data) {
                    callback.data = data;
                    callback.called = true;
                };
                callback.id = callbackId;
                return callback;
            };
            const v14703 = function (url) {
                const v14700 = callbacks.$$counter;
                const v14701 = v14700++;
                const v14702 = v14701.toString(36);
                var callbackId = '_' + v14702;
                var callbackPath = 'angular.callbacks.' + callbackId;
                var callback = createCallback(callbackId);
                callbacks.callbackId = callback;
                callbackMap[callbackPath] = callbacks[callbackId];
                return callbackPath;
            };
            const v14706 = function (callbackPath) {
                const v14704 = callbackMap[callbackPath];
                const v14705 = v14704.called;
                return v14705;
            };
            const v14709 = function (callbackPath) {
                const v14707 = callbackMap[callbackPath];
                const v14708 = v14707.data;
                return v14708;
            };
            const v14715 = function (callbackPath) {
                var callback = callbackMap[callbackPath];
                const v14710 = callback.id;
                const v14711 = callbacks[v14710];
                const v14712 = delete v14711;
                v14712;
                const v14713 = callbackMap[callbackPath];
                const v14714 = delete v14713;
                v14714;
            };
            const v14716 = {};
            v14716.createCallback = v14703;
            v14716.wasCalled = v14706;
            v14716.getResponse = v14709;
            v14716.removeCallback = v14715;
            return v14716;
        };
        this.$get = v14717;
    };
    var PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/;
    var DEFAULT_PORTS = {};
    DEFAULT_PORTS['http'] = 80;
    DEFAULT_PORTS['https'] = 443;
    DEFAULT_PORTS['ftp'] = 21;
    var $locationMinErr = minErr('$location');
    const encodePath = function (path) {
        var segments = path.split('/');
        var i = segments.length;
        let v14718 = i--;
        while (v14718) {
            const v14719 = segments[i];
            const v14720 = v14719.replace(/%2F/g, '/');
            const v14721 = encodeUriSegment(v14720);
            segments[i] = v14721;
            v14718 = i--;
        }
        const v14722 = segments.join('/');
        return v14722;
    };
    const decodePath = function (path, html5Mode) {
        var segments = path.split('/');
        var i = segments.length;
        let v14723 = i--;
        while (v14723) {
            const v14724 = segments[i];
            const v14725 = decodeURIComponent(v14724);
            segments[i] = v14725;
            if (html5Mode) {
                const v14726 = segments[i];
                const v14727 = v14726.replace(/\//g, '%2F');
                segments[i] = v14727;
            }
            v14723 = i--;
        }
        const v14728 = segments.join('/');
        return v14728;
    };
    const normalizePath = function (pathValue, searchValue, hashValue) {
        var search = toKeyValue(searchValue);
        let hash;
        const v14729 = encodeUriSegment(hashValue);
        const v14730 = '#' + v14729;
        if (hashValue) {
            hash = v14730;
        } else {
            hash = '';
        }
        var path = encodePath(pathValue);
        const v14731 = '?' + search;
        let v14732;
        if (search) {
            v14732 = v14731;
        } else {
            v14732 = '';
        }
        const v14733 = path + v14732;
        const v14734 = v14733 + hash;
        return v14734;
    };
    const parseAbsoluteUrl = function (absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        const v14735 = parsedUrl.protocol;
        locationObj.$$protocol = v14735;
        const v14736 = parsedUrl.hostname;
        locationObj.$$host = v14736;
        const v14737 = parsedUrl.port;
        const v14738 = toInt(v14737);
        const v14739 = parsedUrl.protocol;
        const v14740 = DEFAULT_PORTS[v14739];
        const v14741 = v14738 || v14740;
        locationObj.$$port = v14741 || null;
    };
    var DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/;
    const parseAppUrl = function (url, locationObj, html5Mode) {
        const v14742 = DOUBLE_SLASH_REGEX.test(url);
        if (v14742) {
            const v14743 = $locationMinErr('badpath', 'Invalid url "{0}".', url);
            throw v14743;
        }
        const v14744 = url.charAt(0);
        var prefixed = v14744 !== '/';
        if (prefixed) {
            url = '/' + url;
        }
        var match = urlResolve(url);
        let path;
        const v14745 = match.pathname;
        const v14746 = v14745.charAt(0);
        const v14747 = v14746 === '/';
        const v14748 = prefixed && v14747;
        const v14749 = match.pathname;
        const v14750 = v14749.substring(1);
        const v14751 = match.pathname;
        if (v14748) {
            path = v14750;
        } else {
            path = v14751;
        }
        const v14752 = decodePath(path, html5Mode);
        locationObj.$$path = v14752;
        const v14753 = match.search;
        const v14754 = parseKeyValue(v14753);
        locationObj.$$search = v14754;
        const v14755 = match.hash;
        const v14756 = decodeURIComponent(v14755);
        locationObj.$$hash = v14756;
        const v14757 = locationObj.$$path;
        const v14758 = locationObj.$$path;
        const v14759 = v14758.charAt(0);
        const v14760 = v14759 !== '/';
        const v14761 = v14757 && v14760;
        if (v14761) {
            const v14762 = locationObj.$$path;
            locationObj.$$path = '/' + v14762;
        }
    };
    const startsWith = function (str, search) {
        const v14763 = search.length;
        const v14764 = str.slice(0, v14763);
        const v14765 = v14764 === search;
        return v14765;
    };
    const stripBaseUrl = function (base, url) {
        const v14766 = startsWith(url, base);
        if (v14766) {
            const v14767 = base.length;
            const v14768 = url.substr(v14767);
            return v14768;
        }
    };
    const stripHash = function (url) {
        var index = url.indexOf('#');
        const v14769 = -1;
        const v14770 = index === v14769;
        const v14771 = url.substr(0, index);
        let v14772;
        if (v14770) {
            v14772 = url;
        } else {
            v14772 = v14771;
        }
        return v14772;
    };
    const stripFile = function (url) {
        const v14773 = stripHash(url);
        const v14774 = v14773.lastIndexOf('/');
        const v14775 = v14774 + 1;
        const v14776 = url.substr(0, v14775);
        return v14776;
    };
    const serverBase = function (url) {
        const v14777 = url.indexOf('//');
        const v14778 = v14777 + 2;
        const v14779 = url.indexOf('/', v14778);
        const v14780 = url.substring(0, v14779);
        return v14780;
    };
    const LocationHtml5Url = function (appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        const v14781 = parseAbsoluteUrl(appBase, this);
        v14781;
        const v14789 = function (url) {
            var pathUrl = stripBaseUrl(appBaseNoFile, url);
            const v14782 = isString(pathUrl);
            const v14783 = !v14782;
            if (v14783) {
                const v14784 = $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                throw v14784;
            }
            const v14785 = parseAppUrl(pathUrl, this, true);
            v14785;
            const v14786 = this.$$path;
            const v14787 = !v14786;
            if (v14787) {
                this.$$path = '/';
            }
            const v14788 = this.$$compose();
            v14788;
        };
        this.$$parse = v14789;
        const v14792 = function (url) {
            const v14790 = url.substr(1);
            const v14791 = appBaseNoFile + v14790;
            return v14791;
        };
        this.$$normalizeUrl = v14792;
        const v14809 = function (url, relHref) {
            const v14793 = relHref[0];
            const v14794 = v14793 === '#';
            const v14795 = relHref && v14794;
            if (v14795) {
                const v14796 = relHref.slice(1);
                const v14797 = this.hash(v14796);
                v14797;
                return true;
            }
            var appUrl;
            var prevAppUrl;
            var rewrittenUrl;
            const v14798 = isDefined(appUrl = stripBaseUrl(appBase, url));
            if (v14798) {
                prevAppUrl = appUrl;
                const v14799 = isDefined(appUrl = stripBaseUrl(basePrefix, appUrl));
                const v14800 = basePrefix && v14799;
                if (v14800) {
                    const v14801 = stripBaseUrl('/', appUrl);
                    const v14802 = v14801 || appUrl;
                    rewrittenUrl = appBaseNoFile + v14802;
                } else {
                    rewrittenUrl = appBase + prevAppUrl;
                }
            } else {
                const v14803 = isDefined(appUrl = stripBaseUrl(appBaseNoFile, url));
                if (v14803) {
                    rewrittenUrl = appBaseNoFile + appUrl;
                } else {
                    const v14804 = url + '/';
                    const v14805 = appBaseNoFile === v14804;
                    if (v14805) {
                        rewrittenUrl = appBaseNoFile;
                    }
                }
            }
            if (rewrittenUrl) {
                const v14806 = this.$$parse(rewrittenUrl);
                v14806;
            }
            const v14807 = !rewrittenUrl;
            const v14808 = !v14807;
            return v14808;
        };
        this.$$parseLinkUrl = v14809;
    };
    const LocationHashbangUrl = function (appBase, appBaseNoFile, hashPrefix) {
        const v14810 = parseAbsoluteUrl(appBase, this);
        v14810;
        const v14830 = function (url) {
            const v14811 = stripBaseUrl(appBase, url);
            const v14812 = stripBaseUrl(appBaseNoFile, url);
            var withoutBaseUrl = v14811 || v14812;
            var withoutHashUrl;
            const v14813 = isUndefined(withoutBaseUrl);
            const v14814 = !v14813;
            const v14815 = withoutBaseUrl.charAt(0);
            const v14816 = v14815 === '#';
            const v14817 = v14814 && v14816;
            if (v14817) {
                withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
                const v14818 = isUndefined(withoutHashUrl);
                if (v14818) {
                    withoutHashUrl = withoutBaseUrl;
                }
            } else {
                const v14819 = this.$$html5;
                if (v14819) {
                    withoutHashUrl = withoutBaseUrl;
                } else {
                    withoutHashUrl = '';
                    const v14820 = isUndefined(withoutBaseUrl);
                    if (v14820) {
                        appBase = url;
                        const v14821 = this.replace();
                        v14821;
                    }
                }
            }
            const v14822 = parseAppUrl(withoutHashUrl, this, false);
            v14822;
            const v14823 = this.$$path;
            const v14824 = removeWindowsDriveName(v14823, withoutHashUrl, appBase);
            this.$$path = v14824;
            const v14825 = this.$$compose();
            v14825;
            const removeWindowsDriveName = function (path, url, base) {
                var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                var firstPathSegmentMatch;
                const v14826 = startsWith(url, base);
                if (v14826) {
                    url = url.replace(base, '');
                }
                const v14827 = windowsFilePathExp.exec(url);
                if (v14827) {
                    return path;
                }
                firstPathSegmentMatch = windowsFilePathExp.exec(path);
                const v14828 = firstPathSegmentMatch[1];
                let v14829;
                if (firstPathSegmentMatch) {
                    v14829 = v14828;
                } else {
                    v14829 = path;
                }
                return v14829;
            };
        };
        this.$$parse = v14830;
        const v14834 = function (url) {
            const v14831 = hashPrefix + url;
            let v14832;
            if (url) {
                v14832 = v14831;
            } else {
                v14832 = '';
            }
            const v14833 = appBase + v14832;
            return v14833;
        };
        this.$$normalizeUrl = v14834;
        const v14839 = function (url, relHref) {
            const v14835 = stripHash(appBase);
            const v14836 = stripHash(url);
            const v14837 = v14835 === v14836;
            if (v14837) {
                const v14838 = this.$$parse(url);
                v14838;
                return true;
            }
            return false;
        };
        this.$$parseLinkUrl = v14839;
    };
    const LocationHashbangInHtml5Url = function (appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        const v14840 = LocationHashbangUrl.apply(this, arguments);
        v14840;
        const v14854 = function (url, relHref) {
            const v14841 = relHref[0];
            const v14842 = v14841 === '#';
            const v14843 = relHref && v14842;
            if (v14843) {
                const v14844 = relHref.slice(1);
                const v14845 = this.hash(v14844);
                v14845;
                return true;
            }
            var rewrittenUrl;
            var appUrl;
            const v14846 = stripHash(url);
            const v14847 = appBase === v14846;
            if (v14847) {
                rewrittenUrl = url;
            } else {
                if (appUrl = stripBaseUrl(appBaseNoFile, url)) {
                    const v14848 = appBase + hashPrefix;
                    rewrittenUrl = v14848 + appUrl;
                } else {
                    const v14849 = url + '/';
                    const v14850 = appBaseNoFile === v14849;
                    if (v14850) {
                        rewrittenUrl = appBaseNoFile;
                    }
                }
            }
            if (rewrittenUrl) {
                const v14851 = this.$$parse(rewrittenUrl);
                v14851;
            }
            const v14852 = !rewrittenUrl;
            const v14853 = !v14852;
            return v14853;
        };
        this.$$parseLinkUrl = v14854;
        const v14857 = function (url) {
            const v14855 = appBase + hashPrefix;
            const v14856 = v14855 + url;
            return v14856;
        };
        this.$$normalizeUrl = v14857;
    };
    const v14864 = function () {
        const v14858 = this.$$path;
        const v14859 = this.$$search;
        const v14860 = this.$$hash;
        const v14861 = normalizePath(v14858, v14859, v14860);
        this.$$url = v14861;
        const v14862 = this.$$url;
        const v14863 = this.$$normalizeUrl(v14862);
        this.$$absUrl = v14863;
        this.$$urlUpdatedByLocation = true;
    };
    const v14865 = locationGetter('$$absUrl');
    const v14885 = function (url) {
        const v14866 = isUndefined(url);
        if (v14866) {
            const v14867 = this.$$url;
            return v14867;
        }
        var match = PATH_MATCH.exec(url);
        const v14868 = match[1];
        const v14869 = url === '';
        const v14870 = v14868 || v14869;
        if (v14870) {
            const v14871 = match[1];
            const v14872 = decodeURIComponent(v14871);
            const v14873 = this.path(v14872);
            v14873;
        }
        const v14874 = match[2];
        const v14875 = match[1];
        const v14876 = v14874 || v14875;
        const v14877 = url === '';
        const v14878 = v14876 || v14877;
        if (v14878) {
            const v14879 = match[3];
            const v14880 = v14879 || '';
            const v14881 = this.search(v14880);
            v14881;
        }
        const v14882 = match[5];
        const v14883 = v14882 || '';
        const v14884 = this.hash(v14883);
        v14884;
        return this;
    };
    const v14886 = locationGetter('$$protocol');
    const v14887 = locationGetter('$$host');
    const v14888 = locationGetter('$$port');
    const v14895 = function (path) {
        const v14889 = path !== null;
        const v14890 = path.toString();
        if (v14889) {
            path = v14890;
        } else {
            path = '';
        }
        const v14891 = path.charAt(0);
        const v14892 = v14891 === '/';
        const v14893 = '/' + path;
        let v14894;
        if (v14892) {
            v14894 = path;
        } else {
            v14894 = v14893;
        }
        return v14894;
    };
    const v14896 = locationGetterSetter('$$path', v14895);
    const v14919 = function (search, paramValue) {
        const v14897 = arguments.length;
        switch (v14897) {
        case 0:
            const v14898 = this.$$search;
            return v14898;
        case 1:
            const v14899 = isString(search);
            const v14900 = isNumber(search);
            const v14901 = v14899 || v14900;
            if (v14901) {
                search = search.toString();
                const v14902 = parseKeyValue(search);
                this.$$search = v14902;
            } else {
                const v14903 = isObject(search);
                if (v14903) {
                    const v14904 = {};
                    search = copy(search, v14904);
                    const v14908 = function (value, key) {
                        const v14905 = value == null;
                        if (v14905) {
                            const v14906 = search[key];
                            const v14907 = delete v14906;
                            v14907;
                        }
                    };
                    const v14909 = forEach(search, v14908);
                    v14909;
                    this.$$search = search;
                } else {
                    const v14910 = $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
                    throw v14910;
                }
            }
            break;
        default:
            const v14911 = isUndefined(paramValue);
            const v14912 = paramValue === null;
            const v14913 = v14911 || v14912;
            if (v14913) {
                const v14914 = this.$$search;
                const v14915 = v14914[search];
                const v14916 = delete v14915;
                v14916;
            } else {
                const v14917 = this.$$search;
                v14917[search] = paramValue;
            }
        }
        const v14918 = this.$$compose();
        v14918;
        return this;
    };
    const v14923 = function (hash) {
        const v14920 = hash !== null;
        const v14921 = hash.toString();
        let v14922;
        if (v14920) {
            v14922 = v14921;
        } else {
            v14922 = '';
        }
        return v14922;
    };
    const v14924 = locationGetterSetter('$$hash', v14923);
    const v14925 = function () {
        this.$$replace = true;
        return this;
    };
    var locationPrototype = {};
    locationPrototype.$$absUrl = '';
    locationPrototype.$$html5 = false;
    locationPrototype.$$replace = false;
    locationPrototype.$$compose = v14864;
    locationPrototype.absUrl = v14865;
    locationPrototype.url = v14885;
    locationPrototype.protocol = v14886;
    locationPrototype.host = v14887;
    locationPrototype.port = v14888;
    locationPrototype.path = v14896;
    locationPrototype.search = v14919;
    locationPrototype.hash = v14924;
    locationPrototype.replace = v14925;
    const v14926 = [
        LocationHashbangInHtml5Url,
        LocationHashbangUrl,
        LocationHtml5Url
    ];
    const v14941 = function (Location) {
        const v14927 = Object.create(locationPrototype);
        Location.prototype = v14927;
        const v14928 = Location.prototype;
        const v14940 = function (state) {
            const v14929 = arguments.length;
            const v14930 = !v14929;
            if (v14930) {
                const v14931 = this.$$state;
                return v14931;
            }
            const v14932 = Location !== LocationHtml5Url;
            const v14933 = this.$$html5;
            const v14934 = !v14933;
            const v14935 = v14932 || v14934;
            if (v14935) {
                const v14936 = 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API';
                const v14937 = $locationMinErr('nostate', v14936);
                throw v14937;
            }
            const v14938 = isUndefined(state);
            let v14939;
            if (v14938) {
                v14939 = null;
            } else {
                v14939 = state;
            }
            this.$$state = v14939;
            this.$$urlUpdatedByLocation = true;
            return this;
        };
        v14928.state = v14940;
    };
    const v14942 = forEach(v14926, v14941);
    v14942;
    const locationGetter = function (property) {
        const v14944 = function () {
            const v14943 = this[property];
            return v14943;
        };
        return v14944;
    };
    const locationGetterSetter = function (property, preprocess) {
        const v14949 = function (value) {
            const v14945 = isUndefined(value);
            if (v14945) {
                const v14946 = this[property];
                return v14946;
            }
            const v14947 = preprocess(value);
            this[property] = v14947;
            const v14948 = this.$$compose();
            v14948;
            return this;
        };
        return v14949;
    };
    const $LocationProvider = function () {
        var hashPrefix = '!';
        var html5Mode = {};
        html5Mode.enabled = false;
        html5Mode.requireBase = true;
        html5Mode.rewriteLinks = true;
        const v14951 = function (prefix) {
            const v14950 = isDefined(prefix);
            if (v14950) {
                hashPrefix = prefix;
                return this;
            } else {
                return hashPrefix;
            }
        };
        this.hashPrefix = v14951;
        const v14966 = function (mode) {
            const v14952 = isBoolean(mode);
            if (v14952) {
                html5Mode.enabled = mode;
                return this;
            } else {
                const v14953 = isObject(mode);
                if (v14953) {
                    const v14954 = mode.enabled;
                    const v14955 = isBoolean(v14954);
                    if (v14955) {
                        const v14956 = mode.enabled;
                        html5Mode.enabled = v14956;
                    }
                    const v14957 = mode.requireBase;
                    const v14958 = isBoolean(v14957);
                    if (v14958) {
                        const v14959 = mode.requireBase;
                        html5Mode.requireBase = v14959;
                    }
                    const v14960 = mode.rewriteLinks;
                    const v14961 = isBoolean(v14960);
                    const v14962 = mode.rewriteLinks;
                    const v14963 = isString(v14962);
                    const v14964 = v14961 || v14963;
                    if (v14964) {
                        const v14965 = mode.rewriteLinks;
                        html5Mode.rewriteLinks = v14965;
                    }
                    return this;
                } else {
                    return html5Mode;
                }
            }
        };
        this.html5Mode = v14966;
        const v15088 = function ($rootScope, $browser, $sniffer, $rootElement, $window) {
            var $location;
            var LocationMode;
            var baseHref = $browser.baseHref();
            var initialUrl = $browser.url();
            var appBase;
            const v14967 = html5Mode.enabled;
            if (v14967) {
                const v14968 = !baseHref;
                const v14969 = html5Mode.requireBase;
                const v14970 = v14968 && v14969;
                if (v14970) {
                    const v14971 = $locationMinErr('nobase', '$location in HTML5 mode requires a <base> tag to be present!');
                    throw v14971;
                }
                const v14972 = serverBase(initialUrl);
                const v14973 = baseHref || '/';
                appBase = v14972 + v14973;
                const v14974 = $sniffer.history;
                if (v14974) {
                    LocationMode = LocationHtml5Url;
                } else {
                    LocationMode = LocationHashbangInHtml5Url;
                }
            } else {
                appBase = stripHash(initialUrl);
                LocationMode = LocationHashbangUrl;
            }
            var appBaseNoFile = stripFile(appBase);
            const v14975 = '#' + hashPrefix;
            $location = new LocationMode(appBase, appBaseNoFile, v14975);
            const v14976 = $location.$$parseLinkUrl(initialUrl, initialUrl);
            v14976;
            const v14977 = $browser.state();
            $location.$$state = v14977;
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            const urlsEqual = function (a, b) {
                const v14978 = a === b;
                const v14979 = urlResolve(a);
                const v14980 = v14979.href;
                const v14981 = urlResolve(b);
                const v14982 = v14981.href;
                const v14983 = v14980 === v14982;
                const v14984 = v14978 || v14983;
                return v14984;
            };
            const setBrowserUrlWithFallback = function (url, replace, state) {
                var oldUrl = $location.url();
                var oldState = $location.$$state;
                try {
                    const v14985 = $browser.url(url, replace, state);
                    v14985;
                    const v14986 = $browser.state();
                    $location.$$state = v14986;
                } catch (e) {
                    const v14987 = $location.url(oldUrl);
                    v14987;
                    $location.$$state = oldState;
                    throw e;
                }
            };
            const v15036 = function (event) {
                var rewriteLinks = html5Mode.rewriteLinks;
                const v14988 = !rewriteLinks;
                const v14989 = event.ctrlKey;
                const v14990 = v14988 || v14989;
                const v14991 = event.metaKey;
                const v14992 = v14990 || v14991;
                const v14993 = event.shiftKey;
                const v14994 = v14992 || v14993;
                const v14995 = event.which;
                const v14996 = v14995 === 2;
                const v14997 = v14994 || v14996;
                const v14998 = event.button;
                const v14999 = v14998 === 2;
                const v15000 = v14997 || v14999;
                if (v15000) {
                    return;
                }
                const v15001 = event.target;
                var elm = jqLite(v15001);
                const v15002 = elm[0];
                const v15003 = nodeName_(v15002);
                let v15004 = v15003 !== 'a';
                while (v15004) {
                    const v15005 = elm[0];
                    const v15006 = $rootElement[0];
                    const v15007 = v15005 === v15006;
                    const v15008 = (elm = elm.parent())[0];
                    const v15009 = !v15008;
                    const v15010 = v15007 || v15009;
                    if (v15010) {
                        return;
                    }
                    v15004 = v15003 !== 'a';
                }
                const v15011 = isString(rewriteLinks);
                const v15012 = elm.attr(rewriteLinks);
                const v15013 = isUndefined(v15012);
                const v15014 = v15011 && v15013;
                if (v15014) {
                    return;
                }
                var absHref = elm.prop('href');
                const v15015 = elm.attr('href');
                const v15016 = elm.attr('xlink:href');
                var relHref = v15015 || v15016;
                const v15017 = isObject(absHref);
                const v15018 = absHref.toString();
                const v15019 = v15018 === '[object SVGAnimatedString]';
                const v15020 = v15017 && v15019;
                if (v15020) {
                    const v15021 = absHref.animVal;
                    const v15022 = urlResolve(v15021);
                    absHref = v15022.href;
                }
                const v15023 = IGNORE_URI_REGEXP.test(absHref);
                if (v15023) {
                    return;
                }
                const v15024 = elm.attr('target');
                const v15025 = !v15024;
                const v15026 = absHref && v15025;
                const v15027 = event.isDefaultPrevented();
                const v15028 = !v15027;
                const v15029 = v15026 && v15028;
                if (v15029) {
                    const v15030 = $location.$$parseLinkUrl(absHref, relHref);
                    if (v15030) {
                        const v15031 = event.preventDefault();
                        v15031;
                        const v15032 = $location.absUrl();
                        const v15033 = $browser.url();
                        const v15034 = v15032 !== v15033;
                        if (v15034) {
                            const v15035 = $rootScope.$apply();
                            v15035;
                        }
                    }
                }
            };
            const v15037 = $rootElement.on('click', v15036);
            v15037;
            const v15038 = $location.absUrl();
            const v15039 = v15038 !== initialUrl;
            if (v15039) {
                const v15040 = $location.absUrl();
                const v15041 = $browser.url(v15040, true);
                v15041;
            }
            var initializing = true;
            const v15057 = function (newUrl, newState) {
                const v15042 = startsWith(newUrl, appBaseNoFile);
                const v15043 = !v15042;
                if (v15043) {
                    const v15044 = $window.location;
                    v15044.href = newUrl;
                    return;
                }
                const v15052 = function () {
                    var oldUrl = $location.absUrl();
                    var oldState = $location.$$state;
                    var defaultPrevented;
                    const v15045 = $location.$$parse(newUrl);
                    v15045;
                    $location.$$state = newState;
                    const v15046 = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState);
                    defaultPrevented = v15046.defaultPrevented;
                    const v15047 = $location.absUrl();
                    const v15048 = v15047 !== newUrl;
                    if (v15048) {
                        return;
                    }
                    if (defaultPrevented) {
                        const v15049 = $location.$$parse(oldUrl);
                        v15049;
                        $location.$$state = oldState;
                        const v15050 = setBrowserUrlWithFallback(oldUrl, false, oldState);
                        v15050;
                    } else {
                        initializing = false;
                        const v15051 = afterLocationChange(oldUrl, oldState);
                        v15051;
                    }
                };
                const v15053 = $rootScope.$evalAsync(v15052);
                v15053;
                const v15054 = $rootScope.$$phase;
                const v15055 = !v15054;
                if (v15055) {
                    const v15056 = $rootScope.$digest();
                    v15056;
                }
            };
            const v15058 = $browser.onUrlChange(v15057);
            v15058;
            const v15083 = function $locationWatch() {
                const v15059 = $location.$$urlUpdatedByLocation;
                const v15060 = initializing || v15059;
                if (v15060) {
                    $location.$$urlUpdatedByLocation = false;
                    var oldUrl = $browser.url();
                    var newUrl = $location.absUrl();
                    var oldState = $browser.state();
                    var currentReplace = $location.$$replace;
                    const v15061 = urlsEqual(oldUrl, newUrl);
                    const v15062 = !v15061;
                    const v15063 = $location.$$html5;
                    const v15064 = $sniffer.history;
                    const v15065 = v15063 && v15064;
                    const v15066 = $location.$$state;
                    const v15067 = oldState !== v15066;
                    const v15068 = v15065 && v15067;
                    var urlOrStateChanged = v15062 || v15068;
                    const v15069 = initializing || urlOrStateChanged;
                    if (v15069) {
                        initializing = false;
                        const v15081 = function () {
                            var newUrl = $location.absUrl();
                            const v15070 = $location.$$state;
                            const v15071 = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, v15070, oldState);
                            var defaultPrevented = v15071.defaultPrevented;
                            const v15072 = $location.absUrl();
                            const v15073 = v15072 !== newUrl;
                            if (v15073) {
                                return;
                            }
                            if (defaultPrevented) {
                                const v15074 = $location.$$parse(oldUrl);
                                v15074;
                                $location.$$state = oldState;
                            } else {
                                if (urlOrStateChanged) {
                                    const v15075 = $location.$$state;
                                    const v15076 = oldState === v15075;
                                    const v15077 = $location.$$state;
                                    let v15078;
                                    if (v15076) {
                                        v15078 = null;
                                    } else {
                                        v15078 = v15077;
                                    }
                                    const v15079 = setBrowserUrlWithFallback(newUrl, currentReplace, v15078);
                                    v15079;
                                }
                                const v15080 = afterLocationChange(oldUrl, oldState);
                                v15080;
                            }
                        };
                        const v15082 = $rootScope.$evalAsync(v15081);
                        v15082;
                    }
                }
                $location.$$replace = false;
            };
            const v15084 = $rootScope.$watch(v15083);
            v15084;
            return $location;
            const afterLocationChange = function (oldUrl, oldState) {
                const v15085 = $location.absUrl();
                const v15086 = $location.$$state;
                const v15087 = $rootScope.$broadcast('$locationChangeSuccess', v15085, oldUrl, v15086, oldState);
                v15087;
            };
        };
        this.$get = [
            '$rootScope',
            '$browser',
            '$sniffer',
            '$rootElement',
            '$window',
            v15088
        ];
    };
    const $LogProvider = function () {
        var debug = true;
        var self = this;
        const v15090 = function (flag) {
            const v15089 = isDefined(flag);
            if (v15089) {
                debug = flag;
                return this;
            } else {
                return debug;
            }
        };
        this.debugEnabled = v15090;
        const v15141 = function ($window) {
            const v15091 = $window.navigator;
            const v15092 = $window.navigator;
            const v15093 = v15092.userAgent;
            const v15094 = v15091 && v15093;
            const v15095 = /\bEdge\//.test(v15094);
            var formatStackTrace = msie || v15095;
            const v15096 = consoleLog('log');
            const v15097 = consoleLog('info');
            const v15098 = consoleLog('warn');
            const v15099 = consoleLog('error');
            const v15102 = function () {
                var fn = consoleLog('debug');
                const v15101 = function () {
                    if (debug) {
                        const v15100 = fn.apply(self, arguments);
                        v15100;
                    }
                };
                return v15101;
            };
            const v15103 = v15102();
            const v15104 = {};
            v15104.log = v15096;
            v15104.info = v15097;
            v15104.warn = v15098;
            v15104.error = v15099;
            v15104.debug = v15103;
            return v15104;
            const formatError = function (arg) {
                const v15105 = isError(arg);
                if (v15105) {
                    const v15106 = arg.stack;
                    const v15107 = v15106 && formatStackTrace;
                    if (v15107) {
                        const v15108 = arg.message;
                        const v15109 = arg.stack;
                        const v15110 = arg.message;
                        const v15111 = v15109.indexOf(v15110);
                        const v15112 = -1;
                        const v15113 = v15111 === v15112;
                        const v15114 = v15108 && v15113;
                        const v15115 = arg.message;
                        const v15116 = 'Error: ' + v15115;
                        const v15117 = v15116 + '\n';
                        const v15118 = arg.stack;
                        const v15119 = v15117 + v15118;
                        const v15120 = arg.stack;
                        if (v15114) {
                            arg = v15119;
                        } else {
                            arg = v15120;
                        }
                    } else {
                        const v15121 = arg.sourceURL;
                        if (v15121) {
                            const v15122 = arg.message;
                            const v15123 = v15122 + '\n';
                            const v15124 = arg.sourceURL;
                            const v15125 = v15123 + v15124;
                            const v15126 = v15125 + ':';
                            const v15127 = arg.line;
                            arg = v15126 + v15127;
                        }
                    }
                }
                return arg;
            };
            const consoleLog = function (type) {
                const v15128 = $window.console;
                const v15129 = {};
                var console = v15128 || v15129;
                const v15130 = console[type];
                const v15131 = console.log;
                const v15132 = v15130 || v15131;
                var logFn = v15132 || noop;
                const v15140 = function () {
                    var args = [];
                    const v15135 = function (arg) {
                        const v15133 = formatError(arg);
                        const v15134 = args.push(v15133);
                        v15134;
                    };
                    const v15136 = forEach(arguments, v15135);
                    v15136;
                    const v15137 = Function.prototype;
                    const v15138 = v15137.apply;
                    const v15139 = v15138.call(logFn, console, args);
                    return v15139;
                };
                return v15140;
            };
        };
        this.$get = [
            '$window',
            v15141
        ];
    };
    var $parseMinErr = minErr('$parse');
    const v15142 = {};
    const v15143 = v15142.constructor;
    const v15144 = v15143.prototype;
    var objectValueOf = v15144.valueOf;
    const getStringValue = function (name) {
        const v15145 = name + '';
        return v15145;
    };
    var OPERATORS = createMap();
    const v15146 = '+ - * / % === !== == != < > <= >= && || ! = |'.split(' ');
    const v15147 = function (operator) {
        OPERATORS[operator] = true;
    };
    const v15148 = forEach(v15146, v15147);
    v15148;
    var ESCAPE = {};
    ESCAPE['n'] = '\n';
    ESCAPE['f'] = '\f';
    ESCAPE['r'] = '\r';
    ESCAPE['t'] = '\t';
    ESCAPE['v'] = '\x0B';
    ESCAPE['\''] = '\'';
    ESCAPE['"'] = '"';
    var Lexer = function Lexer(options) {
        this.options = options;
    };
    const v15194 = function (text) {
        this.text = text;
        this.index = 0;
        this.tokens = [];
        const v15149 = this.index;
        const v15150 = this.text;
        const v15151 = v15150.length;
        let v15152 = v15149 < v15151;
        while (v15152) {
            const v15153 = this.text;
            const v15154 = this.index;
            var ch = v15153.charAt(v15154);
            const v15155 = ch === '"';
            const v15156 = ch === '\'';
            const v15157 = v15155 || v15156;
            if (v15157) {
                const v15158 = this.readString(ch);
                v15158;
            } else {
                const v15159 = this.isNumber(ch);
                const v15160 = ch === '.';
                const v15161 = this.peek();
                const v15162 = this.isNumber(v15161);
                const v15163 = v15160 && v15162;
                const v15164 = v15159 || v15163;
                if (v15164) {
                    const v15165 = this.readNumber();
                    v15165;
                } else {
                    const v15166 = this.peekMultichar();
                    const v15167 = this.isIdentifierStart(v15166);
                    if (v15167) {
                        const v15168 = this.readIdent();
                        v15168;
                    } else {
                        const v15169 = this.is(ch, '(){}[].,;:?');
                        if (v15169) {
                            const v15170 = this.tokens;
                            const v15171 = this.index;
                            const v15172 = {
                                index: v15171,
                                text: ch
                            };
                            const v15173 = v15170.push(v15172);
                            v15173;
                            const v15174 = this.index;
                            const v15175 = v15174++;
                            v15175;
                        } else {
                            const v15176 = this.isWhitespace(ch);
                            if (v15176) {
                                const v15177 = this.index;
                                const v15178 = v15177++;
                                v15178;
                            } else {
                                const v15179 = this.peek();
                                var ch2 = ch + v15179;
                                const v15180 = this.peek(2);
                                var ch3 = ch2 + v15180;
                                var op1 = OPERATORS[ch];
                                var op2 = OPERATORS[ch2];
                                var op3 = OPERATORS[ch3];
                                const v15181 = op1 || op2;
                                const v15182 = v15181 || op3;
                                if (v15182) {
                                    let token;
                                    let v15183;
                                    if (op2) {
                                        v15183 = ch2;
                                    } else {
                                        v15183 = ch;
                                    }
                                    if (op3) {
                                        token = ch3;
                                    } else {
                                        token = v15183;
                                    }
                                    const v15184 = this.tokens;
                                    const v15185 = this.index;
                                    const v15186 = {
                                        index: v15185,
                                        text: token,
                                        operator: true
                                    };
                                    const v15187 = v15184.push(v15186);
                                    v15187;
                                    const v15188 = token.length;
                                    this.index += v15188;
                                } else {
                                    const v15189 = this.index;
                                    const v15190 = this.index;
                                    const v15191 = v15190 + 1;
                                    const v15192 = this.throwError('Unexpected next character ', v15189, v15191);
                                    v15192;
                                }
                            }
                        }
                    }
                }
            }
            v15152 = v15149 < v15151;
        }
        const v15193 = this.tokens;
        return v15193;
    };
    const v15198 = function (ch, chars) {
        const v15195 = chars.indexOf(ch);
        const v15196 = -1;
        const v15197 = v15195 !== v15196;
        return v15197;
    };
    const v15209 = function (i) {
        var num = i || 1;
        const v15199 = this.index;
        const v15200 = v15199 + num;
        const v15201 = this.text;
        const v15202 = v15201.length;
        const v15203 = v15200 < v15202;
        const v15204 = this.text;
        const v15205 = this.index;
        const v15206 = v15205 + num;
        const v15207 = v15204.charAt(v15206);
        let v15208;
        if (v15203) {
            v15208 = v15207;
        } else {
            v15208 = false;
        }
        return v15208;
    };
    const v15216 = function (ch) {
        const v15210 = '0' <= ch;
        const v15211 = ch <= '9';
        const v15212 = v15210 && v15211;
        const v15213 = typeof ch;
        const v15214 = v15213 === 'string';
        const v15215 = v15212 && v15214;
        return v15215;
    };
    const v15228 = function (ch) {
        const v15217 = ch === ' ';
        const v15218 = ch === '\r';
        const v15219 = v15217 || v15218;
        const v15220 = ch === '\t';
        const v15221 = v15219 || v15220;
        const v15222 = ch === '\n';
        const v15223 = v15221 || v15222;
        const v15224 = ch === '\x0B';
        const v15225 = v15223 || v15224;
        const v15226 = ch === '\xA0';
        const v15227 = v15225 || v15226;
        return v15227;
    };
    const v15236 = function (ch) {
        const v15229 = this.options;
        const v15230 = v15229.isIdentifierStart;
        const v15231 = this.options;
        const v15232 = this.codePointAt(ch);
        const v15233 = v15231.isIdentifierStart(ch, v15232);
        const v15234 = this.isValidIdentifierStart(ch);
        let v15235;
        if (v15230) {
            v15235 = v15233;
        } else {
            v15235 = v15234;
        }
        return v15235;
    };
    const v15248 = function (ch) {
        const v15237 = 'a' <= ch;
        const v15238 = ch <= 'z';
        const v15239 = v15237 && v15238;
        const v15240 = 'A' <= ch;
        const v15241 = ch <= 'Z';
        const v15242 = v15240 && v15241;
        const v15243 = v15239 || v15242;
        const v15244 = '_' === ch;
        const v15245 = v15243 || v15244;
        const v15246 = ch === '$';
        const v15247 = v15245 || v15246;
        return v15247;
    };
    const v15256 = function (ch) {
        const v15249 = this.options;
        const v15250 = v15249.isIdentifierContinue;
        const v15251 = this.options;
        const v15252 = this.codePointAt(ch);
        const v15253 = v15251.isIdentifierContinue(ch, v15252);
        const v15254 = this.isValidIdentifierContinue(ch);
        let v15255;
        if (v15250) {
            v15255 = v15253;
        } else {
            v15255 = v15254;
        }
        return v15255;
    };
    const v15260 = function (ch, cp) {
        const v15257 = this.isValidIdentifierStart(ch, cp);
        const v15258 = this.isNumber(ch);
        const v15259 = v15257 || v15258;
        return v15259;
    };
    const v15269 = function (ch) {
        const v15261 = ch.length;
        const v15262 = v15261 === 1;
        if (v15262) {
            const v15263 = ch.charCodeAt(0);
            return v15263;
        }
        const v15264 = ch.charCodeAt(0);
        const v15265 = v15264 << 10;
        const v15266 = ch.charCodeAt(1);
        const v15267 = v15265 + v15266;
        const v15268 = v15267 - 56613888;
        return v15268;
    };
    const v15281 = function () {
        const v15270 = this.text;
        const v15271 = this.index;
        var ch = v15270.charAt(v15271);
        var peek = this.peek();
        const v15272 = !peek;
        if (v15272) {
            return ch;
        }
        var cp1 = ch.charCodeAt(0);
        var cp2 = peek.charCodeAt(0);
        const v15273 = cp1 >= 55296;
        const v15274 = cp1 <= 56319;
        const v15275 = v15273 && v15274;
        const v15276 = cp2 >= 56320;
        const v15277 = v15275 && v15276;
        const v15278 = cp2 <= 57343;
        const v15279 = v15277 && v15278;
        if (v15279) {
            const v15280 = ch + peek;
            return v15280;
        }
        return ch;
    };
    const v15287 = function (ch) {
        const v15282 = ch === '-';
        const v15283 = ch === '+';
        const v15284 = v15282 || v15283;
        const v15285 = this.isNumber(ch);
        const v15286 = v15284 || v15285;
        return v15286;
    };
    const v15302 = function (error, start, end) {
        const v15288 = this.index;
        end = end || v15288;
        let colStr;
        const v15289 = isDefined(start);
        const v15290 = 's ' + start;
        const v15291 = v15290 + '-';
        const v15292 = this.index;
        const v15293 = v15291 + v15292;
        const v15294 = v15293 + ' [';
        const v15295 = this.text;
        const v15296 = v15295.substring(start, end);
        const v15297 = v15294 + v15296;
        const v15298 = v15297 + ']';
        const v15299 = ' ' + end;
        if (v15289) {
            colStr = v15298;
        } else {
            colStr = v15299;
        }
        const v15300 = this.text;
        const v15301 = $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, v15300);
        throw v15301;
    };
    const v15343 = function () {
        var number = '';
        var start = this.index;
        const v15303 = this.index;
        const v15304 = this.text;
        const v15305 = v15304.length;
        let v15306 = v15303 < v15305;
        while (v15306) {
            const v15307 = this.text;
            const v15308 = this.index;
            const v15309 = v15307.charAt(v15308);
            var ch = lowercase(v15309);
            const v15310 = ch === '.';
            const v15311 = this.isNumber(ch);
            const v15312 = v15310 || v15311;
            if (v15312) {
                number += ch;
            } else {
                var peekCh = this.peek();
                const v15313 = ch === 'e';
                const v15314 = this.isExpOperator(peekCh);
                const v15315 = v15313 && v15314;
                if (v15315) {
                    number += ch;
                } else {
                    const v15316 = this.isExpOperator(ch);
                    const v15317 = v15316 && peekCh;
                    const v15318 = this.isNumber(peekCh);
                    const v15319 = v15317 && v15318;
                    const v15320 = number.length;
                    const v15321 = v15320 - 1;
                    const v15322 = number.charAt(v15321);
                    const v15323 = v15322 === 'e';
                    const v15324 = v15319 && v15323;
                    if (v15324) {
                        number += ch;
                    } else {
                        const v15325 = this.isExpOperator(ch);
                        const v15326 = !peekCh;
                        const v15327 = this.isNumber(peekCh);
                        const v15328 = !v15327;
                        const v15329 = v15326 || v15328;
                        const v15330 = v15325 && v15329;
                        const v15331 = number.length;
                        const v15332 = v15331 - 1;
                        const v15333 = number.charAt(v15332);
                        const v15334 = v15333 === 'e';
                        const v15335 = v15330 && v15334;
                        if (v15335) {
                            const v15336 = this.throwError('Invalid exponent');
                            v15336;
                        } else {
                            break;
                        }
                    }
                }
            }
            const v15337 = this.index;
            const v15338 = v15337++;
            v15338;
            v15306 = v15303 < v15305;
        }
        const v15339 = this.tokens;
        const v15340 = Number(number);
        const v15341 = {
            index: start,
            text: number,
            constant: true,
            value: v15340
        };
        const v15342 = v15339.push(v15341);
        v15342;
    };
    const v15359 = function () {
        var start = this.index;
        const v15344 = this.peekMultichar();
        const v15345 = v15344.length;
        this.index += v15345;
        const v15346 = this.index;
        const v15347 = this.text;
        const v15348 = v15347.length;
        let v15349 = v15346 < v15348;
        while (v15349) {
            var ch = this.peekMultichar();
            const v15350 = this.isIdentifierContinue(ch);
            const v15351 = !v15350;
            if (v15351) {
                break;
            }
            const v15352 = ch.length;
            this.index += v15352;
            v15349 = v15346 < v15348;
        }
        const v15353 = this.tokens;
        const v15354 = this.text;
        const v15355 = this.index;
        const v15356 = v15354.slice(start, v15355);
        const v15357 = {
            index: start,
            text: v15356,
            identifier: true
        };
        const v15358 = v15353.push(v15357);
        v15358;
    };
    const v15391 = function (quote) {
        var start = this.index;
        const v15360 = this.index;
        const v15361 = v15360++;
        v15361;
        var string = '';
        var rawString = quote;
        var escape = false;
        const v15362 = this.index;
        const v15363 = this.text;
        const v15364 = v15363.length;
        let v15365 = v15362 < v15364;
        while (v15365) {
            const v15366 = this.text;
            const v15367 = this.index;
            var ch = v15366.charAt(v15367);
            rawString += ch;
            if (escape) {
                const v15368 = ch === 'u';
                if (v15368) {
                    const v15369 = this.text;
                    const v15370 = this.index;
                    const v15371 = v15370 + 1;
                    const v15372 = this.index;
                    const v15373 = v15372 + 5;
                    var hex = v15369.substring(v15371, v15373);
                    const v15374 = hex.match(/[\da-f]{4}/i);
                    const v15375 = !v15374;
                    if (v15375) {
                        const v15376 = 'Invalid unicode escape [\\u' + hex;
                        const v15377 = v15376 + ']';
                        const v15378 = this.throwError(v15377);
                        v15378;
                    }
                    this.index += 4;
                    const v15379 = parseInt(hex, 16);
                    string += String.fromCharCode(v15379);
                } else {
                    var rep = ESCAPE[ch];
                    const v15380 = rep || ch;
                    string = string + v15380;
                }
                escape = false;
            } else {
                const v15381 = ch === '\\';
                if (v15381) {
                    escape = true;
                } else {
                    const v15382 = ch === quote;
                    if (v15382) {
                        const v15383 = this.index;
                        const v15384 = v15383++;
                        v15384;
                        const v15385 = this.tokens;
                        const v15386 = {
                            index: start,
                            text: rawString,
                            constant: true,
                            value: string
                        };
                        const v15387 = v15385.push(v15386);
                        v15387;
                        return;
                    } else {
                        string += ch;
                    }
                }
            }
            const v15388 = this.index;
            const v15389 = v15388++;
            v15389;
            v15365 = v15362 < v15364;
        }
        const v15390 = this.throwError('Unterminated quote', start);
        v15390;
    };
    const v15392 = {};
    v15392.constructor = Lexer;
    v15392.lex = v15194;
    v15392.is = v15198;
    v15392.peek = v15209;
    v15392.isNumber = v15216;
    v15392.isWhitespace = v15228;
    v15392.isIdentifierStart = v15236;
    v15392.isValidIdentifierStart = v15248;
    v15392.isIdentifierContinue = v15256;
    v15392.isValidIdentifierContinue = v15260;
    v15392.codePointAt = v15269;
    v15392.peekMultichar = v15281;
    v15392.isExpOperator = v15287;
    v15392.throwError = v15302;
    v15392.readNumber = v15343;
    v15392.readIdent = v15359;
    v15392.readString = v15391;
    Lexer.prototype = v15392;
    var AST = function AST(lexer, options) {
        this.lexer = lexer;
        this.options = options;
    };
    AST.Program = 'Program';
    AST.ExpressionStatement = 'ExpressionStatement';
    AST.AssignmentExpression = 'AssignmentExpression';
    AST.ConditionalExpression = 'ConditionalExpression';
    AST.LogicalExpression = 'LogicalExpression';
    AST.BinaryExpression = 'BinaryExpression';
    AST.UnaryExpression = 'UnaryExpression';
    AST.CallExpression = 'CallExpression';
    AST.MemberExpression = 'MemberExpression';
    AST.Identifier = 'Identifier';
    AST.Literal = 'Literal';
    AST.ArrayExpression = 'ArrayExpression';
    AST.Property = 'Property';
    AST.ObjectExpression = 'ObjectExpression';
    AST.ThisExpression = 'ThisExpression';
    AST.LocalsExpression = 'LocalsExpression';
    AST.NGValueParameter = 'NGValueParameter';
    const v15401 = function (text) {
        this.text = text;
        const v15393 = this.lexer;
        const v15394 = v15393.lex(text);
        this.tokens = v15394;
        var value = this.program();
        const v15395 = this.tokens;
        const v15396 = v15395.length;
        const v15397 = v15396 !== 0;
        if (v15397) {
            const v15398 = this.tokens;
            const v15399 = v15398[0];
            const v15400 = this.throwError('is an unexpected token', v15399);
            v15400;
        }
        return value;
    };
    const v15414 = function () {
        var body = [];
        while (true) {
            const v15402 = this.tokens;
            const v15403 = v15402.length;
            const v15404 = v15403 > 0;
            const v15405 = this.peek('}', ')', ';', ']');
            const v15406 = !v15405;
            const v15407 = v15404 && v15406;
            if (v15407) {
                const v15408 = this.expressionStatement();
                const v15409 = body.push(v15408);
                v15409;
            }
            const v15410 = this.expect(';');
            const v15411 = !v15410;
            if (v15411) {
                const v15412 = AST.Program;
                const v15413 = {};
                v15413.type = v15412;
                v15413.body = body;
                return v15413;
            }
        }
    };
    const v15418 = function () {
        const v15415 = AST.ExpressionStatement;
        const v15416 = this.filterChain();
        const v15417 = {};
        v15417.type = v15415;
        v15417.expression = v15416;
        return v15417;
    };
    const v15420 = function () {
        var left = this.expression();
        let v15419 = this.expect('|');
        while (v15419) {
            left = this.filter(left);
            v15419 = this.expect('|');
        }
        return left;
    };
    const v15422 = function () {
        const v15421 = this.assignment();
        return v15421;
    };
    const v15429 = function () {
        var result = this.ternary();
        const v15423 = this.expect('=');
        if (v15423) {
            const v15424 = isAssignable(result);
            const v15425 = !v15424;
            if (v15425) {
                const v15426 = $parseMinErr('lval', 'Trying to assign a value to a non l-value');
                throw v15426;
            }
            const v15427 = AST.AssignmentExpression;
            const v15428 = this.assignment();
            result.type = v15427;
            result.left = result;
            result.right = v15428;
            result.operator = '=';
            result = {};
            result = {};
        }
        return result;
    };
    const v15434 = function () {
        var test = this.logicalOR();
        var alternate;
        var consequent;
        const v15430 = this.expect('?');
        if (v15430) {
            alternate = this.expression();
            const v15431 = this.consume(':');
            if (v15431) {
                consequent = this.expression();
                const v15432 = AST.ConditionalExpression;
                const v15433 = {};
                v15433.type = v15432;
                v15433.test = test;
                v15433.alternate = alternate;
                v15433.consequent = consequent;
                return v15433;
            }
        }
        return test;
    };
    const v15438 = function () {
        var left = this.logicalAND();
        let v15435 = this.expect('||');
        while (v15435) {
            const v15436 = AST.LogicalExpression;
            const v15437 = this.logicalAND();
            left.type = v15436;
            left.operator = '||';
            left.left = left;
            left.right = v15437;
            left = {};
            left = {};
            v15435 = this.expect('||');
        }
        return left;
    };
    const v15442 = function () {
        var left = this.equality();
        let v15439 = this.expect('&&');
        while (v15439) {
            const v15440 = AST.LogicalExpression;
            const v15441 = this.equality();
            left.type = v15440;
            left.operator = '&&';
            left.left = left;
            left.right = v15441;
            left = {};
            left = {};
            v15439 = this.expect('&&');
        }
        return left;
    };
    const v15446 = function () {
        var left = this.relational();
        var token;
        while (token = this.expect('==', '!=', '===', '!==')) {
            const v15443 = AST.BinaryExpression;
            const v15444 = token.text;
            const v15445 = this.relational();
            left.type = v15443;
            left.operator = v15444;
            left.left = left;
            left.right = v15445;
            left = {};
            left = {};
        }
        return left;
    };
    const v15450 = function () {
        var left = this.additive();
        var token;
        while (token = this.expect('<', '>', '<=', '>=')) {
            const v15447 = AST.BinaryExpression;
            const v15448 = token.text;
            const v15449 = this.additive();
            left.type = v15447;
            left.operator = v15448;
            left.left = left;
            left.right = v15449;
            left = {};
            left = {};
        }
        return left;
    };
    const v15454 = function () {
        var left = this.multiplicative();
        var token;
        while (token = this.expect('+', '-')) {
            const v15451 = AST.BinaryExpression;
            const v15452 = token.text;
            const v15453 = this.multiplicative();
            left.type = v15451;
            left.operator = v15452;
            left.left = left;
            left.right = v15453;
            left = {};
            left = {};
        }
        return left;
    };
    const v15458 = function () {
        var left = this.unary();
        var token;
        while (token = this.expect('*', '/', '%')) {
            const v15455 = AST.BinaryExpression;
            const v15456 = token.text;
            const v15457 = this.unary();
            left.type = v15455;
            left.operator = v15456;
            left.left = left;
            left.right = v15457;
            left = {};
            left = {};
        }
        return left;
    };
    const v15464 = function () {
        var token;
        if (token = this.expect('+', '-', '!')) {
            const v15459 = AST.UnaryExpression;
            const v15460 = token.text;
            const v15461 = this.unary();
            const v15462 = {};
            v15462.type = v15459;
            v15462.operator = v15460;
            v15462.prefix = true;
            v15462.argument = v15461;
            return v15462;
        } else {
            const v15463 = this.primary();
            return v15463;
        }
    };
    const v15509 = function () {
        var primary;
        const v15465 = this.expect('(');
        if (v15465) {
            primary = this.filterChain();
            const v15466 = this.consume(')');
            v15466;
        } else {
            const v15467 = this.expect('[');
            if (v15467) {
                primary = this.arrayDeclaration();
            } else {
                const v15468 = this.expect('{');
                if (v15468) {
                    primary = this.object();
                } else {
                    const v15469 = this.selfReferential;
                    const v15470 = this.peek();
                    const v15471 = v15470.text;
                    const v15472 = v15469.hasOwnProperty(v15471);
                    if (v15472) {
                        const v15473 = this.selfReferential;
                        const v15474 = this.consume();
                        const v15475 = v15474.text;
                        const v15476 = v15473[v15475];
                        primary = copy(v15476);
                    } else {
                        const v15477 = this.options;
                        const v15478 = v15477.literals;
                        const v15479 = this.peek();
                        const v15480 = v15479.text;
                        const v15481 = v15478.hasOwnProperty(v15480);
                        if (v15481) {
                            const v15482 = AST.Literal;
                            const v15483 = this.options;
                            const v15484 = v15483.literals;
                            const v15485 = this.consume();
                            const v15486 = v15485.text;
                            const v15487 = v15484[v15486];
                            primary.type = v15482;
                            primary.value = v15487;
                            primary = {};
                            primary = {};
                        } else {
                            const v15488 = this.peek();
                            const v15489 = v15488.identifier;
                            if (v15489) {
                                primary = this.identifier();
                            } else {
                                const v15490 = this.peek();
                                const v15491 = v15490.constant;
                                if (v15491) {
                                    primary = this.constant();
                                } else {
                                    const v15492 = this.peek();
                                    const v15493 = this.throwError('not a primary expression', v15492);
                                    v15493;
                                }
                            }
                        }
                    }
                }
            }
        }
        var next;
        while (next = this.expect('(', '[', '.')) {
            const v15494 = next.text;
            const v15495 = v15494 === '(';
            if (v15495) {
                const v15496 = AST.CallExpression;
                const v15497 = this.parseArguments();
                primary.type = v15496;
                primary.callee = primary;
                primary.arguments = v15497;
                primary = {};
                primary = {};
                const v15498 = this.consume(')');
                v15498;
            } else {
                const v15499 = next.text;
                const v15500 = v15499 === '[';
                if (v15500) {
                    const v15501 = AST.MemberExpression;
                    const v15502 = this.expression();
                    primary.type = v15501;
                    primary.object = primary;
                    primary.property = v15502;
                    primary.computed = true;
                    primary = {};
                    primary = {};
                    const v15503 = this.consume(']');
                    v15503;
                } else {
                    const v15504 = next.text;
                    const v15505 = v15504 === '.';
                    if (v15505) {
                        const v15506 = AST.MemberExpression;
                        const v15507 = this.identifier();
                        primary.type = v15506;
                        primary.object = primary;
                        primary.property = v15507;
                        primary.computed = false;
                        primary = {};
                        primary = {};
                    } else {
                        const v15508 = this.throwError('IMPOSSIBLE');
                        v15508;
                    }
                }
            }
        }
        return primary;
    };
    const v15515 = function (baseExpression) {
        var args = [baseExpression];
        const v15510 = AST.CallExpression;
        const v15511 = this.identifier();
        var result = {};
        result.type = v15510;
        result.callee = v15511;
        result.arguments = args;
        result.filter = true;
        let v15512 = this.expect(':');
        while (v15512) {
            const v15513 = this.expression();
            const v15514 = args.push(v15513);
            v15514;
            v15512 = this.expect(':');
        }
        return result;
    };
    const v15522 = function () {
        var args = [];
        const v15516 = this.peekToken();
        const v15517 = v15516.text;
        const v15518 = v15517 !== ')';
        if (v15518) {
            let v15519 = true;
            while (v15519) {
                const v15520 = this.filterChain();
                const v15521 = args.push(v15520);
                v15521;
                v15519 = this.expect(',');
            }
        }
        return args;
    };
    const v15529 = function () {
        var token = this.consume();
        const v15523 = token.identifier;
        const v15524 = !v15523;
        if (v15524) {
            const v15525 = this.throwError('is not a valid identifier', token);
            v15525;
        }
        const v15526 = AST.Identifier;
        const v15527 = token.text;
        const v15528 = {};
        v15528.type = v15526;
        v15528.name = v15527;
        return v15528;
    };
    const v15534 = function () {
        const v15530 = AST.Literal;
        const v15531 = this.consume();
        const v15532 = v15531.value;
        const v15533 = {};
        v15533.type = v15530;
        v15533.value = v15532;
        return v15533;
    };
    const v15545 = function () {
        var elements = [];
        const v15535 = this.peekToken();
        const v15536 = v15535.text;
        const v15537 = v15536 !== ']';
        if (v15537) {
            let v15538 = true;
            while (v15538) {
                const v15539 = this.peek(']');
                if (v15539) {
                    break;
                }
                const v15540 = this.expression();
                const v15541 = elements.push(v15540);
                v15541;
                v15538 = this.expect(',');
            }
        }
        const v15542 = this.consume(']');
        v15542;
        const v15543 = AST.ArrayExpression;
        const v15544 = {};
        v15544.type = v15543;
        v15544.elements = elements;
        return v15544;
    };
    const v15576 = function () {
        var properties = [];
        var property;
        const v15546 = this.peekToken();
        const v15547 = v15546.text;
        const v15548 = v15547 !== '}';
        if (v15548) {
            let v15549 = true;
            while (v15549) {
                const v15550 = this.peek('}');
                if (v15550) {
                    break;
                }
                const v15551 = AST.Property;
                property.type = v15551;
                property.kind = 'init';
                property = {};
                property = {};
                const v15552 = this.peek();
                const v15553 = v15552.constant;
                if (v15553) {
                    const v15554 = this.constant();
                    property.key = v15554;
                    property.computed = false;
                    const v15555 = this.consume(':');
                    v15555;
                    const v15556 = this.expression();
                    property.value = v15556;
                } else {
                    const v15557 = this.peek();
                    const v15558 = v15557.identifier;
                    if (v15558) {
                        const v15559 = this.identifier();
                        property.key = v15559;
                        property.computed = false;
                        const v15560 = this.peek(':');
                        if (v15560) {
                            const v15561 = this.consume(':');
                            v15561;
                            const v15562 = this.expression();
                            property.value = v15562;
                        } else {
                            const v15563 = property.key;
                            property.value = v15563;
                        }
                    } else {
                        const v15564 = this.peek('[');
                        if (v15564) {
                            const v15565 = this.consume('[');
                            v15565;
                            const v15566 = this.expression();
                            property.key = v15566;
                            const v15567 = this.consume(']');
                            v15567;
                            property.computed = true;
                            const v15568 = this.consume(':');
                            v15568;
                            const v15569 = this.expression();
                            property.value = v15569;
                        } else {
                            const v15570 = this.peek();
                            const v15571 = this.throwError('invalid key', v15570);
                            v15571;
                        }
                    }
                }
                const v15572 = properties.push(property);
                v15572;
                v15549 = this.expect(',');
            }
        }
        const v15573 = this.consume('}');
        v15573;
        const v15574 = AST.ObjectExpression;
        const v15575 = {};
        v15575.type = v15574;
        v15575.properties = properties;
        return v15575;
    };
    const v15585 = function (msg, token) {
        const v15577 = token.text;
        const v15578 = token.index;
        const v15579 = v15578 + 1;
        const v15580 = this.text;
        const v15581 = this.text;
        const v15582 = token.index;
        const v15583 = v15581.substring(v15582);
        const v15584 = $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', v15577, msg, v15579, v15580, v15583);
        throw v15584;
    };
    const v15596 = function (e1) {
        const v15586 = this.tokens;
        const v15587 = v15586.length;
        const v15588 = v15587 === 0;
        if (v15588) {
            const v15589 = this.text;
            const v15590 = $parseMinErr('ueoe', 'Unexpected end of expression: {0}', v15589);
            throw v15590;
        }
        var token = this.expect(e1);
        const v15591 = !token;
        if (v15591) {
            const v15592 = 'is unexpected, expecting [' + e1;
            const v15593 = v15592 + ']';
            const v15594 = this.peek();
            const v15595 = this.throwError(v15593, v15594);
            v15595;
        }
        return token;
    };
    const v15604 = function () {
        const v15597 = this.tokens;
        const v15598 = v15597.length;
        const v15599 = v15598 === 0;
        if (v15599) {
            const v15600 = this.text;
            const v15601 = $parseMinErr('ueoe', 'Unexpected end of expression: {0}', v15600);
            throw v15601;
        }
        const v15602 = this.tokens;
        const v15603 = v15602[0];
        return v15603;
    };
    const v15606 = function (e1, e2, e3, e4) {
        const v15605 = this.peekAhead(0, e1, e2, e3, e4);
        return v15605;
    };
    const v15626 = function (i, e1, e2, e3, e4) {
        const v15607 = this.tokens;
        const v15608 = v15607.length;
        const v15609 = v15608 > i;
        if (v15609) {
            const v15610 = this.tokens;
            var token = v15610[i];
            var t = token.text;
            const v15611 = t === e1;
            const v15612 = t === e2;
            const v15613 = v15611 || v15612;
            const v15614 = t === e3;
            const v15615 = v15613 || v15614;
            const v15616 = t === e4;
            const v15617 = v15615 || v15616;
            const v15618 = !e1;
            const v15619 = !e2;
            const v15620 = v15618 && v15619;
            const v15621 = !e3;
            const v15622 = v15620 && v15621;
            const v15623 = !e4;
            const v15624 = v15622 && v15623;
            const v15625 = v15617 || v15624;
            if (v15625) {
                return token;
            }
        }
        return false;
    };
    const v15629 = function (e1, e2, e3, e4) {
        var token = this.peek(e1, e2, e3, e4);
        if (token) {
            const v15627 = this.tokens;
            const v15628 = v15627.shift();
            v15628;
            return token;
        }
        return false;
    };
    const v15630 = AST.ThisExpression;
    const v15631 = {};
    v15631.type = v15630;
    const v15632 = AST.LocalsExpression;
    const v15633 = {};
    v15633.type = v15632;
    const v15634 = {};
    v15634['this'] = v15631;
    v15634['$locals'] = v15633;
    const v15635 = {};
    v15635.ast = v15401;
    v15635.program = v15414;
    v15635.expressionStatement = v15418;
    v15635.filterChain = v15420;
    v15635.expression = v15422;
    v15635.assignment = v15429;
    v15635.ternary = v15434;
    v15635.logicalOR = v15438;
    v15635.logicalAND = v15442;
    v15635.equality = v15446;
    v15635.relational = v15450;
    v15635.additive = v15454;
    v15635.multiplicative = v15458;
    v15635.unary = v15464;
    v15635.primary = v15509;
    v15635.filter = v15515;
    v15635.parseArguments = v15522;
    v15635.identifier = v15529;
    v15635.constant = v15534;
    v15635.arrayDeclaration = v15545;
    v15635.object = v15576;
    v15635.throwError = v15585;
    v15635.consume = v15596;
    v15635.peekToken = v15604;
    v15635.peek = v15606;
    v15635.peekAhead = v15626;
    v15635.expect = v15629;
    v15635.selfReferential = v15634;
    AST.prototype = v15635;
    const ifDefined = function (v, d) {
        const v15636 = typeof v;
        const v15637 = v15636 !== 'undefined';
        let v15638;
        if (v15637) {
            v15638 = v;
        } else {
            v15638 = d;
        }
        return v15638;
    };
    const plusFn = function (l, r) {
        const v15639 = typeof l;
        const v15640 = v15639 === 'undefined';
        if (v15640) {
            return r;
        }
        const v15641 = typeof r;
        const v15642 = v15641 === 'undefined';
        if (v15642) {
            return l;
        }
        const v15643 = l + r;
        return v15643;
    };
    const isStateless = function ($filter, filterName) {
        var fn = $filter(filterName);
        const v15644 = fn.$stateful;
        const v15645 = !v15644;
        return v15645;
    };
    var PURITY_ABSOLUTE = 1;
    var PURITY_RELATIVE = 2;
    const isPure = function (node, parentIsPure) {
        const v15646 = node.type;
        const v15647 = AST.MemberExpression;
        const v15648 = AST.UnaryExpression;
        const v15649 = AST.BinaryExpression;
        const v15650 = AST.CallExpression;
        switch (v15646) {
        case v15647:
            const v15651 = node.computed;
            if (v15651) {
                return false;
            }
            break;
        case v15648:
            return PURITY_ABSOLUTE;
        case v15649:
            const v15652 = node.operator;
            const v15653 = v15652 !== '+';
            let v15654;
            if (v15653) {
                v15654 = PURITY_ABSOLUTE;
            } else {
                v15654 = false;
            }
            return v15654;
        case v15650:
            return false;
        }
        const v15655 = undefined === parentIsPure;
        let v15656;
        if (v15655) {
            v15656 = PURITY_RELATIVE;
        } else {
            v15656 = parentIsPure;
        }
        return v15656;
    };
    const findConstantAndWatchExpressions = function (ast, $filter, parentIsPure) {
        var allConstants;
        var argsToWatch;
        var isStatelessFilter;
        const v15657 = isPure(ast, parentIsPure);
        ast.isPure = v15657;
        var astIsPure = ast.isPure;
        const v15658 = ast.type;
        const v15659 = AST.Program;
        const v15660 = AST.Literal;
        const v15661 = AST.UnaryExpression;
        const v15662 = AST.BinaryExpression;
        const v15663 = AST.LogicalExpression;
        const v15664 = AST.ConditionalExpression;
        const v15665 = AST.Identifier;
        const v15666 = AST.MemberExpression;
        const v15667 = AST.CallExpression;
        const v15668 = AST.AssignmentExpression;
        const v15669 = AST.ArrayExpression;
        const v15670 = AST.ObjectExpression;
        const v15671 = AST.ThisExpression;
        const v15672 = AST.LocalsExpression;
        switch (v15658) {
        case v15659:
            allConstants = true;
            const v15673 = ast.body;
            const v15678 = function (expr) {
                const v15674 = expr.expression;
                const v15675 = findConstantAndWatchExpressions(v15674, $filter, astIsPure);
                v15675;
                const v15676 = expr.expression;
                const v15677 = v15676.constant;
                allConstants = allConstants && v15677;
            };
            const v15679 = forEach(v15673, v15678);
            v15679;
            ast.constant = allConstants;
            break;
        case v15660:
            ast.constant = true;
            ast.toWatch = [];
            break;
        case v15661:
            const v15680 = ast.argument;
            const v15681 = findConstantAndWatchExpressions(v15680, $filter, astIsPure);
            v15681;
            const v15682 = ast.argument;
            const v15683 = v15682.constant;
            ast.constant = v15683;
            const v15684 = ast.argument;
            const v15685 = v15684.toWatch;
            ast.toWatch = v15685;
            break;
        case v15662:
            const v15686 = ast.left;
            const v15687 = findConstantAndWatchExpressions(v15686, $filter, astIsPure);
            v15687;
            const v15688 = ast.right;
            const v15689 = findConstantAndWatchExpressions(v15688, $filter, astIsPure);
            v15689;
            const v15690 = ast.left;
            const v15691 = v15690.constant;
            const v15692 = ast.right;
            const v15693 = v15692.constant;
            ast.constant = v15691 && v15693;
            const v15694 = ast.left;
            const v15695 = v15694.toWatch;
            const v15696 = ast.right;
            const v15697 = v15696.toWatch;
            const v15698 = v15695.concat(v15697);
            ast.toWatch = v15698;
            break;
        case v15663:
            const v15699 = ast.left;
            const v15700 = findConstantAndWatchExpressions(v15699, $filter, astIsPure);
            v15700;
            const v15701 = ast.right;
            const v15702 = findConstantAndWatchExpressions(v15701, $filter, astIsPure);
            v15702;
            const v15703 = ast.left;
            const v15704 = v15703.constant;
            const v15705 = ast.right;
            const v15706 = v15705.constant;
            ast.constant = v15704 && v15706;
            const v15707 = ast.constant;
            const v15708 = [];
            const v15709 = [ast];
            let v15710;
            if (v15707) {
                v15710 = v15708;
            } else {
                v15710 = v15709;
            }
            ast.toWatch = v15710;
            break;
        case v15664:
            const v15711 = ast.test;
            const v15712 = findConstantAndWatchExpressions(v15711, $filter, astIsPure);
            v15712;
            const v15713 = ast.alternate;
            const v15714 = findConstantAndWatchExpressions(v15713, $filter, astIsPure);
            v15714;
            const v15715 = ast.consequent;
            const v15716 = findConstantAndWatchExpressions(v15715, $filter, astIsPure);
            v15716;
            const v15717 = ast.test;
            const v15718 = v15717.constant;
            const v15719 = ast.alternate;
            const v15720 = v15719.constant;
            const v15721 = v15718 && v15720;
            const v15722 = ast.consequent;
            const v15723 = v15722.constant;
            ast.constant = v15721 && v15723;
            const v15724 = ast.constant;
            const v15725 = [];
            const v15726 = [ast];
            let v15727;
            if (v15724) {
                v15727 = v15725;
            } else {
                v15727 = v15726;
            }
            ast.toWatch = v15727;
            break;
        case v15665:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
        case v15666:
            const v15728 = ast.object;
            const v15729 = findConstantAndWatchExpressions(v15728, $filter, astIsPure);
            v15729;
            const v15730 = ast.computed;
            if (v15730) {
                const v15731 = ast.property;
                const v15732 = findConstantAndWatchExpressions(v15731, $filter, astIsPure);
                v15732;
            }
            const v15733 = ast.object;
            const v15734 = v15733.constant;
            const v15735 = ast.computed;
            const v15736 = !v15735;
            const v15737 = ast.property;
            const v15738 = v15737.constant;
            const v15739 = v15736 || v15738;
            ast.constant = v15734 && v15739;
            const v15740 = ast.constant;
            const v15741 = [];
            const v15742 = [ast];
            let v15743;
            if (v15740) {
                v15743 = v15741;
            } else {
                v15743 = v15742;
            }
            ast.toWatch = v15743;
            break;
        case v15667:
            const v15744 = ast.filter;
            const v15745 = ast.callee;
            const v15746 = v15745.name;
            const v15747 = isStateless($filter, v15746);
            if (v15744) {
                isStatelessFilter = v15747;
            } else {
                isStatelessFilter = false;
            }
            allConstants = isStatelessFilter;
            argsToWatch = [];
            const v15748 = ast.arguments;
            const v15754 = function (expr) {
                const v15749 = findConstantAndWatchExpressions(expr, $filter, astIsPure);
                v15749;
                const v15750 = expr.constant;
                allConstants = allConstants && v15750;
                const v15751 = argsToWatch.push;
                const v15752 = expr.toWatch;
                const v15753 = v15751.apply(argsToWatch, v15752);
                v15753;
            };
            const v15755 = forEach(v15748, v15754);
            v15755;
            ast.constant = allConstants;
            const v15756 = [ast];
            let v15757;
            if (isStatelessFilter) {
                v15757 = argsToWatch;
            } else {
                v15757 = v15756;
            }
            ast.toWatch = v15757;
            break;
        case v15668:
            const v15758 = ast.left;
            const v15759 = findConstantAndWatchExpressions(v15758, $filter, astIsPure);
            v15759;
            const v15760 = ast.right;
            const v15761 = findConstantAndWatchExpressions(v15760, $filter, astIsPure);
            v15761;
            const v15762 = ast.left;
            const v15763 = v15762.constant;
            const v15764 = ast.right;
            const v15765 = v15764.constant;
            ast.constant = v15763 && v15765;
            ast.toWatch = [ast];
            break;
        case v15669:
            allConstants = true;
            argsToWatch = [];
            const v15766 = ast.elements;
            const v15772 = function (expr) {
                const v15767 = findConstantAndWatchExpressions(expr, $filter, astIsPure);
                v15767;
                const v15768 = expr.constant;
                allConstants = allConstants && v15768;
                const v15769 = argsToWatch.push;
                const v15770 = expr.toWatch;
                const v15771 = v15769.apply(argsToWatch, v15770);
                v15771;
            };
            const v15773 = forEach(v15766, v15772);
            v15773;
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
        case v15670:
            allConstants = true;
            argsToWatch = [];
            const v15774 = ast.properties;
            const v15792 = function (property) {
                const v15775 = property.value;
                const v15776 = findConstantAndWatchExpressions(v15775, $filter, astIsPure);
                v15776;
                const v15777 = property.value;
                const v15778 = v15777.constant;
                allConstants = allConstants && v15778;
                const v15779 = argsToWatch.push;
                const v15780 = property.value;
                const v15781 = v15780.toWatch;
                const v15782 = v15779.apply(argsToWatch, v15781);
                v15782;
                const v15783 = property.computed;
                if (v15783) {
                    const v15784 = property.key;
                    const v15785 = findConstantAndWatchExpressions(v15784, $filter, false);
                    v15785;
                    const v15786 = property.key;
                    const v15787 = v15786.constant;
                    allConstants = allConstants && v15787;
                    const v15788 = argsToWatch.push;
                    const v15789 = property.key;
                    const v15790 = v15789.toWatch;
                    const v15791 = v15788.apply(argsToWatch, v15790);
                    v15791;
                }
            };
            const v15793 = forEach(v15774, v15792);
            v15793;
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
        case v15671:
            ast.constant = false;
            ast.toWatch = [];
            break;
        case v15672:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
    };
    const getInputs = function (body) {
        const v15794 = body.length;
        const v15795 = v15794 !== 1;
        if (v15795) {
            return;
        }
        const v15796 = body[0];
        var lastExpression = v15796.expression;
        var candidate = lastExpression.toWatch;
        const v15797 = candidate.length;
        const v15798 = v15797 !== 1;
        if (v15798) {
            return candidate;
        }
        const v15799 = candidate[0];
        const v15800 = v15799 !== lastExpression;
        let v15801;
        if (v15800) {
            v15801 = candidate;
        } else {
            v15801 = undefined;
        }
        return v15801;
    };
    const isAssignable = function (ast) {
        const v15802 = ast.type;
        const v15803 = AST.Identifier;
        const v15804 = v15802 === v15803;
        const v15805 = ast.type;
        const v15806 = AST.MemberExpression;
        const v15807 = v15805 === v15806;
        const v15808 = v15804 || v15807;
        return v15808;
    };
    const assignableAST = function (ast) {
        const v15809 = ast.body;
        const v15810 = v15809.length;
        const v15811 = v15810 === 1;
        const v15812 = ast.body;
        const v15813 = v15812[0];
        const v15814 = v15813.expression;
        const v15815 = isAssignable(v15814);
        const v15816 = v15811 && v15815;
        if (v15816) {
            const v15817 = AST.AssignmentExpression;
            const v15818 = ast.body;
            const v15819 = v15818[0];
            const v15820 = v15819.expression;
            const v15821 = AST.NGValueParameter;
            const v15822 = {};
            v15822.type = v15821;
            const v15823 = {};
            v15823.type = v15817;
            v15823.left = v15820;
            v15823.right = v15822;
            v15823.operator = '=';
            return v15823;
        }
    };
    const isLiteral = function (ast) {
        const v15824 = ast.body;
        const v15825 = v15824.length;
        const v15826 = v15825 === 0;
        const v15827 = ast.body;
        const v15828 = v15827.length;
        const v15829 = v15828 === 1;
        const v15830 = ast.body;
        const v15831 = v15830[0];
        const v15832 = v15831.expression;
        const v15833 = v15832.type;
        const v15834 = AST.Literal;
        const v15835 = v15833 === v15834;
        const v15836 = ast.body;
        const v15837 = v15836[0];
        const v15838 = v15837.expression;
        const v15839 = v15838.type;
        const v15840 = AST.ArrayExpression;
        const v15841 = v15839 === v15840;
        const v15842 = v15835 || v15841;
        const v15843 = ast.body;
        const v15844 = v15843[0];
        const v15845 = v15844.expression;
        const v15846 = v15845.type;
        const v15847 = AST.ObjectExpression;
        const v15848 = v15846 === v15847;
        const v15849 = v15842 || v15848;
        const v15850 = v15829 && v15849;
        const v15851 = v15826 || v15850;
        return v15851;
    };
    const isConstant = function (ast) {
        const v15852 = ast.constant;
        return v15852;
    };
    const ASTCompiler = function ($filter) {
        this.$filter = $filter;
    };
    const v15904 = function (ast) {
        var self = this;
        const v15853 = {};
        const v15854 = [];
        const v15855 = [];
        const v15856 = {};
        const v15857 = {};
        v15857.vars = v15854;
        v15857.body = v15855;
        v15857.own = v15856;
        const v15858 = [];
        const v15859 = [];
        const v15860 = {};
        const v15861 = {};
        v15861.vars = v15858;
        v15861.body = v15859;
        v15861.own = v15860;
        const v15862 = [];
        const v15863 = {};
        v15863.nextId = 0;
        v15863.filters = v15853;
        v15863.fn = v15857;
        v15863.assign = v15861;
        v15863.inputs = v15862;
        this.state = v15863;
        const v15864 = self.$filter;
        const v15865 = findConstantAndWatchExpressions(ast, v15864);
        v15865;
        var extra = '';
        var assignable;
        this.stage = 'assign';
        if (assignable = assignableAST(ast)) {
            const v15866 = this.state;
            v15866.computing = 'assign';
            var result = this.nextId();
            const v15867 = this.recurse(assignable, result);
            v15867;
            const v15868 = this.return_(result);
            v15868;
            const v15869 = this.generateFunction('assign', 's,v,l');
            extra = 'fn.assign=' + v15869;
        }
        const v15870 = ast.body;
        var toWatch = getInputs(v15870);
        self.stage = 'inputs';
        const v15884 = function (watch, key) {
            var fnKey = 'fn' + key;
            const v15871 = self.state;
            const v15872 = [];
            const v15873 = [];
            const v15874 = {};
            const v15875 = {};
            v15875.vars = v15872;
            v15875.body = v15873;
            v15875.own = v15874;
            v15871[fnKey] = v15875;
            const v15876 = self.state;
            v15876.computing = fnKey;
            var intoId = self.nextId();
            const v15877 = self.recurse(watch, intoId);
            v15877;
            const v15878 = self.return_(intoId);
            v15878;
            const v15879 = self.state;
            const v15880 = v15879.inputs;
            const v15881 = watch.isPure;
            const v15882 = {
                name: fnKey,
                isPure: v15881
            };
            const v15883 = v15880.push(v15882);
            v15883;
            watch.watchId = key;
        };
        const v15885 = forEach(toWatch, v15884);
        v15885;
        const v15886 = this.state;
        v15886.computing = 'fn';
        this.stage = 'main';
        const v15887 = this.recurse(ast);
        v15887;
        const v15888 = this.USE;
        const v15889 = '"' + v15888;
        const v15890 = v15889 + ' ';
        const v15891 = this.STRICT;
        const v15892 = v15890 + v15891;
        const v15893 = v15892 + '";\n';
        const v15894 = this.filterPrefix();
        const v15895 = v15893 + v15894;
        const v15896 = v15895 + 'var fn=';
        const v15897 = this.generateFunction('fn', 's,l,a,i');
        const v15898 = v15896 + v15897;
        const v15899 = v15898 + extra;
        const v15900 = this.watchFns();
        const v15901 = v15899 + v15900;
        var fnString = v15901 + 'return fn;';
        const v15902 = new Function('$filter', 'getStringValue', 'ifDefined', 'plus', fnString);
        const v15903 = this.$filter;
        var fn = v15902(v15903, getStringValue, ifDefined, plusFn);
        this.state = this.stage = undefined;
        return fn;
    };
    const v15931 = function () {
        var result = [];
        const v15905 = this.state;
        var inputs = v15905.inputs;
        var self = this;
        const v15920 = function (input) {
            const v15906 = input.name;
            const v15907 = 'var ' + v15906;
            const v15908 = v15907 + '=';
            const v15909 = input.name;
            const v15910 = self.generateFunction(v15909, 's');
            const v15911 = v15908 + v15910;
            const v15912 = result.push(v15911);
            v15912;
            const v15913 = input.isPure;
            if (v15913) {
                const v15914 = input.name;
                const v15915 = input.isPure;
                const v15916 = JSON.stringify(v15915);
                const v15917 = '.isPure=' + v15916;
                const v15918 = v15917 + ';';
                const v15919 = result.push(v15914, v15918);
                v15919;
            }
        };
        const v15921 = forEach(inputs, v15920);
        v15921;
        const v15922 = inputs.length;
        if (v15922) {
            const v15924 = function (i) {
                const v15923 = i.name;
                return v15923;
            };
            const v15925 = inputs.map(v15924);
            const v15926 = v15925.join(',');
            const v15927 = 'fn.inputs=[' + v15926;
            const v15928 = v15927 + '];';
            const v15929 = result.push(v15928);
            v15929;
        }
        const v15930 = result.join('');
        return v15930;
    };
    const v15939 = function (name, params) {
        const v15932 = 'function(' + params;
        const v15933 = v15932 + '){';
        const v15934 = this.varsPrefix(name);
        const v15935 = v15933 + v15934;
        const v15936 = this.body(name);
        const v15937 = v15935 + v15936;
        const v15938 = v15937 + '};';
        return v15938;
    };
    const v15953 = function () {
        var parts = [];
        var self = this;
        const v15940 = this.state;
        const v15941 = v15940.filters;
        const v15947 = function (id, filter) {
            const v15942 = id + '=$filter(';
            const v15943 = self.escape(filter);
            const v15944 = v15942 + v15943;
            const v15945 = v15944 + ')';
            const v15946 = parts.push(v15945);
            v15946;
        };
        const v15948 = forEach(v15941, v15947);
        v15948;
        const v15949 = parts.length;
        if (v15949) {
            const v15950 = parts.join(',');
            const v15951 = 'var ' + v15950;
            const v15952 = v15951 + ';';
            return v15952;
        }
        return '';
    };
    const v15965 = function (section) {
        const v15954 = this.state;
        const v15955 = v15954[section];
        const v15956 = v15955.vars;
        const v15957 = v15956.length;
        const v15958 = this.state;
        const v15959 = v15958[section];
        const v15960 = v15959.vars;
        const v15961 = v15960.join(',');
        const v15962 = 'var ' + v15961;
        const v15963 = v15962 + ';';
        let v15964;
        if (v15957) {
            v15964 = v15963;
        } else {
            v15964 = '';
        }
        return v15964;
    };
    const v15970 = function (section) {
        const v15966 = this.state;
        const v15967 = v15966[section];
        const v15968 = v15967.body;
        const v15969 = v15968.join('');
        return v15969;
    };
    const v16288 = function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
        var left;
        var right;
        var self = this;
        var args;
        var expression;
        var computed;
        recursionFn = recursionFn || noop;
        const v15971 = !skipWatchIdCheck;
        const v15972 = ast.watchId;
        const v15973 = isDefined(v15972);
        const v15974 = v15971 && v15973;
        if (v15974) {
            const v15975 = this.nextId();
            intoId = intoId || v15975;
            const v15976 = ast.watchId;
            const v15977 = this.computedMember('i', v15976);
            const v15978 = this.lazyAssign(intoId, v15977);
            const v15979 = this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true);
            const v15980 = this.if_('i', v15978, v15979);
            v15980;
            return;
        }
        const v15981 = ast.type;
        const v15982 = AST.Program;
        const v15983 = AST.Literal;
        const v15984 = AST.UnaryExpression;
        const v15985 = AST.BinaryExpression;
        const v15986 = AST.LogicalExpression;
        const v15987 = AST.ConditionalExpression;
        const v15988 = AST.Identifier;
        const v15989 = AST.MemberExpression;
        const v15990 = AST.CallExpression;
        const v15991 = AST.AssignmentExpression;
        const v15992 = AST.ArrayExpression;
        const v15993 = AST.ObjectExpression;
        const v15994 = AST.ThisExpression;
        const v15995 = AST.LocalsExpression;
        const v15996 = AST.NGValueParameter;
        switch (v15981) {
        case v15982:
            const v15997 = ast.body;
            const v16009 = function (expression, pos) {
                const v15998 = expression.expression;
                const v15999 = function (expr) {
                    right = expr;
                };
                const v16000 = self.recurse(v15998, undefined, undefined, v15999);
                v16000;
                const v16001 = ast.body;
                const v16002 = v16001.length;
                const v16003 = v16002 - 1;
                const v16004 = pos !== v16003;
                if (v16004) {
                    const v16005 = self.current();
                    const v16006 = v16005.body;
                    const v16007 = v16006.push(right, ';');
                    v16007;
                } else {
                    const v16008 = self.return_(right);
                    v16008;
                }
            };
            const v16010 = forEach(v15997, v16009);
            v16010;
            break;
        case v15983:
            const v16011 = ast.value;
            expression = this.escape(v16011);
            const v16012 = this.assign(intoId, expression);
            v16012;
            const v16013 = intoId || expression;
            const v16014 = recursionFn(v16013);
            v16014;
            break;
        case v15984:
            const v16015 = ast.argument;
            const v16016 = function (expr) {
                right = expr;
            };
            const v16017 = this.recurse(v16015, undefined, undefined, v16016);
            v16017;
            const v16018 = ast.operator;
            const v16019 = v16018 + '(';
            const v16020 = this.ifDefined(right, 0);
            const v16021 = v16019 + v16020;
            expression = v16021 + ')';
            const v16022 = this.assign(intoId, expression);
            v16022;
            const v16023 = recursionFn(expression);
            v16023;
            break;
        case v15985:
            const v16024 = ast.left;
            const v16025 = function (expr) {
                left = expr;
            };
            const v16026 = this.recurse(v16024, undefined, undefined, v16025);
            v16026;
            const v16027 = ast.right;
            const v16028 = function (expr) {
                right = expr;
            };
            const v16029 = this.recurse(v16027, undefined, undefined, v16028);
            v16029;
            const v16030 = ast.operator;
            const v16031 = v16030 === '+';
            if (v16031) {
                expression = this.plus(left, right);
            } else {
                const v16032 = ast.operator;
                const v16033 = v16032 === '-';
                if (v16033) {
                    const v16034 = this.ifDefined(left, 0);
                    const v16035 = ast.operator;
                    const v16036 = v16034 + v16035;
                    const v16037 = this.ifDefined(right, 0);
                    expression = v16036 + v16037;
                } else {
                    const v16038 = '(' + left;
                    const v16039 = v16038 + ')';
                    const v16040 = ast.operator;
                    const v16041 = v16039 + v16040;
                    const v16042 = v16041 + '(';
                    const v16043 = v16042 + right;
                    expression = v16043 + ')';
                }
            }
            const v16044 = this.assign(intoId, expression);
            v16044;
            const v16045 = recursionFn(expression);
            v16045;
            break;
        case v15986:
            const v16046 = this.nextId();
            intoId = intoId || v16046;
            const v16047 = ast.left;
            const v16048 = self.recurse(v16047, intoId);
            v16048;
            const v16049 = ast.operator;
            const v16050 = v16049 === '&&';
            const v16051 = self.not(intoId);
            let v16052;
            if (v16050) {
                v16052 = intoId;
            } else {
                v16052 = v16051;
            }
            const v16053 = ast.right;
            const v16054 = self.lazyRecurse(v16053, intoId);
            const v16055 = self.if_(v16052, v16054);
            v16055;
            const v16056 = recursionFn(intoId);
            v16056;
            break;
        case v15987:
            const v16057 = this.nextId();
            intoId = intoId || v16057;
            const v16058 = ast.test;
            const v16059 = self.recurse(v16058, intoId);
            v16059;
            const v16060 = ast.alternate;
            const v16061 = self.lazyRecurse(v16060, intoId);
            const v16062 = ast.consequent;
            const v16063 = self.lazyRecurse(v16062, intoId);
            const v16064 = self.if_(intoId, v16061, v16063);
            v16064;
            const v16065 = recursionFn(intoId);
            v16065;
            break;
        case v15988:
            const v16066 = this.nextId();
            intoId = intoId || v16066;
            if (nameId) {
                const v16067 = self.stage;
                const v16068 = v16067 === 'inputs';
                const v16069 = this.nextId();
                const v16070 = ast.name;
                const v16071 = this.getHasOwnProperty('l', v16070);
                const v16072 = v16071 + '?l:s';
                const v16073 = this.assign(v16069, v16072);
                let v16074;
                if (v16068) {
                    v16074 = 's';
                } else {
                    v16074 = v16073;
                }
                nameId.context = v16074;
                nameId.computed = false;
                const v16075 = ast.name;
                nameId.name = v16075;
            }
            const v16076 = self.stage;
            const v16077 = v16076 === 'inputs';
            const v16078 = ast.name;
            const v16079 = self.getHasOwnProperty('l', v16078);
            const v16080 = self.not(v16079);
            const v16081 = v16077 || v16080;
            const v16099 = function () {
                const v16082 = self.stage;
                const v16083 = v16082 === 'inputs';
                const v16084 = v16083 || 's';
                const v16097 = function () {
                    const v16085 = create !== 1;
                    const v16086 = create && v16085;
                    if (v16086) {
                        const v16087 = ast.name;
                        const v16088 = self.nonComputedMember('s', v16087);
                        const v16089 = self.isNull(v16088);
                        const v16090 = ast.name;
                        const v16091 = self.nonComputedMember('s', v16090);
                        const v16092 = self.lazyAssign(v16091, '{}');
                        const v16093 = self.if_(v16089, v16092);
                        v16093;
                    }
                    const v16094 = ast.name;
                    const v16095 = self.nonComputedMember('s', v16094);
                    const v16096 = self.assign(intoId, v16095);
                    v16096;
                };
                const v16098 = self.if_(v16084, v16097);
                v16098;
            };
            const v16100 = ast.name;
            const v16101 = self.nonComputedMember('l', v16100);
            const v16102 = self.lazyAssign(intoId, v16101);
            const v16103 = intoId && v16102;
            const v16104 = self.if_(v16081, v16099, v16103);
            v16104;
            const v16105 = recursionFn(intoId);
            v16105;
            break;
        case v15989:
            const v16106 = this.nextId();
            const v16107 = nameId && (nameId.context = v16106);
            const v16108 = this.nextId();
            left = v16107 || v16108;
            const v16109 = this.nextId();
            intoId = intoId || v16109;
            const v16110 = ast.object;
            const v16145 = function () {
                const v16111 = self.notNull(left);
                const v16140 = function () {
                    const v16112 = ast.computed;
                    if (v16112) {
                        right = self.nextId();
                        const v16113 = ast.property;
                        const v16114 = self.recurse(v16113, right);
                        v16114;
                        const v16115 = self.getStringValue(right);
                        v16115;
                        const v16116 = create !== 1;
                        const v16117 = create && v16116;
                        if (v16117) {
                            const v16118 = self.computedMember(left, right);
                            const v16119 = self.not(v16118);
                            const v16120 = self.computedMember(left, right);
                            const v16121 = self.lazyAssign(v16120, '{}');
                            const v16122 = self.if_(v16119, v16121);
                            v16122;
                        }
                        expression = self.computedMember(left, right);
                        const v16123 = self.assign(intoId, expression);
                        v16123;
                        if (nameId) {
                            nameId.computed = true;
                            nameId.name = right;
                        }
                    } else {
                        const v16124 = create !== 1;
                        const v16125 = create && v16124;
                        if (v16125) {
                            const v16126 = ast.property;
                            const v16127 = v16126.name;
                            const v16128 = self.nonComputedMember(left, v16127);
                            const v16129 = self.isNull(v16128);
                            const v16130 = ast.property;
                            const v16131 = v16130.name;
                            const v16132 = self.nonComputedMember(left, v16131);
                            const v16133 = self.lazyAssign(v16132, '{}');
                            const v16134 = self.if_(v16129, v16133);
                            v16134;
                        }
                        const v16135 = ast.property;
                        const v16136 = v16135.name;
                        expression = self.nonComputedMember(left, v16136);
                        const v16137 = self.assign(intoId, expression);
                        v16137;
                        if (nameId) {
                            nameId.computed = false;
                            const v16138 = ast.property;
                            const v16139 = v16138.name;
                            nameId.name = v16139;
                        }
                    }
                };
                const v16142 = function () {
                    const v16141 = self.assign(intoId, 'undefined');
                    v16141;
                };
                const v16143 = self.if_(v16111, v16140, v16142);
                v16143;
                const v16144 = recursionFn(intoId);
                v16144;
            };
            const v16146 = !create;
            const v16147 = !v16146;
            const v16148 = self.recurse(v16110, left, undefined, v16145, v16147);
            v16148;
            break;
        case v15990:
            const v16149 = this.nextId();
            intoId = intoId || v16149;
            const v16150 = ast.filter;
            if (v16150) {
                const v16151 = ast.callee;
                const v16152 = v16151.name;
                right = self.filter(v16152);
                args = [];
                const v16153 = ast.arguments;
                const v16156 = function (expr) {
                    var argument = self.nextId();
                    const v16154 = self.recurse(expr, argument);
                    v16154;
                    const v16155 = args.push(argument);
                    v16155;
                };
                const v16157 = forEach(v16153, v16156);
                v16157;
                const v16158 = right + '(';
                const v16159 = args.join(',');
                const v16160 = v16158 + v16159;
                expression = v16160 + ')';
                const v16161 = self.assign(intoId, expression);
                v16161;
                const v16162 = recursionFn(intoId);
                v16162;
            } else {
                right = self.nextId();
                left = {};
                args = [];
                const v16163 = ast.callee;
                const v16191 = function () {
                    const v16164 = self.notNull(right);
                    const v16186 = function () {
                        const v16165 = ast.arguments;
                        const v16172 = function (expr) {
                            const v16166 = ast.constant;
                            const v16167 = self.nextId();
                            let v16168;
                            if (v16166) {
                                v16168 = undefined;
                            } else {
                                v16168 = v16167;
                            }
                            const v16170 = function (argument) {
                                const v16169 = args.push(argument);
                                v16169;
                            };
                            const v16171 = self.recurse(expr, v16168, undefined, v16170);
                            v16171;
                        };
                        const v16173 = forEach(v16165, v16172);
                        v16173;
                        const v16174 = left.name;
                        if (v16174) {
                            const v16175 = left.context;
                            const v16176 = left.name;
                            const v16177 = left.computed;
                            const v16178 = self.member(v16175, v16176, v16177);
                            const v16179 = v16178 + '(';
                            const v16180 = args.join(',');
                            const v16181 = v16179 + v16180;
                            expression = v16181 + ')';
                        } else {
                            const v16182 = right + '(';
                            const v16183 = args.join(',');
                            const v16184 = v16182 + v16183;
                            expression = v16184 + ')';
                        }
                        const v16185 = self.assign(intoId, expression);
                        v16185;
                    };
                    const v16188 = function () {
                        const v16187 = self.assign(intoId, 'undefined');
                        v16187;
                    };
                    const v16189 = self.if_(v16164, v16186, v16188);
                    v16189;
                    const v16190 = recursionFn(intoId);
                    v16190;
                };
                const v16192 = self.recurse(v16163, right, left, v16191);
                v16192;
            }
            break;
        case v15991:
            right = this.nextId();
            left = {};
            const v16193 = ast.left;
            const v16209 = function () {
                const v16194 = left.context;
                const v16195 = self.notNull(v16194);
                const v16207 = function () {
                    const v16196 = ast.right;
                    const v16197 = self.recurse(v16196, right);
                    v16197;
                    const v16198 = left.context;
                    const v16199 = left.name;
                    const v16200 = left.computed;
                    const v16201 = self.member(v16198, v16199, v16200);
                    const v16202 = ast.operator;
                    const v16203 = v16201 + v16202;
                    expression = v16203 + right;
                    const v16204 = self.assign(intoId, expression);
                    v16204;
                    const v16205 = intoId || expression;
                    const v16206 = recursionFn(v16205);
                    v16206;
                };
                const v16208 = self.if_(v16195, v16207);
                v16208;
            };
            const v16210 = this.recurse(v16193, undefined, left, v16209, 1);
            v16210;
            break;
        case v15992:
            args = [];
            const v16211 = ast.elements;
            const v16218 = function (expr) {
                const v16212 = ast.constant;
                const v16213 = self.nextId();
                let v16214;
                if (v16212) {
                    v16214 = undefined;
                } else {
                    v16214 = v16213;
                }
                const v16216 = function (argument) {
                    const v16215 = args.push(argument);
                    v16215;
                };
                const v16217 = self.recurse(expr, v16214, undefined, v16216);
                v16217;
            };
            const v16219 = forEach(v16211, v16218);
            v16219;
            const v16220 = args.join(',');
            const v16221 = '[' + v16220;
            expression = v16221 + ']';
            const v16222 = this.assign(intoId, expression);
            v16222;
            const v16223 = intoId || expression;
            const v16224 = recursionFn(v16223);
            v16224;
            break;
        case v15993:
            args = [];
            computed = false;
            const v16225 = ast.properties;
            const v16227 = function (property) {
                const v16226 = property.computed;
                if (v16226) {
                    computed = true;
                }
            };
            const v16228 = forEach(v16225, v16227);
            v16228;
            if (computed) {
                const v16229 = this.nextId();
                intoId = intoId || v16229;
                const v16230 = this.assign(intoId, '{}');
                v16230;
                const v16231 = ast.properties;
                const v16249 = function (property) {
                    const v16232 = property.computed;
                    if (v16232) {
                        left = self.nextId();
                        const v16233 = property.key;
                        const v16234 = self.recurse(v16233, left);
                        v16234;
                    } else {
                        const v16235 = property.key;
                        const v16236 = v16235.type;
                        const v16237 = AST.Identifier;
                        const v16238 = v16236 === v16237;
                        const v16239 = property.key;
                        const v16240 = v16239.name;
                        const v16241 = property.key;
                        const v16242 = v16241.value;
                        const v16243 = '' + v16242;
                        if (v16238) {
                            left = v16240;
                        } else {
                            left = v16243;
                        }
                    }
                    right = self.nextId();
                    const v16244 = property.value;
                    const v16245 = self.recurse(v16244, right);
                    v16245;
                    const v16246 = property.computed;
                    const v16247 = self.member(intoId, left, v16246);
                    const v16248 = self.assign(v16247, right);
                    v16248;
                };
                const v16250 = forEach(v16231, v16249);
                v16250;
            } else {
                const v16251 = ast.properties;
                const v16272 = function (property) {
                    const v16252 = property.value;
                    const v16253 = ast.constant;
                    const v16254 = self.nextId();
                    let v16255;
                    if (v16253) {
                        v16255 = undefined;
                    } else {
                        v16255 = v16254;
                    }
                    const v16270 = function (expr) {
                        const v16256 = property.key;
                        const v16257 = v16256.type;
                        const v16258 = AST.Identifier;
                        const v16259 = v16257 === v16258;
                        const v16260 = property.key;
                        const v16261 = v16260.name;
                        const v16262 = property.key;
                        const v16263 = v16262.value;
                        const v16264 = '' + v16263;
                        let v16265;
                        if (v16259) {
                            v16265 = v16261;
                        } else {
                            v16265 = v16264;
                        }
                        const v16266 = self.escape(v16265);
                        const v16267 = v16266 + ':';
                        const v16268 = v16267 + expr;
                        const v16269 = args.push(v16268);
                        v16269;
                    };
                    const v16271 = self.recurse(v16252, v16255, undefined, v16270);
                    v16271;
                };
                const v16273 = forEach(v16251, v16272);
                v16273;
                const v16274 = args.join(',');
                const v16275 = '{' + v16274;
                expression = v16275 + '}';
                const v16276 = this.assign(intoId, expression);
                v16276;
            }
            const v16277 = intoId || expression;
            const v16278 = recursionFn(v16277);
            v16278;
            break;
        case v15994:
            const v16279 = this.assign(intoId, 's');
            v16279;
            const v16280 = intoId || 's';
            const v16281 = recursionFn(v16280);
            v16281;
            break;
        case v15995:
            const v16282 = this.assign(intoId, 'l');
            v16282;
            const v16283 = intoId || 'l';
            const v16284 = recursionFn(v16283);
            v16284;
            break;
        case v15996:
            const v16285 = this.assign(intoId, 'v');
            v16285;
            const v16286 = intoId || 'v';
            const v16287 = recursionFn(v16286);
            v16287;
            break;
        }
    };
    const v16301 = function (element, property) {
        const v16289 = element + '.';
        var key = v16289 + property;
        const v16290 = this.current();
        var own = v16290.own;
        const v16291 = own.hasOwnProperty(key);
        const v16292 = !v16291;
        if (v16292) {
            const v16293 = element + '&&(';
            const v16294 = this.escape(property);
            const v16295 = v16293 + v16294;
            const v16296 = v16295 + ' in ';
            const v16297 = v16296 + element;
            const v16298 = v16297 + ')';
            const v16299 = this.nextId(false, v16298);
            own[key] = v16299;
        }
        const v16300 = own[key];
        return v16300;
    };
    const v16306 = function (id, value) {
        const v16302 = !id;
        if (v16302) {
            return;
        }
        const v16303 = this.current();
        const v16304 = v16303.body;
        const v16305 = v16304.push(id, '=', value, ';');
        v16305;
        return id;
    };
    const v16317 = function (filterName) {
        const v16307 = this.state;
        const v16308 = v16307.filters;
        const v16309 = v16308.hasOwnProperty(filterName);
        const v16310 = !v16309;
        if (v16310) {
            const v16313 = this.nextId(true);
            v16312[filterName] = v16313;
        }
        const v16314 = this.state;
        const v16315 = v16314.filters;
        const v16316 = v16315[filterName];
        return v16316;
    };
    const v16323 = function (id, defaultValue) {
        const v16318 = 'ifDefined(' + id;
        const v16319 = v16318 + ',';
        const v16320 = this.escape(defaultValue);
        const v16321 = v16319 + v16320;
        const v16322 = v16321 + ')';
        return v16322;
    };
    const v16328 = function (left, right) {
        const v16324 = 'plus(' + left;
        const v16325 = v16324 + ',';
        const v16326 = v16325 + right;
        const v16327 = v16326 + ')';
        return v16327;
    };
    const v16332 = function (id) {
        const v16329 = this.current();
        const v16330 = v16329.body;
        const v16331 = v16330.push('return ', id, ';');
        v16331;
    };
    const v16342 = function (test, alternate, consequent) {
        const v16333 = test === true;
        if (v16333) {
            const v16334 = alternate();
            v16334;
        } else {
            const v16335 = this.current();
            var body = v16335.body;
            const v16336 = body.push('if(', test, '){');
            v16336;
            const v16337 = alternate();
            v16337;
            const v16338 = body.push('}');
            v16338;
            if (consequent) {
                const v16339 = body.push('else{');
                v16339;
                const v16340 = consequent();
                v16340;
                const v16341 = body.push('}');
                v16341;
            }
        }
    };
    const v16345 = function (expression) {
        const v16343 = '!(' + expression;
        const v16344 = v16343 + ')';
        return v16344;
    };
    const v16347 = function (expression) {
        const v16346 = expression + '==null';
        return v16346;
    };
    const v16349 = function (expression) {
        const v16348 = expression + '!=null';
        return v16348;
    };
    const v16358 = function (left, right) {
        var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
        var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
        const v16350 = SAFE_IDENTIFIER.test(right);
        if (v16350) {
            const v16351 = left + '.';
            const v16352 = v16351 + right;
            return v16352;
        } else {
            const v16353 = left + '["';
            const v16354 = this.stringEscapeFn;
            const v16355 = right.replace(UNSAFE_CHARACTERS, v16354);
            const v16356 = v16353 + v16355;
            const v16357 = v16356 + '"]';
            return v16357;
        }
    };
    const v16362 = function (left, right) {
        const v16359 = left + '[';
        const v16360 = v16359 + right;
        const v16361 = v16360 + ']';
        return v16361;
    };
    const v16365 = function (left, right, computed) {
        if (computed) {
            const v16363 = this.computedMember(left, right);
            return v16363;
        }
        const v16364 = this.nonComputedMember(left, right);
        return v16364;
    };
    const v16369 = function (item) {
        const v16366 = 'getStringValue(' + item;
        const v16367 = v16366 + ')';
        const v16368 = this.assign(item, v16367);
        v16368;
    };
    const v16372 = function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
        var self = this;
        const v16371 = function () {
            const v16370 = self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
            v16370;
        };
        return v16371;
    };
    const v16375 = function (id, value) {
        var self = this;
        const v16374 = function () {
            const v16373 = self.assign(id, value);
            v16373;
        };
        return v16374;
    };
    const v16382 = function (c) {
        const v16376 = c.charCodeAt(0);
        const v16377 = v16376.toString(16);
        const v16378 = '0000' + v16377;
        const v16379 = -4;
        const v16380 = v16378.slice(v16379);
        const v16381 = '\\u' + v16380;
        return v16381;
    };
    const v16397 = function (value) {
        const v16383 = isString(value);
        if (v16383) {
            const v16384 = this.stringEscapeRegex;
            const v16385 = this.stringEscapeFn;
            const v16386 = value.replace(v16384, v16385);
            const v16387 = '\'' + v16386;
            const v16388 = v16387 + '\'';
            return v16388;
        }
        const v16389 = isNumber(value);
        if (v16389) {
            const v16390 = value.toString();
            return v16390;
        }
        const v16391 = value === true;
        if (v16391) {
            return 'true';
        }
        const v16392 = value === false;
        if (v16392) {
            return 'false';
        }
        const v16393 = value === null;
        if (v16393) {
            return 'null';
        }
        const v16394 = typeof value;
        const v16395 = v16394 === 'undefined';
        if (v16395) {
            return 'undefined';
        }
        const v16396 = $parseMinErr('esc', 'IMPOSSIBLE');
        throw v16396;
    };
    const v16408 = function (skip, init) {
        const v16398 = this.state;
        const v16399 = v16398.nextId;
        const v16400 = v16399++;
        var id = 'v' + v16400;
        const v16401 = !skip;
        if (v16401) {
            const v16402 = this.current();
            const v16403 = v16402.vars;
            const v16404 = '=' + init;
            let v16405;
            if (init) {
                v16405 = v16404;
            } else {
                v16405 = '';
            }
            const v16406 = id + v16405;
            const v16407 = v16403.push(v16406);
            v16407;
        }
        return id;
    };
    const v16413 = function () {
        const v16409 = this.state;
        const v16410 = this.state;
        const v16411 = v16410.computing;
        const v16412 = v16409[v16411];
        return v16412;
    };
    const v16414 = {};
    v16414.compile = v15904;
    v16414.USE = 'use';
    v16414.STRICT = 'strict';
    v16414.watchFns = v15931;
    v16414.generateFunction = v15939;
    v16414.filterPrefix = v15953;
    v16414.varsPrefix = v15965;
    v16414.body = v15970;
    v16414.recurse = v16288;
    v16414.getHasOwnProperty = v16301;
    v16414.assign = v16306;
    v16414.filter = v16317;
    v16414.ifDefined = v16323;
    v16414.plus = v16328;
    v16414.return_ = v16332;
    v16414.if_ = v16342;
    v16414.not = v16345;
    v16414.isNull = v16347;
    v16414.notNull = v16349;
    v16414.nonComputedMember = v16358;
    v16414.computedMember = v16362;
    v16414.member = v16365;
    v16414.getStringValue = v16369;
    v16414.lazyRecurse = v16372;
    v16414.lazyAssign = v16375;
    v16414.stringEscapeRegex = /[^ a-zA-Z0-9]/g;
    v16414.stringEscapeFn = v16382;
    v16414.escape = v16397;
    v16414.nextId = v16408;
    v16414.current = v16413;
    ASTCompiler.prototype = v16414;
    const ASTInterpreter = function ($filter) {
        this.$filter = $filter;
    };
    const v16441 = function (ast) {
        var self = this;
        const v16415 = self.$filter;
        const v16416 = findConstantAndWatchExpressions(ast, v16415);
        v16416;
        var assignable;
        var assign;
        if (assignable = assignableAST(ast)) {
            assign = this.recurse(assignable);
        }
        const v16417 = ast.body;
        var toWatch = getInputs(v16417);
        var inputs;
        if (toWatch) {
            inputs = [];
            const v16420 = function (watch, key) {
                var input = self.recurse(watch);
                const v16418 = watch.isPure;
                input.isPure = v16418;
                watch.input = input;
                const v16419 = inputs.push(input);
                v16419;
                watch.watchId = key;
            };
            const v16421 = forEach(toWatch, v16420);
            v16421;
        }
        var expressions = [];
        const v16422 = ast.body;
        const v16426 = function (expression) {
            const v16423 = expression.expression;
            const v16424 = self.recurse(v16423);
            const v16425 = expressions.push(v16424);
            v16425;
        };
        const v16427 = forEach(v16422, v16426);
        v16427;
        let fn;
        const v16428 = ast.body;
        const v16429 = v16428.length;
        const v16430 = v16429 === 0;
        const v16431 = ast.body;
        const v16432 = v16431.length;
        const v16433 = v16432 === 1;
        const v16434 = expressions[0];
        const v16437 = function (scope, locals) {
            var lastValue;
            const v16435 = function (exp) {
                lastValue = exp(scope, locals);
            };
            const v16436 = forEach(expressions, v16435);
            v16436;
            return lastValue;
        };
        let v16438;
        if (v16433) {
            v16438 = v16434;
        } else {
            v16438 = v16437;
        }
        if (v16430) {
            fn = noop;
        } else {
            fn = v16438;
        }
        if (assign) {
            const v16440 = function (scope, value, locals) {
                const v16439 = assign(scope, locals, value);
                return v16439;
            };
            fn.assign = v16440;
        }
        if (inputs) {
            fn.inputs = inputs;
        }
        return fn;
    };
    const v16600 = function (ast, context, create) {
        var left;
        var right;
        var self = this;
        var args;
        const v16442 = ast.input;
        if (v16442) {
            const v16443 = ast.input;
            const v16444 = ast.watchId;
            const v16445 = this.inputs(v16443, v16444);
            return v16445;
        }
        const v16446 = ast.type;
        const v16447 = AST.Literal;
        const v16448 = AST.UnaryExpression;
        const v16449 = AST.BinaryExpression;
        const v16450 = AST.LogicalExpression;
        const v16451 = AST.ConditionalExpression;
        const v16452 = AST.Identifier;
        const v16453 = AST.MemberExpression;
        const v16454 = AST.CallExpression;
        const v16455 = AST.AssignmentExpression;
        const v16456 = AST.ArrayExpression;
        const v16457 = AST.ObjectExpression;
        const v16458 = AST.ThisExpression;
        const v16459 = AST.LocalsExpression;
        const v16460 = AST.NGValueParameter;
        switch (v16446) {
        case v16447:
            const v16461 = ast.value;
            const v16462 = this.value(v16461, context);
            return v16462;
        case v16448:
            const v16463 = ast.argument;
            right = this.recurse(v16463);
            const v16464 = ast.operator;
            const v16465 = 'unary' + v16464;
            const v16466 = this[v16465](right, context);
            return v16466;
        case v16449:
            const v16467 = ast.left;
            left = this.recurse(v16467);
            const v16468 = ast.right;
            right = this.recurse(v16468);
            const v16469 = ast.operator;
            const v16470 = 'binary' + v16469;
            const v16471 = this[v16470](left, right, context);
            return v16471;
        case v16450:
            const v16472 = ast.left;
            left = this.recurse(v16472);
            const v16473 = ast.right;
            right = this.recurse(v16473);
            const v16474 = ast.operator;
            const v16475 = 'binary' + v16474;
            const v16476 = this[v16475](left, right, context);
            return v16476;
        case v16451:
            const v16477 = ast.test;
            const v16478 = this.recurse(v16477);
            const v16479 = ast.alternate;
            const v16480 = this.recurse(v16479);
            const v16481 = ast.consequent;
            const v16482 = this.recurse(v16481);
            const v16483 = this['ternary?:'](v16478, v16480, v16482, context);
            return v16483;
        case v16452:
            const v16484 = ast.name;
            const v16485 = self.identifier(v16484, context, create);
            return v16485;
        case v16453:
            const v16486 = ast.object;
            const v16487 = !create;
            const v16488 = !v16487;
            left = this.recurse(v16486, false, v16488);
            const v16489 = ast.computed;
            const v16490 = !v16489;
            if (v16490) {
                const v16491 = ast.property;
                right = v16491.name;
            }
            const v16492 = ast.computed;
            if (v16492) {
                const v16493 = ast.property;
                right = this.recurse(v16493);
            }
            const v16494 = ast.computed;
            const v16495 = this.computedMember(left, right, context, create);
            const v16496 = this.nonComputedMember(left, right, context, create);
            let v16497;
            if (v16494) {
                v16497 = v16495;
            } else {
                v16497 = v16496;
            }
            return v16497;
        case v16454:
            args = [];
            const v16498 = ast.arguments;
            const v16501 = function (expr) {
                const v16499 = self.recurse(expr);
                const v16500 = args.push(v16499);
                v16500;
            };
            const v16502 = forEach(v16498, v16501);
            v16502;
            const v16503 = ast.filter;
            if (v16503) {
                const v16504 = ast.callee;
                const v16505 = v16504.name;
                right = this.$filter(v16505);
            }
            const v16506 = ast.filter;
            const v16507 = !v16506;
            if (v16507) {
                const v16508 = ast.callee;
                right = this.recurse(v16508, true);
            }
            const v16509 = ast.filter;
            const v16517 = function (scope, locals, assign, inputs) {
                var values = [];
                var i = 0;
                const v16510 = args.length;
                let v16511 = i < v16510;
                while (v16511) {
                    const v16513 = args[i](scope, locals, assign, inputs);
                    const v16514 = values.push(v16513);
                    v16514;
                    const v16512 = ++i;
                    v16511 = i < v16510;
                }
                var value = right.apply(undefined, values, inputs);
                const v16515 = {
                    context: undefined,
                    name: undefined,
                    value: value
                };
                let v16516;
                if (context) {
                    v16516 = v16515;
                } else {
                    v16516 = value;
                }
                return v16516;
            };
            const v16529 = function (scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                const v16518 = rhs.value;
                const v16519 = v16518 != null;
                if (v16519) {
                    var values = [];
                    var i = 0;
                    const v16520 = args.length;
                    let v16521 = i < v16520;
                    while (v16521) {
                        const v16523 = args[i](scope, locals, assign, inputs);
                        const v16524 = values.push(v16523);
                        v16524;
                        const v16522 = ++i;
                        v16521 = i < v16520;
                    }
                    const v16525 = rhs.value;
                    const v16526 = rhs.context;
                    value = v16525.apply(v16526, values);
                }
                const v16527 = { value: value };
                let v16528;
                if (context) {
                    v16528 = v16527;
                } else {
                    v16528 = value;
                }
                return v16528;
            };
            let v16530;
            if (v16509) {
                v16530 = v16517;
            } else {
                v16530 = v16529;
            }
            return v16530;
        case v16455:
            const v16531 = ast.left;
            left = this.recurse(v16531, true, 1);
            const v16532 = ast.right;
            right = this.recurse(v16532);
            const v16537 = function (scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                const v16533 = lhs.context;
                const v16534 = lhs.name;
                v16533[v16534] = rhs;
                const v16535 = { value: rhs };
                let v16536;
                if (context) {
                    v16536 = v16535;
                } else {
                    v16536 = rhs;
                }
                return v16536;
            };
            return v16537;
        case v16456:
            args = [];
            const v16538 = ast.elements;
            const v16541 = function (expr) {
                const v16539 = self.recurse(expr);
                const v16540 = args.push(v16539);
                v16540;
            };
            const v16542 = forEach(v16538, v16541);
            v16542;
            const v16550 = function (scope, locals, assign, inputs) {
                var value = [];
                var i = 0;
                const v16543 = args.length;
                let v16544 = i < v16543;
                while (v16544) {
                    const v16546 = args[i](scope, locals, assign, inputs);
                    const v16547 = value.push(v16546);
                    v16547;
                    const v16545 = ++i;
                    v16544 = i < v16543;
                }
                const v16548 = { value: value };
                let v16549;
                if (context) {
                    v16549 = v16548;
                } else {
                    v16549 = value;
                }
                return v16549;
            };
            return v16550;
        case v16457:
            args = [];
            const v16551 = ast.properties;
            const v16573 = function (property) {
                const v16552 = property.computed;
                if (v16552) {
                    const v16553 = property.key;
                    const v16554 = self.recurse(v16553);
                    const v16555 = property.value;
                    const v16556 = self.recurse(v16555);
                    const v16557 = {
                        key: v16554,
                        computed: true,
                        value: v16556
                    };
                    const v16558 = args.push(v16557);
                    v16558;
                } else {
                    const v16559 = property.key;
                    const v16560 = v16559.type;
                    const v16561 = AST.Identifier;
                    const v16562 = v16560 === v16561;
                    const v16563 = property.key;
                    const v16564 = v16563.name;
                    const v16565 = property.key;
                    const v16566 = v16565.value;
                    const v16567 = '' + v16566;
                    let v16568;
                    if (v16562) {
                        v16568 = v16564;
                    } else {
                        v16568 = v16567;
                    }
                    const v16569 = property.value;
                    const v16570 = self.recurse(v16569);
                    const v16571 = {
                        key: v16568,
                        computed: false,
                        value: v16570
                    };
                    const v16572 = args.push(v16571);
                    v16572;
                }
            };
            const v16574 = forEach(v16551, v16573);
            v16574;
            const v16590 = function (scope, locals, assign, inputs) {
                var value = {};
                var i = 0;
                const v16575 = args.length;
                let v16576 = i < v16575;
                while (v16576) {
                    const v16578 = args[i];
                    const v16579 = v16578.computed;
                    if (v16579) {
                        const v16582 = args[i];
                        const v16583 = v16582.value(scope, locals, assign, inputs);
                        value[v16581] = v16583;
                    } else {
                        const v16586 = args[i];
                        const v16587 = v16586.value(scope, locals, assign, inputs);
                        value[v16585] = v16587;
                    }
                    const v16577 = ++i;
                    v16576 = i < v16575;
                }
                const v16588 = { value: value };
                let v16589;
                if (context) {
                    v16589 = v16588;
                } else {
                    v16589 = value;
                }
                return v16589;
            };
            return v16590;
        case v16458:
            const v16593 = function (scope) {
                const v16591 = { value: scope };
                let v16592;
                if (context) {
                    v16592 = v16591;
                } else {
                    v16592 = scope;
                }
                return v16592;
            };
            return v16593;
        case v16459:
            const v16596 = function (scope, locals) {
                const v16594 = { value: locals };
                let v16595;
                if (context) {
                    v16595 = v16594;
                } else {
                    v16595 = locals;
                }
                return v16595;
            };
            return v16596;
        case v16460:
            const v16599 = function (scope, locals, assign) {
                const v16597 = { value: assign };
                let v16598;
                if (context) {
                    v16598 = v16597;
                } else {
                    v16598 = assign;
                }
                return v16598;
            };
            return v16599;
        }
    };
    const v16606 = function (argument, context) {
        const v16605 = function (scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            const v16601 = isDefined(arg);
            if (v16601) {
                const v16602 = +arg;
                arg = v16602;
            } else {
                arg = 0;
            }
            const v16603 = { value: arg };
            let v16604;
            if (context) {
                v16604 = v16603;
            } else {
                v16604 = arg;
            }
            return v16604;
        };
        return v16605;
    };
    const v16613 = function (argument, context) {
        const v16612 = function (scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            const v16607 = isDefined(arg);
            if (v16607) {
                const v16608 = -arg;
                arg = v16608;
            } else {
                const v16609 = -0;
                arg = v16609;
            }
            const v16610 = { value: arg };
            let v16611;
            if (context) {
                v16611 = v16610;
            } else {
                v16611 = arg;
            }
            return v16611;
        };
        return v16612;
    };
    const v16619 = function (argument, context) {
        const v16618 = function (scope, locals, assign, inputs) {
            const v16614 = argument(scope, locals, assign, inputs);
            const v16615 = !v16614;
            var arg = v16615;
            const v16616 = { value: arg };
            let v16617;
            if (context) {
                v16617 = v16616;
            } else {
                v16617 = arg;
            }
            return v16617;
        };
        return v16618;
    };
    const v16623 = function (left, right, context) {
        const v16622 = function (scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            const v16620 = { value: arg };
            let v16621;
            if (context) {
                v16621 = v16620;
            } else {
                v16621 = arg;
            }
            return v16621;
        };
        return v16622;
    };
    const v16631 = function (left, right, context) {
        const v16630 = function (scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            const v16624 = isDefined(lhs);
            let v16625;
            if (v16624) {
                v16625 = lhs;
            } else {
                v16625 = 0;
            }
            const v16626 = isDefined(rhs);
            let v16627;
            if (v16626) {
                v16627 = rhs;
            } else {
                v16627 = 0;
            }
            var arg = v16625 - v16627;
            const v16628 = { value: arg };
            let v16629;
            if (context) {
                v16629 = v16628;
            } else {
                v16629 = arg;
            }
            return v16629;
        };
        return v16630;
    };
    const v16637 = function (left, right, context) {
        const v16636 = function (scope, locals, assign, inputs) {
            const v16632 = left(scope, locals, assign, inputs);
            const v16633 = right(scope, locals, assign, inputs);
            var arg = v16632 * v16633;
            const v16634 = { value: arg };
            let v16635;
            if (context) {
                v16635 = v16634;
            } else {
                v16635 = arg;
            }
            return v16635;
        };
        return v16636;
    };
    const v16643 = function (left, right, context) {
        const v16642 = function (scope, locals, assign, inputs) {
            const v16638 = left(scope, locals, assign, inputs);
            const v16639 = right(scope, locals, assign, inputs);
            var arg = v16638 / v16639;
            const v16640 = { value: arg };
            let v16641;
            if (context) {
                v16641 = v16640;
            } else {
                v16641 = arg;
            }
            return v16641;
        };
        return v16642;
    };
    const v16649 = function (left, right, context) {
        const v16648 = function (scope, locals, assign, inputs) {
            const v16644 = left(scope, locals, assign, inputs);
            const v16645 = right(scope, locals, assign, inputs);
            var arg = v16644 % v16645;
            const v16646 = { value: arg };
            let v16647;
            if (context) {
                v16647 = v16646;
            } else {
                v16647 = arg;
            }
            return v16647;
        };
        return v16648;
    };
    const v16655 = function (left, right, context) {
        const v16654 = function (scope, locals, assign, inputs) {
            const v16650 = left(scope, locals, assign, inputs);
            const v16651 = right(scope, locals, assign, inputs);
            var arg = v16650 === v16651;
            const v16652 = { value: arg };
            let v16653;
            if (context) {
                v16653 = v16652;
            } else {
                v16653 = arg;
            }
            return v16653;
        };
        return v16654;
    };
    const v16661 = function (left, right, context) {
        const v16660 = function (scope, locals, assign, inputs) {
            const v16656 = left(scope, locals, assign, inputs);
            const v16657 = right(scope, locals, assign, inputs);
            var arg = v16656 !== v16657;
            const v16658 = { value: arg };
            let v16659;
            if (context) {
                v16659 = v16658;
            } else {
                v16659 = arg;
            }
            return v16659;
        };
        return v16660;
    };
    const v16667 = function (left, right, context) {
        const v16666 = function (scope, locals, assign, inputs) {
            const v16662 = left(scope, locals, assign, inputs);
            const v16663 = right(scope, locals, assign, inputs);
            var arg = v16662 == v16663;
            const v16664 = { value: arg };
            let v16665;
            if (context) {
                v16665 = v16664;
            } else {
                v16665 = arg;
            }
            return v16665;
        };
        return v16666;
    };
    const v16673 = function (left, right, context) {
        const v16672 = function (scope, locals, assign, inputs) {
            const v16668 = left(scope, locals, assign, inputs);
            const v16669 = right(scope, locals, assign, inputs);
            var arg = v16668 != v16669;
            const v16670 = { value: arg };
            let v16671;
            if (context) {
                v16671 = v16670;
            } else {
                v16671 = arg;
            }
            return v16671;
        };
        return v16672;
    };
    const v16679 = function (left, right, context) {
        const v16678 = function (scope, locals, assign, inputs) {
            const v16674 = left(scope, locals, assign, inputs);
            const v16675 = right(scope, locals, assign, inputs);
            var arg = v16674 < v16675;
            const v16676 = { value: arg };
            let v16677;
            if (context) {
                v16677 = v16676;
            } else {
                v16677 = arg;
            }
            return v16677;
        };
        return v16678;
    };
    const v16685 = function (left, right, context) {
        const v16684 = function (scope, locals, assign, inputs) {
            const v16680 = left(scope, locals, assign, inputs);
            const v16681 = right(scope, locals, assign, inputs);
            var arg = v16680 > v16681;
            const v16682 = { value: arg };
            let v16683;
            if (context) {
                v16683 = v16682;
            } else {
                v16683 = arg;
            }
            return v16683;
        };
        return v16684;
    };
    const v16691 = function (left, right, context) {
        const v16690 = function (scope, locals, assign, inputs) {
            const v16686 = left(scope, locals, assign, inputs);
            const v16687 = right(scope, locals, assign, inputs);
            var arg = v16686 <= v16687;
            const v16688 = { value: arg };
            let v16689;
            if (context) {
                v16689 = v16688;
            } else {
                v16689 = arg;
            }
            return v16689;
        };
        return v16690;
    };
    const v16697 = function (left, right, context) {
        const v16696 = function (scope, locals, assign, inputs) {
            const v16692 = left(scope, locals, assign, inputs);
            const v16693 = right(scope, locals, assign, inputs);
            var arg = v16692 >= v16693;
            const v16694 = { value: arg };
            let v16695;
            if (context) {
                v16695 = v16694;
            } else {
                v16695 = arg;
            }
            return v16695;
        };
        return v16696;
    };
    const v16703 = function (left, right, context) {
        const v16702 = function (scope, locals, assign, inputs) {
            const v16698 = left(scope, locals, assign, inputs);
            const v16699 = right(scope, locals, assign, inputs);
            var arg = v16698 && v16699;
            const v16700 = { value: arg };
            let v16701;
            if (context) {
                v16701 = v16700;
            } else {
                v16701 = arg;
            }
            return v16701;
        };
        return v16702;
    };
    const v16709 = function (left, right, context) {
        const v16708 = function (scope, locals, assign, inputs) {
            const v16704 = left(scope, locals, assign, inputs);
            const v16705 = right(scope, locals, assign, inputs);
            var arg = v16704 || v16705;
            const v16706 = { value: arg };
            let v16707;
            if (context) {
                v16707 = v16706;
            } else {
                v16707 = arg;
            }
            return v16707;
        };
        return v16708;
    };
    const v16716 = function (test, alternate, consequent, context) {
        const v16715 = function (scope, locals, assign, inputs) {
            let arg;
            const v16710 = test(scope, locals, assign, inputs);
            const v16711 = alternate(scope, locals, assign, inputs);
            const v16712 = consequent(scope, locals, assign, inputs);
            if (v16710) {
                arg = v16711;
            } else {
                arg = v16712;
            }
            const v16713 = { value: arg };
            let v16714;
            if (context) {
                v16714 = v16713;
            } else {
                v16714 = arg;
            }
            return v16714;
        };
        return v16715;
    };
    const v16720 = function (value, context) {
        const v16719 = function () {
            const v16717 = {
                context: undefined,
                name: undefined,
                value: value
            };
            let v16718;
            if (context) {
                v16718 = v16717;
            } else {
                v16718 = value;
            }
            return v16718;
        };
        return v16719;
    };
    const v16733 = function (name, context, create) {
        const v16732 = function (scope, locals, assign, inputs) {
            let base;
            const v16721 = name in locals;
            const v16722 = locals && v16721;
            if (v16722) {
                base = locals;
            } else {
                base = scope;
            }
            const v16723 = create !== 1;
            const v16724 = create && v16723;
            const v16725 = v16724 && base;
            const v16726 = base[name];
            const v16727 = v16726 == null;
            const v16728 = v16725 && v16727;
            if (v16728) {
                const v16729 = {};
                base[name] = v16729;
            }
            let value;
            const v16730 = base[name];
            if (base) {
                value = v16730;
            } else {
                value = undefined;
            }
            if (context) {
                const v16731 = {};
                v16731.context = base;
                v16731.name = name;
                v16731.value = value;
                return v16731;
            } else {
                return value;
            }
        };
        return v16732;
    };
    const v16743 = function (left, right, context, create) {
        const v16742 = function (scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            const v16734 = lhs != null;
            if (v16734) {
                rhs = right(scope, locals, assign, inputs);
                rhs = getStringValue(rhs);
                const v16735 = create !== 1;
                const v16736 = create && v16735;
                if (v16736) {
                    const v16737 = lhs[rhs];
                    const v16738 = !v16737;
                    const v16739 = lhs && v16738;
                    if (v16739) {
                        const v16740 = {};
                        lhs[rhs] = v16740;
                    }
                }
                value = lhs[rhs];
            }
            if (context) {
                const v16741 = {};
                v16741.context = lhs;
                v16741.name = rhs;
                v16741.value = value;
                return v16741;
            } else {
                return value;
            }
        };
        return v16742;
    };
    const v16754 = function (left, right, context, create) {
        const v16753 = function (scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            const v16744 = create !== 1;
            const v16745 = create && v16744;
            if (v16745) {
                const v16746 = lhs[right];
                const v16747 = v16746 == null;
                const v16748 = lhs && v16747;
                if (v16748) {
                    const v16749 = {};
                    lhs[right] = v16749;
                }
            }
            let value;
            const v16750 = lhs != null;
            const v16751 = lhs[right];
            if (v16750) {
                value = v16751;
            } else {
                value = undefined;
            }
            if (context) {
                const v16752 = {};
                v16752.context = lhs;
                v16752.name = right;
                v16752.value = value;
                return v16752;
            } else {
                return value;
            }
        };
        return v16753;
    };
    const v16758 = function (input, watchId) {
        const v16757 = function (scope, value, locals, inputs) {
            if (inputs) {
                const v16755 = inputs[watchId];
                return v16755;
            }
            const v16756 = input(scope, value, locals);
            return v16756;
        };
        return v16757;
    };
    const v16759 = {};
    v16759.compile = v16441;
    v16759.recurse = v16600;
    v16759['unary+'] = v16606;
    v16759['unary-'] = v16613;
    v16759['unary!'] = v16619;
    v16759['binary+'] = v16623;
    v16759['binary-'] = v16631;
    v16759['binary*'] = v16637;
    v16759['binary/'] = v16643;
    v16759['binary%'] = v16649;
    v16759['binary==='] = v16655;
    v16759['binary!=='] = v16661;
    v16759['binary=='] = v16667;
    v16759['binary!='] = v16673;
    v16759['binary<'] = v16679;
    v16759['binary>'] = v16685;
    v16759['binary<='] = v16691;
    v16759['binary>='] = v16697;
    v16759['binary&&'] = v16703;
    v16759['binary||'] = v16709;
    v16759['ternary?:'] = v16716;
    v16759.value = v16720;
    v16759.identifier = v16733;
    v16759.computedMember = v16743;
    v16759.nonComputedMember = v16754;
    v16759.inputs = v16758;
    ASTInterpreter.prototype = v16759;
    const Parser = function (lexer, $filter, options) {
        this.ast = new AST(lexer, options);
        const v16760 = options.csp;
        const v16761 = new ASTInterpreter($filter);
        const v16762 = new ASTCompiler($filter);
        let v16763;
        if (v16760) {
            v16763 = v16761;
        } else {
            v16763 = v16762;
        }
        this.astCompiler = v16763;
    };
    const v16771 = function (text) {
        var ast = this.getAst(text);
        const v16764 = this.astCompiler;
        const v16765 = ast.ast;
        var fn = v16764.compile(v16765);
        const v16766 = ast.ast;
        const v16767 = isLiteral(v16766);
        fn.literal = v16767;
        const v16768 = ast.ast;
        const v16769 = isConstant(v16768);
        fn.constant = v16769;
        const v16770 = ast.oneTime;
        fn.oneTime = v16770;
        return fn;
    };
    const v16780 = function (exp) {
        var oneTime = false;
        exp = exp.trim();
        const v16772 = exp.charAt(0);
        const v16773 = v16772 === ':';
        const v16774 = exp.charAt(1);
        const v16775 = v16774 === ':';
        const v16776 = v16773 && v16775;
        if (v16776) {
            oneTime = true;
            exp = exp.substring(2);
        }
        const v16777 = this.ast;
        const v16778 = v16777.ast(exp);
        const v16779 = {};
        v16779.ast = v16778;
        v16779.oneTime = oneTime;
        return v16779;
    };
    const v16781 = {};
    v16781.constructor = Parser;
    v16781.parse = v16771;
    v16781.getAst = v16780;
    Parser.prototype = v16781;
    const getValueOf = function (value) {
        const v16782 = value.valueOf;
        const v16783 = isFunction(v16782);
        const v16784 = value.valueOf();
        const v16785 = objectValueOf.call(value);
        let v16786;
        if (v16783) {
            v16786 = v16784;
        } else {
            v16786 = v16785;
        }
        return v16786;
    };
    const $ParseProvider = function () {
        var cache = createMap();
        var literals = {};
        literals['true'] = true;
        literals['false'] = false;
        literals['null'] = null;
        literals['undefined'] = undefined;
        var identStart;
        var identContinue;
        const v16787 = function (literalName, literalValue) {
            literals[literalName] = literalValue;
        };
        this.addLiteral = v16787;
        const v16788 = function (identifierStart, identifierContinue) {
            identStart = identifierStart;
            identContinue = identifierContinue;
            return this;
        };
        this.setIdentifierFns = v16788;
        const v16902 = function ($filter) {
            const v16789 = csp();
            var noUnsafeEval = v16789.noUnsafeEval;
            const v16790 = copy(literals);
            const v16791 = isFunction(identStart);
            const v16792 = v16791 && identStart;
            const v16793 = isFunction(identContinue);
            const v16794 = v16793 && identContinue;
            var $parseOptions = {};
            $parseOptions.csp = noUnsafeEval;
            $parseOptions.literals = v16790;
            $parseOptions.isIdentifierStart = v16792;
            $parseOptions.isIdentifierContinue = v16794;
            $parse.$$getAst = $$getAst;
            return $parse;
            const $parse = function (exp, interceptorFn) {
                var parsedExpression;
                var cacheKey;
                const v16795 = typeof exp;
                switch (v16795) {
                case 'string':
                    exp = exp.trim();
                    cacheKey = exp;
                    parsedExpression = cache[cacheKey];
                    const v16796 = !parsedExpression;
                    if (v16796) {
                        var lexer = new Lexer($parseOptions);
                        var parser = new Parser(lexer, $filter, $parseOptions);
                        parsedExpression = parser.parse(exp);
                        const v16797 = addWatchDelegate(parsedExpression);
                        cache[cacheKey] = v16797;
                    }
                    const v16798 = addInterceptor(parsedExpression, interceptorFn);
                    return v16798;
                case 'function':
                    const v16799 = addInterceptor(exp, interceptorFn);
                    return v16799;
                default:
                    const v16800 = addInterceptor(noop, interceptorFn);
                    return v16800;
                }
            };
            const $$getAst = function (exp) {
                var lexer = new Lexer($parseOptions);
                var parser = new Parser(lexer, $filter, $parseOptions);
                const v16801 = parser.getAst(exp);
                const v16802 = v16801.ast;
                return v16802;
            };
            const expressionInputDirtyCheck = function (newValue, oldValueOfValue, compareObjectIdentity) {
                const v16803 = newValue == null;
                const v16804 = oldValueOfValue == null;
                const v16805 = v16803 || v16804;
                if (v16805) {
                    const v16806 = newValue === oldValueOfValue;
                    return v16806;
                }
                const v16807 = typeof newValue;
                const v16808 = v16807 === 'object';
                if (v16808) {
                    newValue = getValueOf(newValue);
                    const v16809 = typeof newValue;
                    const v16810 = v16809 === 'object';
                    const v16811 = !compareObjectIdentity;
                    const v16812 = v16810 && v16811;
                    if (v16812) {
                        return false;
                    }
                }
                const v16813 = newValue === oldValueOfValue;
                const v16814 = newValue !== newValue;
                const v16815 = oldValueOfValue !== oldValueOfValue;
                const v16816 = v16814 && v16815;
                const v16817 = v16813 || v16816;
                return v16817;
            };
            const inputsWatchDelegate = function (scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var inputExpressions = parsedExpression.inputs;
                var lastResult;
                const v16818 = inputExpressions.length;
                const v16819 = v16818 === 1;
                if (v16819) {
                    var oldInputValueOf = expressionInputDirtyCheck;
                    inputExpressions = inputExpressions[0];
                    const v16825 = function expressionInputWatch(scope) {
                        var newInputValue = inputExpressions(scope);
                        const v16820 = inputExpressions.isPure;
                        const v16821 = expressionInputDirtyCheck(newInputValue, oldInputValueOf, v16820);
                        const v16822 = !v16821;
                        if (v16822) {
                            const v16823 = [newInputValue];
                            lastResult = parsedExpression(scope, undefined, undefined, v16823);
                            const v16824 = getValueOf(newInputValue);
                            oldInputValueOf = newInputValue && v16824;
                        }
                        return lastResult;
                    };
                    const v16826 = scope.$watch(v16825, listener, objectEquality, prettyPrintExpression);
                    return v16826;
                }
                var oldInputValueOfValues = [];
                var oldInputValues = [];
                var i = 0;
                var ii = inputExpressions.length;
                let v16827 = i < ii;
                while (v16827) {
                    oldInputValueOfValues[i] = expressionInputDirtyCheck;
                    oldInputValues[i] = null;
                    const v16828 = i++;
                    v16827 = i < ii;
                }
                const v16838 = function expressionInputsWatch(scope) {
                    var changed = false;
                    var i = 0;
                    var ii = inputExpressions.length;
                    let v16829 = i < ii;
                    while (v16829) {
                        var newInputValue = inputExpressions[i](scope);
                        const v16831 = oldInputValueOfValues[i];
                        const v16832 = inputExpressions[i];
                        const v16833 = v16832.isPure;
                        const v16834 = expressionInputDirtyCheck(newInputValue, v16831, v16833);
                        const v16835 = !v16834;
                        const v16836 = changed || (changed = v16835);
                        if (v16836) {
                            oldInputValues[i] = newInputValue;
                            const v16837 = getValueOf(newInputValue);
                            oldInputValueOfValues[i] = newInputValue && v16837;
                        }
                        const v16830 = i++;
                        v16829 = i < ii;
                    }
                    if (changed) {
                        lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
                    }
                    return lastResult;
                };
                const v16839 = scope.$watch(v16838, listener, objectEquality, prettyPrintExpression);
                return v16839;
            };
            const oneTimeWatchDelegate = function (scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                let isDone;
                const v16840 = parsedExpression.literal;
                if (v16840) {
                    isDone = isAllDefined;
                } else {
                    isDone = isDefined;
                }
                var unwatch;
                var lastValue;
                const v16841 = parsedExpression.$$intercepted;
                var exp = v16841 || parsedExpression;
                const v16842 = parsedExpression.$$interceptor;
                var post = v16842 || identity;
                const v16843 = parsedExpression.inputs;
                const v16844 = exp.inputs;
                const v16845 = !v16844;
                var useInputs = v16843 && v16845;
                const v16846 = parsedExpression.literal;
                oneTimeWatch.literal = v16846;
                const v16847 = parsedExpression.constant;
                oneTimeWatch.constant = v16847;
                const v16848 = parsedExpression.inputs;
                oneTimeWatch.inputs = v16848;
                const v16849 = addWatchDelegate(oneTimeWatch);
                v16849;
                unwatch = scope.$watch(oneTimeWatch, listener, objectEquality, prettyPrintExpression);
                return unwatch;
                const unwatchIfDone = function () {
                    const v16850 = isDone(lastValue);
                    if (v16850) {
                        const v16851 = unwatch();
                        v16851;
                    }
                };
                const oneTimeWatch = function (scope, locals, assign, inputs) {
                    const v16852 = useInputs && inputs;
                    const v16853 = inputs[0];
                    const v16854 = exp(scope, locals, assign, inputs);
                    if (v16852) {
                        lastValue = v16853;
                    } else {
                        lastValue = v16854;
                    }
                    const v16855 = isDone(lastValue);
                    if (v16855) {
                        const v16856 = scope.$$postDigest(unwatchIfDone);
                        v16856;
                    }
                    const v16857 = post(lastValue);
                    return v16857;
                };
            };
            const isAllDefined = function (value) {
                var allDefined = true;
                const v16860 = function (val) {
                    const v16858 = isDefined(val);
                    const v16859 = !v16858;
                    if (v16859) {
                        allDefined = false;
                    }
                };
                const v16861 = forEach(value, v16860);
                v16861;
                return allDefined;
            };
            const constantWatchDelegate = function (scope, listener, objectEquality, parsedExpression) {
                const v16864 = function constantWatch(scope) {
                    const v16862 = unwatch();
                    v16862;
                    const v16863 = parsedExpression(scope);
                    return v16863;
                };
                var unwatch = scope.$watch(v16864, listener, objectEquality);
                return unwatch;
            };
            const addWatchDelegate = function (parsedExpression) {
                const v16865 = parsedExpression.constant;
                if (v16865) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                } else {
                    const v16866 = parsedExpression.oneTime;
                    if (v16866) {
                        parsedExpression.$$watchDelegate = oneTimeWatchDelegate;
                    } else {
                        const v16867 = parsedExpression.inputs;
                        if (v16867) {
                            parsedExpression.$$watchDelegate = inputsWatchDelegate;
                        }
                    }
                }
                return parsedExpression;
            };
            const chainInterceptors = function (first, second) {
                const chainedInterceptor = function (value) {
                    const v16868 = first(value);
                    const v16869 = second(v16868);
                    return v16869;
                };
                const v16870 = first.$stateful;
                const v16871 = second.$stateful;
                chainedInterceptor.$stateful = v16870 || v16871;
                const v16872 = first.$$pure;
                const v16873 = second.$$pure;
                chainedInterceptor.$$pure = v16872 && v16873;
                return chainedInterceptor;
            };
            const addInterceptor = function (parsedExpression, interceptorFn) {
                const v16874 = !interceptorFn;
                if (v16874) {
                    return parsedExpression;
                }
                const v16875 = parsedExpression.$$interceptor;
                if (v16875) {
                    const v16876 = parsedExpression.$$interceptor;
                    interceptorFn = chainInterceptors(v16876, interceptorFn);
                    parsedExpression = parsedExpression.$$intercepted;
                }
                var useInputs = false;
                var fn = function interceptedExpression(scope, locals, assign, inputs) {
                    let value;
                    const v16877 = useInputs && inputs;
                    const v16878 = inputs[0];
                    const v16879 = parsedExpression(scope, locals, assign, inputs);
                    if (v16877) {
                        value = v16878;
                    } else {
                        value = v16879;
                    }
                    const v16880 = interceptorFn(value);
                    return v16880;
                };
                fn.$$intercepted = parsedExpression;
                fn.$$interceptor = interceptorFn;
                const v16881 = parsedExpression.literal;
                fn.literal = v16881;
                const v16882 = parsedExpression.oneTime;
                fn.oneTime = v16882;
                const v16883 = parsedExpression.constant;
                fn.constant = v16883;
                const v16884 = interceptorFn.$stateful;
                const v16885 = !v16884;
                if (v16885) {
                    const v16886 = parsedExpression.inputs;
                    const v16887 = !v16886;
                    useInputs = v16887;
                    const v16888 = parsedExpression.inputs;
                    const v16889 = parsedExpression.inputs;
                    const v16890 = [parsedExpression];
                    let v16891;
                    if (v16888) {
                        v16891 = v16889;
                    } else {
                        v16891 = v16890;
                    }
                    fn.inputs = v16891;
                    const v16892 = interceptorFn.$$pure;
                    const v16893 = !v16892;
                    if (v16893) {
                        const v16894 = fn.inputs;
                        const v16899 = function (e) {
                            const v16895 = e.isPure;
                            const v16896 = v16895 === PURITY_RELATIVE;
                            if (v16896) {
                                const v16898 = function depurifier(s) {
                                    const v16897 = e(s);
                                    return v16897;
                                };
                                return v16898;
                            }
                            return e;
                        };
                        const v16900 = v16894.map(v16899);
                        fn.inputs = v16900;
                    }
                }
                const v16901 = addWatchDelegate(fn);
                return v16901;
            };
        };
        this.$get = [
            '$filter',
            v16902
        ];
    };
    const $QProvider = function () {
        var errorOnUnhandledRejections = true;
        const v16906 = function ($rootScope, $exceptionHandler) {
            const v16904 = function (callback) {
                const v16903 = $rootScope.$evalAsync(callback);
                v16903;
            };
            const v16905 = qFactory(v16904, $exceptionHandler, errorOnUnhandledRejections);
            return v16905;
        };
        this.$get = [
            '$rootScope',
            '$exceptionHandler',
            v16906
        ];
        const v16908 = function (value) {
            const v16907 = isDefined(value);
            if (v16907) {
                errorOnUnhandledRejections = value;
                return this;
            } else {
                return errorOnUnhandledRejections;
            }
        };
        this.errorOnUnhandledRejections = v16908;
    };
    const $$QProvider = function () {
        var errorOnUnhandledRejections = true;
        const v16912 = function ($browser, $exceptionHandler) {
            const v16910 = function (callback) {
                const v16909 = $browser.defer(callback);
                v16909;
            };
            const v16911 = qFactory(v16910, $exceptionHandler, errorOnUnhandledRejections);
            return v16911;
        };
        this.$get = [
            '$browser',
            '$exceptionHandler',
            v16912
        ];
        const v16914 = function (value) {
            const v16913 = isDefined(value);
            if (v16913) {
                errorOnUnhandledRejections = value;
                return this;
            } else {
                return errorOnUnhandledRejections;
            }
        };
        this.errorOnUnhandledRejections = v16914;
    };
    const qFactory = function (nextTick, exceptionHandler, errorOnUnhandledRejections) {
        var $qMinErr = minErr('$q', TypeError);
        var queueSize = 0;
        var checkQueue = [];
        const defer = function () {
            const v16915 = new Deferred();
            return v16915;
        };
        const Deferred = function () {
            this.promise = new Promise();
            var promise = this.promise;
            const v16917 = function (val) {
                const v16916 = resolvePromise(promise, val);
                v16916;
            };
            this.resolve = v16917;
            const v16919 = function (reason) {
                const v16918 = rejectPromise(promise, reason);
                v16918;
            };
            this.reject = v16919;
            const v16921 = function (progress) {
                const v16920 = notifyPromise(promise, progress);
                v16920;
            };
            this.notify = v16921;
        };
        const Promise = function () {
            const v16922 = {};
            v16922.status = 0;
            this.$$state = v16922;
        };
        const v16923 = Promise.prototype;
        const v16942 = function (onFulfilled, onRejected, progressBack) {
            const v16924 = isUndefined(onFulfilled);
            const v16925 = isUndefined(onRejected);
            const v16926 = v16924 && v16925;
            const v16927 = isUndefined(progressBack);
            const v16928 = v16926 && v16927;
            if (v16928) {
                return this;
            }
            var result = new Promise();
            const v16929 = this.$$state;
            const v16930 = this.$$state;
            const v16931 = v16930.pending;
            const v16932 = [];
            v16929.pending = v16931 || v16932;
            const v16933 = this.$$state;
            const v16934 = v16933.pending;
            const v16935 = [
                result,
                onFulfilled,
                onRejected,
                progressBack
            ];
            const v16936 = v16934.push(v16935);
            v16936;
            const v16937 = this.$$state;
            const v16938 = v16937.status;
            const v16939 = v16938 > 0;
            if (v16939) {
                const v16940 = this.$$state;
                const v16941 = scheduleProcessQueue(v16940);
                v16941;
            }
            return result;
        };
        const v16944 = function (callback) {
            const v16943 = this.then(null, callback);
            return v16943;
        };
        const v16950 = function (callback, progressBack) {
            const v16946 = function (value) {
                const v16945 = handleCallback(value, resolve, callback);
                return v16945;
            };
            const v16948 = function (error) {
                const v16947 = handleCallback(error, reject, callback);
                return v16947;
            };
            const v16949 = this.then(v16946, v16948, progressBack);
            return v16949;
        };
        const v16951 = {
            then: v16942,
            'catch': v16944,
            'finally': v16950
        };
        const v16952 = extend(v16923, v16951);
        v16952;
        const processQueue = function (state) {
            var fn;
            var promise;
            var pending;
            pending = state.pending;
            state.processScheduled = false;
            state.pending = undefined;
            try {
                var i = 0;
                var ii = pending.length;
                let v16953 = i < ii;
                while (v16953) {
                    const v16955 = markQStateExceptionHandled(state);
                    v16955;
                    const v16956 = pending[i];
                    promise = v16956[0];
                    const v16957 = pending[i];
                    const v16958 = state.status;
                    fn = v16957[v16958];
                    try {
                        const v16959 = isFunction(fn);
                        if (v16959) {
                            const v16960 = state.value;
                            const v16961 = fn(v16960);
                            const v16962 = resolvePromise(promise, v16961);
                            v16962;
                        } else {
                            const v16963 = state.status;
                            const v16964 = v16963 === 1;
                            if (v16964) {
                                const v16965 = state.value;
                                const v16966 = resolvePromise(promise, v16965);
                                v16966;
                            } else {
                                const v16967 = state.value;
                                const v16968 = rejectPromise(promise, v16967);
                                v16968;
                            }
                        }
                    } catch (e) {
                        const v16969 = rejectPromise(promise, e);
                        v16969;
                        const v16970 = e.$$passToExceptionHandler;
                        const v16971 = v16970 === true;
                        const v16972 = e && v16971;
                        if (v16972) {
                            const v16973 = exceptionHandler(e);
                            v16973;
                        }
                    }
                    const v16954 = ++i;
                    v16953 = i < ii;
                }
            } finally {
                const v16974 = --queueSize;
                v16974;
                const v16975 = queueSize === 0;
                const v16976 = errorOnUnhandledRejections && v16975;
                if (v16976) {
                    const v16977 = nextTick(processChecks);
                    v16977;
                }
            }
        };
        const processChecks = function () {
            const v16978 = !queueSize;
            const v16979 = checkQueue.length;
            let v16980 = v16978 && v16979;
            while (v16980) {
                var toCheck = checkQueue.shift();
                const v16981 = isStateExceptionHandled(toCheck);
                const v16982 = !v16981;
                if (v16982) {
                    const v16983 = markQStateExceptionHandled(toCheck);
                    v16983;
                    const v16984 = toCheck.value;
                    const v16985 = toDebugString(v16984);
                    var errorMessage = 'Possibly unhandled rejection: ' + v16985;
                    const v16986 = toCheck.value;
                    const v16987 = isError(v16986);
                    if (v16987) {
                        const v16988 = toCheck.value;
                        const v16989 = exceptionHandler(v16988, errorMessage);
                        v16989;
                    } else {
                        const v16990 = exceptionHandler(errorMessage);
                        v16990;
                    }
                }
                v16980 = v16978 && v16979;
            }
        };
        const scheduleProcessQueue = function (state) {
            const v16991 = state.pending;
            const v16992 = !v16991;
            const v16993 = errorOnUnhandledRejections && v16992;
            const v16994 = state.status;
            const v16995 = v16994 === 2;
            const v16996 = v16993 && v16995;
            const v16997 = isStateExceptionHandled(state);
            const v16998 = !v16997;
            const v16999 = v16996 && v16998;
            if (v16999) {
                const v17000 = queueSize === 0;
                const v17001 = checkQueue.length;
                const v17002 = v17001 === 0;
                const v17003 = v17000 && v17002;
                if (v17003) {
                    const v17004 = nextTick(processChecks);
                    v17004;
                }
                const v17005 = checkQueue.push(state);
                v17005;
            }
            const v17006 = state.processScheduled;
            const v17007 = state.pending;
            const v17008 = !v17007;
            const v17009 = v17006 || v17008;
            if (v17009) {
                return;
            }
            state.processScheduled = true;
            const v17010 = ++queueSize;
            v17010;
            const v17012 = function () {
                const v17011 = processQueue(state);
                v17011;
            };
            const v17013 = nextTick(v17012);
            v17013;
        };
        const resolvePromise = function (promise, val) {
            const v17014 = promise.$$state;
            const v17015 = v17014.status;
            if (v17015) {
                return;
            }
            const v17016 = val === promise;
            if (v17016) {
                const v17017 = $qMinErr('qcycle', 'Expected promise to be resolved with value other than itself \'{0}\'', val);
                const v17018 = $$reject(promise, v17017);
                v17018;
            } else {
                const v17019 = $$resolve(promise, val);
                v17019;
            }
        };
        const $$resolve = function (promise, val) {
            var then;
            var done = false;
            try {
                const v17020 = isObject(val);
                const v17021 = isFunction(val);
                const v17022 = v17020 || v17021;
                if (v17022) {
                    then = val.then;
                }
                const v17023 = isFunction(then);
                if (v17023) {
                    const v17024 = promise.$$state;
                    const v17025 = -1;
                    v17024.status = v17025;
                    const v17026 = then.call(val, doResolve, doReject, doNotify);
                    v17026;
                } else {
                    const v17027 = promise.$$state;
                    v17027.value = val;
                    const v17028 = promise.$$state;
                    v17028.status = 1;
                    const v17029 = promise.$$state;
                    const v17030 = scheduleProcessQueue(v17029);
                    v17030;
                }
            } catch (e) {
                const v17031 = doReject(e);
                v17031;
            }
            const doResolve = function (val) {
                if (done) {
                    return;
                }
                done = true;
                const v17032 = $$resolve(promise, val);
                v17032;
            };
            const doReject = function (val) {
                if (done) {
                    return;
                }
                done = true;
                const v17033 = $$reject(promise, val);
                v17033;
            };
            const doNotify = function (progress) {
                const v17034 = notifyPromise(promise, progress);
                v17034;
            };
        };
        const rejectPromise = function (promise, reason) {
            const v17035 = promise.$$state;
            const v17036 = v17035.status;
            if (v17036) {
                return;
            }
            const v17037 = $$reject(promise, reason);
            v17037;
        };
        const $$reject = function (promise, reason) {
            const v17038 = promise.$$state;
            v17038.value = reason;
            const v17039 = promise.$$state;
            v17039.status = 2;
            const v17040 = promise.$$state;
            const v17041 = scheduleProcessQueue(v17040);
            v17041;
        };
        const notifyPromise = function (promise, progress) {
            const v17042 = promise.$$state;
            var callbacks = v17042.pending;
            const v17043 = promise.$$state;
            const v17044 = v17043.status;
            const v17045 = v17044 <= 0;
            const v17046 = v17045 && callbacks;
            const v17047 = callbacks.length;
            const v17048 = v17046 && v17047;
            if (v17048) {
                const v17058 = function () {
                    var callback;
                    var result;
                    var i = 0;
                    var ii = callbacks.length;
                    let v17049 = i < ii;
                    while (v17049) {
                        const v17051 = callbacks[i];
                        result = v17051[0];
                        const v17052 = callbacks[i];
                        callback = v17052[3];
                        try {
                            const v17053 = isFunction(callback);
                            const v17054 = callback(progress);
                            let v17055;
                            if (v17053) {
                                v17055 = v17054;
                            } else {
                                v17055 = progress;
                            }
                            const v17056 = notifyPromise(result, v17055);
                            v17056;
                        } catch (e) {
                            const v17057 = exceptionHandler(e);
                            v17057;
                        }
                        const v17050 = i++;
                        v17049 = i < ii;
                    }
                };
                const v17059 = nextTick(v17058);
                v17059;
            }
        };
        const reject = function (reason) {
            var result = new Promise();
            const v17060 = rejectPromise(result, reason);
            v17060;
            return result;
        };
        const handleCallback = function (value, resolver, callback) {
            var callbackOutput = null;
            try {
                const v17061 = isFunction(callback);
                if (v17061) {
                    callbackOutput = callback();
                }
            } catch (e) {
                const v17062 = reject(e);
                return v17062;
            }
            const v17063 = isPromiseLike(callbackOutput);
            if (v17063) {
                const v17065 = function () {
                    const v17064 = resolver(value);
                    return v17064;
                };
                const v17066 = callbackOutput.then(v17065, reject);
                return v17066;
            } else {
                const v17067 = resolver(value);
                return v17067;
            }
        };
        const when = function (value, callback, errback, progressBack) {
            var result = new Promise();
            const v17068 = resolvePromise(result, value);
            v17068;
            const v17069 = result.then(callback, errback, progressBack);
            return v17069;
        };
        var resolve = when;
        const all = function (promises) {
            var result = new Promise();
            var counter = 0;
            let results;
            const v17070 = isArray(promises);
            const v17071 = [];
            const v17072 = {};
            if (v17070) {
                results = v17071;
            } else {
                results = v17072;
            }
            const v17082 = function (promise, key) {
                const v17073 = counter++;
                v17073;
                const v17074 = when(promise);
                const v17078 = function (value) {
                    results[key] = value;
                    const v17075 = --counter;
                    const v17076 = !v17075;
                    if (v17076) {
                        const v17077 = resolvePromise(result, results);
                        v17077;
                    }
                };
                const v17080 = function (reason) {
                    const v17079 = rejectPromise(result, reason);
                    v17079;
                };
                const v17081 = v17074.then(v17078, v17080);
                v17081;
            };
            const v17083 = forEach(promises, v17082);
            v17083;
            const v17084 = counter === 0;
            if (v17084) {
                const v17085 = resolvePromise(result, results);
                v17085;
            }
            return result;
        };
        const race = function (promises) {
            var deferred = defer();
            const v17090 = function (promise) {
                const v17086 = when(promise);
                const v17087 = deferred.resolve;
                const v17088 = deferred.reject;
                const v17089 = v17086.then(v17087, v17088);
                v17089;
            };
            const v17091 = forEach(promises, v17090);
            v17091;
            const v17092 = deferred.promise;
            return v17092;
        };
        const $Q = function (resolver) {
            const v17093 = isFunction(resolver);
            const v17094 = !v17093;
            if (v17094) {
                const v17095 = $qMinErr('norslvr', 'Expected resolverFn, got \'{0}\'', resolver);
                throw v17095;
            }
            var promise = new Promise();
            const resolveFn = function (value) {
                const v17096 = resolvePromise(promise, value);
                v17096;
            };
            const rejectFn = function (reason) {
                const v17097 = rejectPromise(promise, reason);
                v17097;
            };
            const v17098 = resolver(resolveFn, rejectFn);
            v17098;
            return promise;
        };
        const v17099 = Promise.prototype;
        $Q.prototype = v17099;
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        $Q.race = race;
        return $Q;
    };
    const isStateExceptionHandled = function (state) {
        const v17100 = state.pur;
        const v17101 = !v17100;
        const v17102 = !v17101;
        return v17102;
    };
    const markQStateExceptionHandled = function (state) {
        state.pur = true;
    };
    const markQExceptionHandled = function (q) {
        const v17103 = q.$$state;
        if (v17103) {
            const v17104 = q.$$state;
            const v17105 = markQStateExceptionHandled(v17104);
            v17105;
        }
    };
    const $$RAFProvider = function () {
        const v17120 = function ($window, $timeout) {
            const v17106 = $window.requestAnimationFrame;
            const v17107 = $window.webkitRequestAnimationFrame;
            var requestAnimationFrame = v17106 || v17107;
            const v17108 = $window.cancelAnimationFrame;
            const v17109 = $window.webkitCancelAnimationFrame;
            const v17110 = v17108 || v17109;
            const v17111 = $window.webkitCancelRequestAnimationFrame;
            var cancelAnimationFrame = v17110 || v17111;
            const v17112 = !requestAnimationFrame;
            const v17113 = !v17112;
            var rafSupported = v17113;
            let raf;
            const v17116 = function (fn) {
                var id = requestAnimationFrame(fn);
                const v17115 = function () {
                    const v17114 = cancelAnimationFrame(id);
                    v17114;
                };
                return v17115;
            };
            const v17119 = function (fn) {
                var timer = $timeout(fn, 16.66, false);
                const v17118 = function () {
                    const v17117 = $timeout.cancel(timer);
                    v17117;
                };
                return v17118;
            };
            if (rafSupported) {
                raf = v17116;
            } else {
                raf = v17119;
            }
            raf.supported = rafSupported;
            return raf;
        };
        this.$get = [
            '$window',
            '$timeout',
            v17120
        ];
    };
    const $RootScopeProvider = function () {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        const v17122 = function (value) {
            const v17121 = arguments.length;
            if (v17121) {
                TTL = value;
            }
            return TTL;
        };
        this.digestTtl = v17122;
        const createChildScopeClass = function (parent) {
            const ChildScope = function () {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                const v17123 = {};
                this.$$listeners = v17123;
                const v17124 = {};
                this.$$listenerCount = v17124;
                this.$$watchersCount = 0;
                const v17125 = nextUid();
                this.$id = v17125;
                this.$$ChildScope = null;
                this.$$suspended = false;
            };
            ChildScope.prototype = parent;
            return ChildScope;
        };
        const v17494 = function ($exceptionHandler, $parse, $browser) {
            const destroyChildScope = function ($event) {
                const v17126 = $event.currentScope;
                v17126.$$destroyed = true;
            };
            const cleanUpScope = function ($scope) {
                const v17127 = msie === 9;
                if (v17127) {
                    const v17128 = $scope.$$childHead;
                    if (v17128) {
                        const v17129 = $scope.$$childHead;
                        const v17130 = cleanUpScope(v17129);
                        v17130;
                    }
                    const v17131 = $scope.$$nextSibling;
                    if (v17131) {
                        const v17132 = $scope.$$nextSibling;
                        const v17133 = cleanUpScope(v17132);
                        v17133;
                    }
                }
                $scope.$$watchers = null;
                $scope.$root = $scope.$$watchers;
                $scope.$$childTail = $scope.$root;
                $scope.$$childHead = $scope.$$childTail;
                $scope.$$prevSibling = $scope.$$childHead;
                $scope.$$nextSibling = $scope.$$prevSibling;
                $scope.$parent = $scope.$$nextSibling;
            };
            const Scope = function () {
                const v17134 = nextUid();
                this.$id = v17134;
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = false;
                this.$$suspended = false;
                const v17135 = {};
                this.$$listeners = v17135;
                const v17136 = {};
                this.$$listenerCount = v17136;
                this.$$watchersCount = 0;
                this.$$isolateBindings = null;
            };
            const v17147 = function (isolate, parent) {
                var child;
                parent = parent || this;
                if (isolate) {
                    child = new Scope();
                    const v17137 = this.$root;
                    child.$root = v17137;
                } else {
                    const v17138 = this.$$ChildScope;
                    const v17139 = !v17138;
                    if (v17139) {
                        const v17140 = createChildScopeClass(this);
                        this.$$ChildScope = v17140;
                    }
                    child = new this.$$ChildScope();
                }
                child.$parent = parent;
                const v17141 = parent.$$childTail;
                child.$$prevSibling = v17141;
                const v17142 = parent.$$childHead;
                if (v17142) {
                    const v17143 = parent.$$childTail;
                    v17143.$$nextSibling = child;
                    parent.$$childTail = child;
                } else {
                    parent.$$childTail = child;
                    parent.$$childHead = parent.$$childTail;
                }
                const v17144 = parent !== this;
                const v17145 = isolate || v17144;
                if (v17145) {
                    const v17146 = child.$on('$destroy', destroyChildScope);
                    v17146;
                }
                return child;
            };
            const v17168 = function (watchExp, listener, objectEquality, prettyPrintExpression) {
                var get = $parse(watchExp);
                let fn;
                const v17148 = isFunction(listener);
                if (v17148) {
                    fn = listener;
                } else {
                    fn = noop;
                }
                const v17149 = get.$$watchDelegate;
                if (v17149) {
                    const v17150 = get.$$watchDelegate(this, fn, objectEquality, get, watchExp);
                    return v17150;
                }
                var scope = this;
                var array = scope.$$watchers;
                const v17151 = prettyPrintExpression || watchExp;
                const v17152 = !objectEquality;
                const v17153 = !v17152;
                var watcher = {};
                watcher.fn = fn;
                watcher.last = initWatchVal;
                watcher.get = get;
                watcher.exp = v17151;
                watcher.eq = v17153;
                lastDirtyWatch = null;
                const v17154 = !array;
                if (v17154) {
                    scope.$$watchers = [];
                    array = scope.$$watchers;
                    const v17155 = -1;
                    array.$$digestWatchIndex = v17155;
                }
                const v17156 = array.unshift(watcher);
                v17156;
                const v17157 = array.$$digestWatchIndex;
                const v17158 = v17157++;
                v17158;
                const v17159 = incrementWatchersCount(this, 1);
                v17159;
                const v17167 = function deregisterWatch() {
                    var index = arrayRemove(array, watcher);
                    const v17160 = index >= 0;
                    if (v17160) {
                        const v17161 = -1;
                        const v17162 = incrementWatchersCount(scope, v17161);
                        v17162;
                        const v17163 = array.$$digestWatchIndex;
                        const v17164 = index < v17163;
                        if (v17164) {
                            const v17165 = array.$$digestWatchIndex;
                            const v17166 = v17165--;
                            v17166;
                        }
                    }
                    lastDirtyWatch = null;
                };
                return v17167;
            };
            const v17201 = function (watchExpressions, listener) {
                const v17169 = watchExpressions.length;
                var oldValues = new Array(v17169);
                const v17170 = watchExpressions.length;
                var newValues = new Array(v17170);
                var deregisterFns = [];
                var self = this;
                var changeReactionScheduled = false;
                var firstRun = true;
                const v17171 = watchExpressions.length;
                const v17172 = !v17171;
                if (v17172) {
                    var shouldCall = true;
                    const v17174 = function () {
                        if (shouldCall) {
                            const v17173 = listener(newValues, newValues, self);
                            v17173;
                        }
                    };
                    const v17175 = self.$evalAsync(v17174);
                    v17175;
                    const v17176 = function deregisterWatchGroup() {
                        shouldCall = false;
                    };
                    return v17176;
                }
                const v17177 = watchExpressions.length;
                const v17178 = v17177 === 1;
                if (v17178) {
                    const v17179 = watchExpressions[0];
                    const v17183 = function watchGroupAction(value, oldValue, scope) {
                        newValues[0] = value;
                        oldValues[0] = oldValue;
                        const v17180 = value === oldValue;
                        let v17181;
                        if (v17180) {
                            v17181 = newValues;
                        } else {
                            v17181 = oldValues;
                        }
                        const v17182 = listener(newValues, v17181, scope);
                        v17182;
                    };
                    const v17184 = this.$watch(v17179, v17183);
                    return v17184;
                }
                const v17189 = function (expr, i) {
                    const v17187 = function watchGroupSubAction(value) {
                        newValues[i] = value;
                        const v17185 = !changeReactionScheduled;
                        if (v17185) {
                            changeReactionScheduled = true;
                            const v17186 = self.$evalAsync(watchGroupAction);
                            v17186;
                        }
                    };
                    var unwatchFn = self.$watch(expr, v17187);
                    const v17188 = deregisterFns.push(unwatchFn);
                    v17188;
                };
                const v17190 = forEach(watchExpressions, v17189);
                v17190;
                const watchGroupAction = function () {
                    changeReactionScheduled = false;
                    try {
                        if (firstRun) {
                            firstRun = false;
                            const v17191 = listener(newValues, newValues, self);
                            v17191;
                        } else {
                            const v17192 = listener(newValues, oldValues, self);
                            v17192;
                        }
                    } finally {
                        var i = 0;
                        const v17193 = watchExpressions.length;
                        let v17194 = i < v17193;
                        while (v17194) {
                            const v17196 = newValues[i];
                            oldValues[i] = v17196;
                            const v17195 = i++;
                            v17194 = i < v17193;
                        }
                    }
                };
                const v17200 = function deregisterWatchGroup() {
                    let v17197 = deregisterFns.length;
                    while (v17197) {
                        const v17198 = deregisterFns.shift();
                        const v17199 = v17198();
                        v17199;
                        v17197 = deregisterFns.length;
                    }
                };
                return v17200;
            };
            const v17258 = function (obj, listener) {
                const v17202 = $parse(obj);
                const v17203 = v17202.literal;
                $watchCollectionInterceptor.$$pure = v17203;
                const v17204 = $watchCollectionInterceptor.$$pure;
                const v17205 = !v17204;
                $watchCollectionInterceptor.$stateful = v17205;
                var self = this;
                var newValue;
                var oldValue;
                var veryOldValue;
                const v17206 = listener.length;
                var trackVeryOldValue = v17206 > 1;
                var changeDetected = 0;
                var changeDetector = $parse(obj, $watchCollectionInterceptor);
                var internalArray = [];
                var internalObject = {};
                var initRun = true;
                var oldLength = 0;
                const $watchCollectionInterceptor = function (_value) {
                    newValue = _value;
                    var newLength;
                    var key;
                    var bothNaN;
                    var newItem;
                    var oldItem;
                    const v17207 = isUndefined(newValue);
                    if (v17207) {
                        return;
                    }
                    const v17208 = isObject(newValue);
                    const v17209 = !v17208;
                    if (v17209) {
                        const v17210 = oldValue !== newValue;
                        if (v17210) {
                            oldValue = newValue;
                            const v17211 = changeDetected++;
                            v17211;
                        }
                    } else {
                        const v17212 = isArrayLike(newValue);
                        if (v17212) {
                            const v17213 = oldValue !== internalArray;
                            if (v17213) {
                                oldValue = internalArray;
                                oldValue.length = 0;
                                oldLength = oldValue.length;
                                const v17214 = changeDetected++;
                                v17214;
                            }
                            newLength = newValue.length;
                            const v17215 = oldLength !== newLength;
                            if (v17215) {
                                const v17216 = changeDetected++;
                                v17216;
                                oldLength = newLength;
                                oldValue.length = oldLength;
                            }
                            var i = 0;
                            let v17217 = i < newLength;
                            while (v17217) {
                                oldItem = oldValue[i];
                                newItem = newValue[i];
                                const v17219 = oldItem !== oldItem;
                                const v17220 = newItem !== newItem;
                                bothNaN = v17219 && v17220;
                                const v17221 = !bothNaN;
                                const v17222 = oldItem !== newItem;
                                const v17223 = v17221 && v17222;
                                if (v17223) {
                                    const v17224 = changeDetected++;
                                    v17224;
                                    oldValue[i] = newItem;
                                }
                                const v17218 = i++;
                                v17217 = i < newLength;
                            }
                        } else {
                            const v17225 = oldValue !== internalObject;
                            if (v17225) {
                                internalObject = {};
                                oldValue = internalObject;
                                oldLength = 0;
                                const v17226 = changeDetected++;
                                v17226;
                            }
                            newLength = 0;
                            for (key in newValue) {
                                const v17227 = hasOwnProperty.call(newValue, key);
                                if (v17227) {
                                    const v17228 = newLength++;
                                    v17228;
                                    newItem = newValue[key];
                                    oldItem = oldValue[key];
                                    const v17229 = key in oldValue;
                                    if (v17229) {
                                        const v17230 = oldItem !== oldItem;
                                        const v17231 = newItem !== newItem;
                                        bothNaN = v17230 && v17231;
                                        const v17232 = !bothNaN;
                                        const v17233 = oldItem !== newItem;
                                        const v17234 = v17232 && v17233;
                                        if (v17234) {
                                            const v17235 = changeDetected++;
                                            v17235;
                                            oldValue[key] = newItem;
                                        }
                                    } else {
                                        const v17236 = oldLength++;
                                        v17236;
                                        oldValue[key] = newItem;
                                        const v17237 = changeDetected++;
                                        v17237;
                                    }
                                }
                            }
                            const v17238 = oldLength > newLength;
                            if (v17238) {
                                const v17239 = changeDetected++;
                                v17239;
                                for (key in oldValue) {
                                    const v17240 = hasOwnProperty.call(newValue, key);
                                    const v17241 = !v17240;
                                    if (v17241) {
                                        const v17242 = oldLength--;
                                        v17242;
                                        const v17243 = oldValue[key];
                                        const v17244 = delete v17243;
                                        v17244;
                                    }
                                }
                            }
                        }
                    }
                    return changeDetected;
                };
                const $watchCollectionAction = function () {
                    if (initRun) {
                        initRun = false;
                        const v17245 = listener(newValue, newValue, self);
                        v17245;
                    } else {
                        const v17246 = listener(newValue, veryOldValue, self);
                        v17246;
                    }
                    if (trackVeryOldValue) {
                        const v17247 = isObject(newValue);
                        const v17248 = !v17247;
                        if (v17248) {
                            veryOldValue = newValue;
                        } else {
                            const v17249 = isArrayLike(newValue);
                            if (v17249) {
                                const v17250 = newValue.length;
                                veryOldValue = new Array(v17250);
                                var i = 0;
                                const v17251 = newValue.length;
                                let v17252 = i < v17251;
                                while (v17252) {
                                    const v17254 = newValue[i];
                                    veryOldValue[i] = v17254;
                                    const v17253 = i++;
                                    v17252 = i < v17251;
                                }
                            } else {
                                veryOldValue = {};
                                let key;
                                for (key in newValue) {
                                    const v17255 = hasOwnProperty.call(newValue, key);
                                    if (v17255) {
                                        const v17256 = newValue[key];
                                        veryOldValue[key] = v17256;
                                    }
                                }
                            }
                        }
                    }
                };
                const v17257 = this.$watch(changeDetector, $watchCollectionAction);
                return v17257;
            };
            const v17346 = function () {
                var watch;
                var value;
                var last;
                var fn;
                var get;
                var watchers;
                var dirty;
                var ttl = TTL;
                var next;
                var current;
                let target;
                const v17259 = asyncQueue.length;
                if (v17259) {
                    target = $rootScope;
                } else {
                    target = this;
                }
                var watchLog = [];
                var logIdx;
                var asyncTask;
                const v17260 = beginPhase('$digest');
                v17260;
                const v17261 = $browser.$$checkUrlChange();
                v17261;
                const v17262 = this === $rootScope;
                const v17263 = applyAsyncId !== null;
                const v17264 = v17262 && v17263;
                if (v17264) {
                    const v17265 = $browser.defer;
                    const v17266 = v17265.cancel(applyAsyncId);
                    v17266;
                    const v17267 = flushApplyAsync();
                    v17267;
                }
                lastDirtyWatch = null;
                let v17269 = true;
                while (v17269) {
                    dirty = false;
                    current = target;
                    var asyncQueuePosition = 0;
                    const v17270 = asyncQueue.length;
                    let v17271 = asyncQueuePosition < v17270;
                    while (v17271) {
                        try {
                            asyncTask = asyncQueue[asyncQueuePosition];
                            fn = asyncTask.fn;
                            const v17273 = asyncTask.scope;
                            const v17274 = asyncTask.locals;
                            const v17275 = fn(v17273, v17274);
                            v17275;
                        } catch (e) {
                            const v17276 = $exceptionHandler(e);
                            v17276;
                        }
                        lastDirtyWatch = null;
                        const v17272 = asyncQueuePosition++;
                        v17271 = asyncQueuePosition < v17270;
                    }
                    asyncQueue.length = 0;
                    traverseScopesLoop: {
                        let v17330 = true;
                        while (current = next) {
                            const v17277 = current.$$suspended;
                            const v17278 = !v17277;
                            const v17279 = current.$$watchers;
                            if (watchers = v17278 && v17279) {
                                const v17280 = watchers.length;
                                watchers.$$digestWatchIndex = v17280;
                                const v17281 = watchers.$$digestWatchIndex;
                                let v17282 = v17281--;
                                while (v17282) {
                                    try {
                                        const v17283 = watchers.$$digestWatchIndex;
                                        watch = watchers[v17283];
                                        if (watch) {
                                            get = watch.get;
                                            const v17284 = (value = get(current)) !== (last = watch.last);
                                            const v17285 = watch.eq;
                                            const v17286 = equals(value, last);
                                            const v17287 = isNumberNaN(value);
                                            const v17288 = isNumberNaN(last);
                                            const v17289 = v17287 && v17288;
                                            let v17290;
                                            if (v17285) {
                                                v17290 = v17286;
                                            } else {
                                                v17290 = v17289;
                                            }
                                            const v17291 = !v17290;
                                            const v17292 = v17284 && v17291;
                                            if (v17292) {
                                                dirty = true;
                                                lastDirtyWatch = watch;
                                                const v17293 = watch.eq;
                                                const v17294 = copy(value, null);
                                                let v17295;
                                                if (v17293) {
                                                    v17295 = v17294;
                                                } else {
                                                    v17295 = value;
                                                }
                                                watch.last = v17295;
                                                fn = watch.fn;
                                                const v17296 = last === initWatchVal;
                                                let v17297;
                                                if (v17296) {
                                                    v17297 = value;
                                                } else {
                                                    v17297 = last;
                                                }
                                                const v17298 = fn(value, v17297, current);
                                                v17298;
                                                const v17299 = ttl < 5;
                                                if (v17299) {
                                                    logIdx = 4 - ttl;
                                                    const v17300 = watchLog[logIdx];
                                                    const v17301 = !v17300;
                                                    if (v17301) {
                                                        watchLog[logIdx] = [];
                                                    }
                                                    const v17302 = watchLog[logIdx];
                                                    const v17303 = watch.exp;
                                                    const v17304 = isFunction(v17303);
                                                    const v17305 = watch.exp;
                                                    const v17306 = v17305.name;
                                                    const v17307 = watch.exp;
                                                    const v17308 = v17307.toString();
                                                    const v17309 = v17306 || v17308;
                                                    const v17310 = 'fn: ' + v17309;
                                                    const v17311 = watch.exp;
                                                    let v17312;
                                                    if (v17304) {
                                                        v17312 = v17310;
                                                    } else {
                                                        v17312 = v17311;
                                                    }
                                                    const v17313 = {
                                                        msg: v17312,
                                                        newVal: value,
                                                        oldVal: last
                                                    };
                                                    const v17314 = v17302.push(v17313);
                                                    v17314;
                                                }
                                            } else {
                                                const v17315 = watch === lastDirtyWatch;
                                                if (v17315) {
                                                    dirty = false;
                                                    break traverseScopesLoop;
                                                }
                                            }
                                        }
                                    } catch (e) {
                                        const v17316 = $exceptionHandler(e);
                                        v17316;
                                    }
                                    v17282 = v17281--;
                                }
                            }
                            const v17317 = current.$$suspended;
                            const v17318 = !v17317;
                            const v17319 = current.$$watchersCount;
                            const v17320 = v17318 && v17319;
                            const v17321 = current.$$childHead;
                            const v17322 = v17320 && v17321;
                            const v17323 = current !== target;
                            const v17324 = current.$$nextSibling;
                            const v17325 = v17323 && v17324;
                            const v17326 = !(next = v17322 || v17325);
                            if (v17326) {
                                const v17327 = current !== target;
                                const v17328 = !(next = current.$$nextSibling);
                                let v17329 = v17327 && v17328;
                                while (v17329) {
                                    current = current.$parent;
                                    v17329 = v17327 && v17328;
                                }
                            }
                        }
                    }
                    const v17331 = asyncQueue.length;
                    const v17332 = dirty || v17331;
                    const v17333 = ttl--;
                    const v17334 = !v17333;
                    const v17335 = v17332 && v17334;
                    if (v17335) {
                        const v17336 = clearPhase();
                        v17336;
                        const v17337 = '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}';
                        const v17338 = $rootScopeMinErr('infdig', v17337, TTL, watchLog);
                        throw v17338;
                    }
                    v17269 = dirty || v17268;
                }
                const v17339 = clearPhase();
                v17339;
                const v17340 = postDigestQueue.length;
                let v17341 = postDigestQueuePosition < v17340;
                while (v17341) {
                    try {
                        const v17342 = postDigestQueuePosition++;
                        const v17343 = postDigestQueue[v17342]();
                        v17343;
                    } catch (e) {
                        const v17344 = $exceptionHandler(e);
                        v17344;
                    }
                    v17341 = postDigestQueuePosition < v17340;
                }
                postDigestQueuePosition = 0;
                postDigestQueue.length = postDigestQueuePosition;
                const v17345 = $browser.$$checkUrlChange();
                v17345;
            };
            const v17347 = function () {
                this.$$suspended = true;
            };
            const v17349 = function () {
                const v17348 = this.$$suspended;
                return v17348;
            };
            const v17350 = function () {
                this.$$suspended = false;
            };
            const v17379 = function () {
                const v17351 = this.$$destroyed;
                if (v17351) {
                    return;
                }
                var parent = this.$parent;
                const v17352 = this.$broadcast('$destroy');
                v17352;
                this.$$destroyed = true;
                const v17353 = this === $rootScope;
                if (v17353) {
                    const v17354 = $browser.$$applicationDestroyed();
                    v17354;
                }
                const v17355 = this.$$watchersCount;
                const v17356 = -v17355;
                const v17357 = incrementWatchersCount(this, v17356);
                v17357;
                let eventName;
                const v17358 = this.$$listenerCount;
                for (eventName in v17358) {
                    const v17359 = this.$$listenerCount;
                    const v17360 = v17359[eventName];
                    const v17361 = decrementListenerCount(this, v17360, eventName);
                    v17361;
                }
                const v17362 = parent.$$childHead;
                const v17363 = v17362 === this;
                const v17364 = parent && v17363;
                if (v17364) {
                    const v17365 = this.$$nextSibling;
                    parent.$$childHead = v17365;
                }
                const v17366 = parent.$$childTail;
                const v17367 = v17366 === this;
                const v17368 = parent && v17367;
                if (v17368) {
                    const v17369 = this.$$prevSibling;
                    parent.$$childTail = v17369;
                }
                const v17370 = this.$$prevSibling;
                if (v17370) {
                    const v17371 = this.$$prevSibling;
                    const v17372 = this.$$nextSibling;
                    v17371.$$nextSibling = v17372;
                }
                const v17373 = this.$$nextSibling;
                if (v17373) {
                    const v17374 = this.$$nextSibling;
                    const v17375 = this.$$prevSibling;
                    v17374.$$prevSibling = v17375;
                }
                this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                const v17376 = function () {
                    return noop;
                };
                this.$on = this.$watch = this.$watchGroup = v17376;
                const v17377 = {};
                this.$$listeners = v17377;
                this.$$nextSibling = null;
                const v17378 = cleanUpScope(this);
                v17378;
            };
            const v17382 = function (expr, locals) {
                const v17380 = $parse(expr);
                const v17381 = v17380(this, locals);
                return v17381;
            };
            const v17395 = function (expr, locals) {
                const v17383 = $rootScope.$$phase;
                const v17384 = !v17383;
                const v17385 = asyncQueue.length;
                const v17386 = !v17385;
                const v17387 = v17384 && v17386;
                if (v17387) {
                    const v17390 = function () {
                        const v17388 = asyncQueue.length;
                        if (v17388) {
                            const v17389 = $rootScope.$digest();
                            v17389;
                        }
                    };
                    const v17391 = $browser.defer(v17390, null, '$evalAsync');
                    v17391;
                }
                const v17392 = $parse(expr);
                const v17393 = {
                    scope: this,
                    fn: v17392,
                    locals: locals
                };
                const v17394 = asyncQueue.push(v17393);
                v17394;
            };
            const v17397 = function (fn) {
                const v17396 = postDigestQueue.push(fn);
                v17396;
            };
            const v17404 = function (expr) {
                try {
                    const v17398 = beginPhase('$apply');
                    v17398;
                    try {
                        const v17399 = this.$eval(expr);
                        return v17399;
                    } finally {
                        const v17400 = clearPhase();
                        v17400;
                    }
                } catch (e) {
                    const v17401 = $exceptionHandler(e);
                    v17401;
                } finally {
                    try {
                        const v17402 = $rootScope.$digest();
                        v17402;
                    } catch (e) {
                        const v17403 = $exceptionHandler(e);
                        v17403;
                        throw e;
                    }
                }
            };
            const v17408 = function (expr) {
                var scope = this;
                if (expr) {
                    const v17405 = applyAsyncQueue.push($applyAsyncExpression);
                    v17405;
                }
                expr = $parse(expr);
                const v17406 = scheduleApplyAsync();
                v17406;
                const $applyAsyncExpression = function () {
                    const v17407 = scope.$eval(expr);
                    v17407;
                };
            };
            const v17427 = function (name, listener) {
                const v17409 = this.$$listeners;
                var namedListeners = v17409[name];
                const v17410 = !namedListeners;
                if (v17410) {
                    const v17411 = this.$$listeners;
                    namedListeners = [];
                    v17411[name] = namedListeners;
                }
                const v17412 = namedListeners.push(listener);
                v17412;
                var current = this;
                let v17420 = true;
                while (current = current.$parent) {
                    const v17413 = current.$$listenerCount;
                    const v17414 = v17413[name];
                    const v17415 = !v17414;
                    if (v17415) {
                        const v17416 = current.$$listenerCount;
                        v17416[name] = 0;
                    }
                    const v17417 = current.$$listenerCount;
                    const v17418 = v17417[name];
                    const v17419 = v17418++;
                    v17419;
                }
                var self = this;
                const v17426 = function () {
                    var indexOfListener = namedListeners.indexOf(listener);
                    const v17421 = -1;
                    const v17422 = indexOfListener !== v17421;
                    if (v17422) {
                        const v17423 = namedListeners[indexOfListener];
                        const v17424 = delete v17423;
                        v17424;
                        const v17425 = decrementListenerCount(self, 1, name);
                        v17425;
                    }
                };
                return v17426;
            };
            const v17443 = function (name, args) {
                var empty = [];
                var namedListeners;
                var scope = this;
                var stopPropagation = false;
                const v17428 = function () {
                    stopPropagation = true;
                };
                const v17429 = function () {
                    event.defaultPrevented = true;
                };
                var event = {};
                event.name = name;
                event.targetScope = scope;
                event.stopPropagation = v17428;
                event.preventDefault = v17429;
                event.defaultPrevented = false;
                const v17430 = [event];
                var listenerArgs = concat(v17430, arguments, 1);
                var i;
                var length;
                let scope = true;
                while (scope) {
                    const v17431 = scope.$$listeners;
                    const v17432 = v17431[name];
                    namedListeners = v17432 || empty;
                    event.currentScope = scope;
                    (i = 0, length = namedListeners.length)
                    let v17433 = i < length;
                    while (v17433) {
                        const v17435 = namedListeners[i];
                        const v17436 = !v17435;
                        if (v17436) {
                            const v17437 = namedListeners.splice(i, 1);
                            v17437;
                            const v17438 = i--;
                            v17438;
                            const v17439 = length--;
                            v17439;
                            continue;
                        }
                        try {
                            const v17440 = namedListeners[i];
                            const v17441 = v17440.apply(null, listenerArgs);
                            v17441;
                        } catch (e) {
                            const v17442 = $exceptionHandler(e);
                            v17442;
                        }
                        const v17434 = i++;
                        v17433 = i < length;
                    }
                    if (stopPropagation) {
                        break;
                    }
                    scope = scope.$parent;
                }
                event.currentScope = null;
                return event;
            };
            const v17473 = function (name, args) {
                var target = this;
                var current = target;
                var next = target;
                const v17444 = function () {
                    event.defaultPrevented = true;
                };
                var event = {};
                event.name = name;
                event.targetScope = target;
                event.preventDefault = v17444;
                event.defaultPrevented = false;
                const v17445 = target.$$listenerCount;
                const v17446 = v17445[name];
                const v17447 = !v17446;
                if (v17447) {
                    return event;
                }
                const v17448 = [event];
                var listenerArgs = concat(v17448, arguments, 1);
                var listeners;
                var i;
                var length;
                while (current = next) {
                    event.currentScope = current;
                    const v17449 = current.$$listeners;
                    const v17450 = v17449[name];
                    const v17451 = [];
                    listeners = v17450 || v17451;
                    (i = 0, length = listeners.length)
                    let v17452 = i < length;
                    while (v17452) {
                        const v17454 = listeners[i];
                        const v17455 = !v17454;
                        if (v17455) {
                            const v17456 = listeners.splice(i, 1);
                            v17456;
                            const v17457 = i--;
                            v17457;
                            const v17458 = length--;
                            v17458;
                            continue;
                        }
                        try {
                            const v17459 = listeners[i];
                            const v17460 = v17459.apply(null, listenerArgs);
                            v17460;
                        } catch (e) {
                            const v17461 = $exceptionHandler(e);
                            v17461;
                        }
                        const v17453 = i++;
                        v17452 = i < length;
                    }
                    const v17462 = current.$$listenerCount;
                    const v17463 = v17462[name];
                    const v17464 = current.$$childHead;
                    const v17465 = v17463 && v17464;
                    const v17466 = current !== target;
                    const v17467 = current.$$nextSibling;
                    const v17468 = v17466 && v17467;
                    const v17469 = !(next = v17465 || v17468);
                    if (v17469) {
                        const v17470 = current !== target;
                        const v17471 = !(next = current.$$nextSibling);
                        let v17472 = v17470 && v17471;
                        while (v17472) {
                            current = current.$parent;
                            v17472 = v17470 && v17471;
                        }
                    }
                }
                event.currentScope = null;
                return event;
            };
            const v17474 = {};
            v17474.constructor = Scope;
            v17474.$new = v17147;
            v17474.$watch = v17168;
            v17474.$watchGroup = v17201;
            v17474.$watchCollection = v17258;
            v17474.$digest = v17346;
            v17474.$suspend = v17347;
            v17474.$isSuspended = v17349;
            v17474.$resume = v17350;
            v17474.$destroy = v17379;
            v17474.$eval = v17382;
            v17474.$evalAsync = v17395;
            v17474.$$postDigest = v17397;
            v17474.$apply = v17404;
            v17474.$applyAsync = v17408;
            v17474.$on = v17427;
            v17474.$emit = v17443;
            v17474.$broadcast = v17473;
            Scope.prototype = v17474;
            var $rootScope = new Scope();
            $rootScope.$$asyncQueue = [];
            var asyncQueue = $rootScope.$$asyncQueue;
            $rootScope.$$postDigestQueue = [];
            var postDigestQueue = $rootScope.$$postDigestQueue;
            $rootScope.$$applyAsyncQueue = [];
            var applyAsyncQueue = $rootScope.$$applyAsyncQueue;
            var postDigestQueuePosition = 0;
            return $rootScope;
            const beginPhase = function (phase) {
                const v17475 = $rootScope.$$phase;
                if (v17475) {
                    const v17476 = $rootScope.$$phase;
                    const v17477 = $rootScopeMinErr('inprog', '{0} already in progress', v17476);
                    throw v17477;
                }
                $rootScope.$$phase = phase;
            };
            const clearPhase = function () {
                $rootScope.$$phase = null;
            };
            const incrementWatchersCount = function (current, count) {
                let v17478 = true;
                while (current = current.$parent) {
                    current.$$watchersCount += count;
                }
            };
            const decrementListenerCount = function (current, count, name) {
                let v17486 = true;
                while (current = current.$parent) {
                    const v17479 = current.$$listenerCount;
                    v17479[name] -= count;
                    const v17480 = current.$$listenerCount;
                    const v17481 = v17480[name];
                    const v17482 = v17481 === 0;
                    if (v17482) {
                        const v17483 = current.$$listenerCount;
                        const v17484 = v17483[name];
                        const v17485 = delete v17484;
                        v17485;
                    }
                }
            };
            const initWatchVal = function () {
            };
            const flushApplyAsync = function () {
                let v17487 = applyAsyncQueue.length;
                while (v17487) {
                    try {
                        const v17488 = applyAsyncQueue.shift();
                        const v17489 = v17488();
                        v17489;
                    } catch (e) {
                        const v17490 = $exceptionHandler(e);
                        v17490;
                    }
                    v17487 = applyAsyncQueue.length;
                }
                applyAsyncId = null;
            };
            const scheduleApplyAsync = function () {
                const v17491 = applyAsyncId === null;
                if (v17491) {
                    const v17493 = function () {
                        const v17492 = $rootScope.$apply(flushApplyAsync);
                        v17492;
                    };
                    applyAsyncId = $browser.defer(v17493, null, '$applyAsync');
                }
            };
        };
        this.$get = [
            '$exceptionHandler',
            '$parse',
            '$browser',
            v17494
        ];
    };
    const $$SanitizeUriProvider = function () {
        var aHrefSanitizationWhitelist = /^\s*(https?|s?ftp|mailto|tel|file):/;
        var imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        const v17496 = function (regexp) {
            const v17495 = isDefined(regexp);
            if (v17495) {
                aHrefSanitizationWhitelist = regexp;
                return this;
            }
            return aHrefSanitizationWhitelist;
        };
        this.aHrefSanitizationWhitelist = v17496;
        const v17498 = function (regexp) {
            const v17497 = isDefined(regexp);
            if (v17497) {
                imgSrcSanitizationWhitelist = regexp;
                return this;
            }
            return imgSrcSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = v17498;
        const v17508 = function () {
            const v17507 = function sanitizeUri(uri, isMediaUrl) {
                let regex;
                if (isMediaUrl) {
                    regex = imgSrcSanitizationWhitelist;
                } else {
                    regex = aHrefSanitizationWhitelist;
                }
                const v17499 = uri.trim();
                const v17500 = uri && v17499;
                const v17501 = urlResolve(v17500);
                var normalizedVal = v17501.href;
                const v17502 = normalizedVal !== '';
                const v17503 = normalizedVal.match(regex);
                const v17504 = !v17503;
                const v17505 = v17502 && v17504;
                if (v17505) {
                    const v17506 = 'unsafe:' + normalizedVal;
                    return v17506;
                }
                return uri;
            };
            return v17507;
        };
        this.$get = v17508;
    };
    var $sceMinErr = minErr('$sce');
    var SCE_CONTEXTS = {};
    SCE_CONTEXTS.HTML = 'html';
    SCE_CONTEXTS.CSS = 'css';
    SCE_CONTEXTS.MEDIA_URL = 'mediaUrl';
    SCE_CONTEXTS.URL = 'url';
    SCE_CONTEXTS.RESOURCE_URL = 'resourceUrl';
    SCE_CONTEXTS.JS = 'js';
    var UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;
    const snakeToCamel = function (name) {
        const v17509 = name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
        return v17509;
    };
    const adjustMatcher = function (matcher) {
        const v17510 = matcher === 'self';
        if (v17510) {
            return matcher;
        } else {
            const v17511 = isString(matcher);
            if (v17511) {
                const v17512 = matcher.indexOf('***');
                const v17513 = -1;
                const v17514 = v17512 > v17513;
                if (v17514) {
                    const v17515 = $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
                    throw v17515;
                }
                const v17516 = escapeForRegexp(matcher);
                const v17517 = v17516.replace(/\\\*\\\*/g, '.*');
                matcher = v17517.replace(/\\\*/g, '[^:/.?&;]*');
                const v17518 = '^' + matcher;
                const v17519 = v17518 + '$';
                const v17520 = new RegExp(v17519);
                return v17520;
            } else {
                const v17521 = isRegExp(matcher);
                if (v17521) {
                    const v17522 = matcher.source;
                    const v17523 = '^' + v17522;
                    const v17524 = v17523 + '$';
                    const v17525 = new RegExp(v17524);
                    return v17525;
                } else {
                    const v17526 = $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
                    throw v17526;
                }
            }
        }
    };
    const adjustMatchers = function (matchers) {
        var adjustedMatchers = [];
        const v17527 = isDefined(matchers);
        if (v17527) {
            const v17530 = function (matcher) {
                const v17528 = adjustMatcher(matcher);
                const v17529 = adjustedMatchers.push(v17528);
                v17529;
            };
            const v17531 = forEach(matchers, v17530);
            v17531;
        }
        return adjustedMatchers;
    };
    const $SceDelegateProvider = function () {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'];
        var resourceUrlBlacklist = [];
        const v17533 = function (value) {
            const v17532 = arguments.length;
            if (v17532) {
                resourceUrlWhitelist = adjustMatchers(value);
            }
            return resourceUrlWhitelist;
        };
        this.resourceUrlWhitelist = v17533;
        const v17535 = function (value) {
            const v17534 = arguments.length;
            if (v17534) {
                resourceUrlBlacklist = adjustMatchers(value);
            }
            return resourceUrlBlacklist;
        };
        this.resourceUrlBlacklist = v17535;
        const v17623 = function ($injector, $$sanitizeUri) {
            var htmlSanitizer = function htmlSanitizer(html) {
                const v17536 = $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
                throw v17536;
            };
            const v17537 = $injector.has('$sanitize');
            if (v17537) {
                htmlSanitizer = $injector.get('$sanitize');
            }
            const matchUrl = function (matcher, parsedUrl) {
                const v17538 = matcher === 'self';
                if (v17538) {
                    const v17539 = urlIsSameOrigin(parsedUrl);
                    const v17540 = urlIsSameOriginAsBaseUrl(parsedUrl);
                    const v17541 = v17539 || v17540;
                    return v17541;
                } else {
                    const v17542 = parsedUrl.href;
                    const v17543 = matcher.exec(v17542);
                    const v17544 = !v17543;
                    const v17545 = !v17544;
                    return v17545;
                }
            };
            const isResourceUrlAllowedByPolicy = function (url) {
                const v17546 = url.toString();
                var parsedUrl = urlResolve(v17546);
                var i;
                var n;
                var allowed = false;
                (i = 0, n = resourceUrlWhitelist.length)
                let v17547 = i < n;
                while (v17547) {
                    const v17549 = resourceUrlWhitelist[i];
                    const v17550 = matchUrl(v17549, parsedUrl);
                    if (v17550) {
                        allowed = true;
                        break;
                    }
                    const v17548 = i++;
                    v17547 = i < n;
                }
                if (allowed) {
                    (i = 0, n = resourceUrlBlacklist.length)
                    let v17551 = i < n;
                    while (v17551) {
                        const v17553 = resourceUrlBlacklist[i];
                        const v17554 = matchUrl(v17553, parsedUrl);
                        if (v17554) {
                            allowed = false;
                            break;
                        }
                        const v17552 = i++;
                        v17551 = i < n;
                    }
                }
                return allowed;
            };
            const generateHolderType = function (Base) {
                var holderType = function TrustedValueHolderType(trustedValue) {
                    const v17555 = function () {
                        return trustedValue;
                    };
                    this.$$unwrapTrustedValue = v17555;
                };
                if (Base) {
                    holderType.prototype = new Base();
                }
                const v17556 = holderType.prototype;
                const sceValueOf = function () {
                    const v17557 = this.$$unwrapTrustedValue();
                    return v17557;
                };
                v17556.valueOf = sceValueOf;
                const v17558 = holderType.prototype;
                const sceToString = function () {
                    const v17559 = this.$$unwrapTrustedValue();
                    const v17560 = v17559.toString();
                    return v17560;
                };
                v17558.toString = sceToString;
                return holderType;
            };
            var trustedValueHolderBase = generateHolderType();
            var byType = {};
            const v17562 = generateHolderType(trustedValueHolderBase);
            byType[v17561] = v17562;
            const v17564 = generateHolderType(trustedValueHolderBase);
            byType[v17563] = v17564;
            const v17566 = generateHolderType(trustedValueHolderBase);
            byType[v17565] = v17566;
            const v17568 = SCE_CONTEXTS.MEDIA_URL;
            const v17569 = byType[v17568];
            const v17570 = generateHolderType(v17569);
            byType[v17567] = v17570;
            const v17572 = generateHolderType(trustedValueHolderBase);
            byType[v17571] = v17572;
            const v17574 = SCE_CONTEXTS.URL;
            const v17575 = byType[v17574];
            const v17576 = generateHolderType(v17575);
            byType[v17573] = v17576;
            const trustAs = function (type, trustedValue) {
                let Constructor;
                const v17577 = byType.hasOwnProperty(type);
                const v17578 = byType[type];
                if (v17577) {
                    Constructor = v17578;
                } else {
                    Constructor = null;
                }
                const v17579 = !Constructor;
                if (v17579) {
                    const v17580 = $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
                    throw v17580;
                }
                const v17581 = trustedValue === null;
                const v17582 = isUndefined(trustedValue);
                const v17583 = v17581 || v17582;
                const v17584 = trustedValue === '';
                const v17585 = v17583 || v17584;
                if (v17585) {
                    return trustedValue;
                }
                const v17586 = typeof trustedValue;
                const v17587 = v17586 !== 'string';
                if (v17587) {
                    const v17588 = $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
                    throw v17588;
                }
                const v17589 = new Constructor(trustedValue);
                return v17589;
            };
            const valueOf = function (maybeTrusted) {
                const v17590 = maybeTrusted instanceof trustedValueHolderBase;
                if (v17590) {
                    const v17591 = maybeTrusted.$$unwrapTrustedValue();
                    return v17591;
                } else {
                    return maybeTrusted;
                }
            };
            const getTrusted = function (type, maybeTrusted) {
                const v17592 = maybeTrusted === null;
                const v17593 = isUndefined(maybeTrusted);
                const v17594 = v17592 || v17593;
                const v17595 = maybeTrusted === '';
                const v17596 = v17594 || v17595;
                if (v17596) {
                    return maybeTrusted;
                }
                let constructor;
                const v17597 = byType.hasOwnProperty(type);
                const v17598 = byType[type];
                if (v17597) {
                    constructor = v17598;
                } else {
                    constructor = null;
                }
                const v17599 = maybeTrusted instanceof constructor;
                const v17600 = constructor && v17599;
                if (v17600) {
                    const v17601 = maybeTrusted.$$unwrapTrustedValue();
                    return v17601;
                }
                const v17602 = maybeTrusted.$$unwrapTrustedValue;
                const v17603 = isFunction(v17602);
                if (v17603) {
                    maybeTrusted = maybeTrusted.$$unwrapTrustedValue();
                }
                const v17604 = SCE_CONTEXTS.MEDIA_URL;
                const v17605 = type === v17604;
                const v17606 = SCE_CONTEXTS.URL;
                const v17607 = type === v17606;
                const v17608 = v17605 || v17607;
                if (v17608) {
                    const v17609 = maybeTrusted.toString();
                    const v17610 = SCE_CONTEXTS.MEDIA_URL;
                    const v17611 = type === v17610;
                    const v17612 = $$sanitizeUri(v17609, v17611);
                    return v17612;
                } else {
                    const v17613 = SCE_CONTEXTS.RESOURCE_URL;
                    const v17614 = type === v17613;
                    if (v17614) {
                        const v17615 = isResourceUrlAllowedByPolicy(maybeTrusted);
                        if (v17615) {
                            return maybeTrusted;
                        } else {
                            const v17616 = maybeTrusted.toString();
                            const v17617 = $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', v17616);
                            throw v17617;
                        }
                    } else {
                        const v17618 = SCE_CONTEXTS.HTML;
                        const v17619 = type === v17618;
                        if (v17619) {
                            const v17620 = htmlSanitizer(maybeTrusted);
                            return v17620;
                        }
                    }
                }
                const v17621 = $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
                throw v17621;
            };
            const v17622 = {};
            v17622.trustAs = trustAs;
            v17622.getTrusted = getTrusted;
            v17622.valueOf = valueOf;
            return v17622;
        };
        this.$get = [
            '$injector',
            '$$sanitizeUri',
            v17623
        ];
    };
    const $SceProvider = function () {
        var enabled = true;
        const v17627 = function (value) {
            const v17624 = arguments.length;
            if (v17624) {
                const v17625 = !value;
                const v17626 = !v17625;
                enabled = v17626;
            }
            return enabled;
        };
        this.enabled = v17627;
        const v17659 = function ($parse, $sceDelegate) {
            const v17628 = msie < 8;
            const v17629 = enabled && v17628;
            if (v17629) {
                const v17630 = 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ';
                const v17631 = v17630 + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.';
                const v17632 = $sceMinErr('iequirks', v17631);
                throw v17632;
            }
            var sce = shallowCopy(SCE_CONTEXTS);
            const v17633 = function () {
                return enabled;
            };
            sce.isEnabled = v17633;
            const v17634 = $sceDelegate.trustAs;
            sce.trustAs = v17634;
            const v17635 = $sceDelegate.getTrusted;
            sce.getTrusted = v17635;
            const v17636 = $sceDelegate.valueOf;
            sce.valueOf = v17636;
            const v17637 = !enabled;
            if (v17637) {
                const v17638 = function (type, value) {
                    return value;
                };
                sce.getTrusted = v17638;
                sce.trustAs = sce.getTrusted;
                sce.valueOf = identity;
            }
            const sceParseAs = function (type, expr) {
                var parsed = $parse(expr);
                const v17639 = parsed.literal;
                const v17640 = parsed.constant;
                const v17641 = v17639 && v17640;
                if (v17641) {
                    return parsed;
                } else {
                    const v17643 = function (value) {
                        const v17642 = sce.getTrusted(type, value);
                        return v17642;
                    };
                    const v17644 = $parse(expr, v17643);
                    return v17644;
                }
            };
            sce.parseAs = sceParseAs;
            var parse = sce.parseAs;
            var getTrusted = sce.getTrusted;
            var trustAs = sce.trustAs;
            const v17657 = function (enumValue, name) {
                var lName = lowercase(name);
                const v17645 = 'parse_as_' + lName;
                const v17646 = snakeToCamel(v17645);
                const v17648 = function (expr) {
                    const v17647 = parse(enumValue, expr);
                    return v17647;
                };
                sce[v17646] = v17648;
                const v17649 = 'get_trusted_' + lName;
                const v17650 = snakeToCamel(v17649);
                const v17652 = function (value) {
                    const v17651 = getTrusted(enumValue, value);
                    return v17651;
                };
                sce[v17650] = v17652;
                const v17653 = 'trust_as_' + lName;
                const v17654 = snakeToCamel(v17653);
                const v17656 = function (value) {
                    const v17655 = trustAs(enumValue, value);
                    return v17655;
                };
                sce[v17654] = v17656;
            };
            const v17658 = forEach(SCE_CONTEXTS, v17657);
            v17658;
            return sce;
        };
        this.$get = [
            '$parse',
            '$sceDelegate',
            v17659
        ];
    };
    const $SnifferProvider = function () {
        const v17732 = function ($window, $document) {
            var eventSupport = {};
            const v17660 = $window.nw;
            const v17661 = $window.nw;
            const v17662 = v17661.process;
            var isNw = v17660 && v17662;
            const v17663 = !isNw;
            const v17664 = $window.chrome;
            const v17665 = v17663 && v17664;
            const v17666 = $window.chrome;
            const v17667 = v17666.app;
            const v17668 = $window.chrome;
            const v17669 = v17668.app;
            const v17670 = v17669.runtime;
            const v17671 = v17667 && v17670;
            const v17672 = $window.chrome;
            const v17673 = v17672.app;
            const v17674 = !v17673;
            const v17675 = $window.chrome;
            const v17676 = v17675.runtime;
            const v17677 = v17674 && v17676;
            const v17678 = $window.chrome;
            const v17679 = v17678.runtime;
            const v17680 = v17679.id;
            const v17681 = v17677 && v17680;
            const v17682 = v17671 || v17681;
            var isChromePackagedApp = v17665 && v17682;
            const v17683 = !isChromePackagedApp;
            const v17684 = $window.history;
            const v17685 = v17683 && v17684;
            const v17686 = $window.history;
            const v17687 = v17686.pushState;
            var hasHistoryPushState = v17685 && v17687;
            const v17688 = $window.navigator;
            const v17689 = {};
            const v17690 = v17688 || v17689;
            const v17691 = v17690.userAgent;
            const v17692 = lowercase(v17691);
            const v17693 = /android (\d+)/.exec(v17692);
            const v17694 = [];
            const v17695 = v17693 || v17694;
            const v17696 = v17695[1];
            var android = toInt(v17696);
            const v17697 = $window.navigator;
            const v17698 = {};
            const v17699 = v17697 || v17698;
            const v17700 = v17699.userAgent;
            var boxee = /Boxee/i.test(v17700);
            const v17701 = $document[0];
            const v17702 = {};
            var document = v17701 || v17702;
            const v17703 = document.body;
            const v17704 = document.body;
            const v17705 = v17704.style;
            var bodyStyle = v17703 && v17705;
            var transitions = false;
            var animations = false;
            if (bodyStyle) {
                const v17706 = 'transition' in bodyStyle;
                const v17707 = 'webkitTransition' in bodyStyle;
                const v17708 = v17706 || v17707;
                const v17709 = !v17708;
                const v17710 = !v17709;
                transitions = v17710;
                const v17711 = 'animation' in bodyStyle;
                const v17712 = 'webkitAnimation' in bodyStyle;
                const v17713 = v17711 || v17712;
                const v17714 = !v17713;
                const v17715 = !v17714;
                animations = v17715;
            }
            const v17716 = android < 4;
            const v17717 = !v17716;
            const v17718 = hasHistoryPushState && v17717;
            const v17719 = !boxee;
            const v17720 = v17718 && v17719;
            const v17721 = !v17720;
            const v17722 = !v17721;
            const v17729 = function (event) {
                const v17723 = event === 'input';
                const v17724 = v17723 && msie;
                if (v17724) {
                    return false;
                }
                const v17725 = eventSupport[event];
                const v17726 = isUndefined(v17725);
                if (v17726) {
                    var divElm = document.createElement('div');
                    const v17727 = 'on' + event;
                    eventSupport[event] = v17727 in divElm;
                }
                const v17728 = eventSupport[event];
                return v17728;
            };
            const v17730 = csp();
            const v17731 = {};
            v17731.history = v17722;
            v17731.hasEvent = v17729;
            v17731.csp = v17730;
            v17731.transitions = transitions;
            v17731.animations = animations;
            v17731.android = android;
            return v17731;
        };
        this.$get = [
            '$window',
            '$document',
            v17732
        ];
    };
    const $$TaskTrackerFactoryProvider = function () {
        const v17734 = function (log) {
            const v17733 = new TaskTracker(log);
            return v17733;
        };
        const v17735 = valueFn(v17734);
        this.$get = v17735;
    };
    const TaskTracker = function (log) {
        var self = this;
        var taskCounts = {};
        var taskCallbacks = [];
        self.ALL_TASKS_TYPE = '$$all$$';
        var ALL_TASKS_TYPE = self.ALL_TASKS_TYPE;
        self.DEFAULT_TASK_TYPE = '$$default$$';
        var DEFAULT_TASK_TYPE = self.DEFAULT_TASK_TYPE;
        self.completeTask = completeTask;
        self.incTaskCount = incTaskCount;
        self.notifyWhenNoPendingTasks = notifyWhenNoPendingTasks;
        const completeTask = function (fn, taskType) {
            taskType = taskType || DEFAULT_TASK_TYPE;
            try {
                const v17736 = fn();
                v17736;
            } finally {
                const v17737 = decTaskCount(taskType);
                v17737;
                var countForType = taskCounts[taskType];
                var countForAll = taskCounts[ALL_TASKS_TYPE];
                const v17738 = !countForAll;
                const v17739 = !countForType;
                const v17740 = v17738 || v17739;
                if (v17740) {
                    let getNextCallback;
                    const v17741 = !countForAll;
                    if (v17741) {
                        getNextCallback = getLastCallback;
                    } else {
                        getNextCallback = getLastCallbackForType;
                    }
                    var nextCb;
                    while (nextCb = getNextCallback(taskType)) {
                        try {
                            const v17742 = nextCb();
                            v17742;
                        } catch (e) {
                            const v17743 = log.error(e);
                            v17743;
                        }
                    }
                }
            }
        };
        const decTaskCount = function (taskType) {
            taskType = taskType || DEFAULT_TASK_TYPE;
            const v17744 = taskCounts[taskType];
            if (v17744) {
                const v17745 = taskCounts[taskType];
                const v17746 = v17745--;
                v17746;
                const v17747 = taskCounts[ALL_TASKS_TYPE];
                const v17748 = v17747--;
                v17748;
            }
        };
        const getLastCallback = function () {
            var cbInfo = taskCallbacks.pop();
            const v17749 = cbInfo.cb;
            const v17750 = cbInfo && v17749;
            return v17750;
        };
        const getLastCallbackForType = function (taskType) {
            const v17751 = taskCallbacks.length;
            var i = v17751 - 1;
            let v17752 = i >= 0;
            while (v17752) {
                var cbInfo = taskCallbacks[i];
                const v17754 = cbInfo.type;
                const v17755 = v17754 === taskType;
                if (v17755) {
                    const v17756 = taskCallbacks.splice(i, 1);
                    v17756;
                    const v17757 = cbInfo.cb;
                    return v17757;
                }
                const v17753 = --i;
                v17752 = i >= 0;
            }
        };
        const incTaskCount = function (taskType) {
            taskType = taskType || DEFAULT_TASK_TYPE;
            const v17758 = taskCounts[taskType];
            const v17759 = v17758 || 0;
            taskCounts[taskType] = v17759 + 1;
            const v17760 = taskCounts[ALL_TASKS_TYPE];
            const v17761 = v17760 || 0;
            taskCounts[ALL_TASKS_TYPE] = v17761 + 1;
        };
        const notifyWhenNoPendingTasks = function (callback, taskType) {
            taskType = taskType || ALL_TASKS_TYPE;
            const v17762 = taskCounts[taskType];
            const v17763 = !v17762;
            if (v17763) {
                const v17764 = callback();
                v17764;
            } else {
                const v17765 = {
                    type: taskType,
                    cb: callback
                };
                const v17766 = taskCallbacks.push(v17765);
                v17766;
            }
        };
    };
    var $templateRequestMinErr = minErr('$templateRequest');
    const $TemplateRequestProvider = function () {
        var httpOptions;
        const v17767 = function (val) {
            if (val) {
                httpOptions = val;
                return this;
            }
            return httpOptions;
        };
        this.httpOptions = v17767;
        const v17798 = function ($exceptionHandler, $templateCache, $http, $q, $sce) {
            const handleRequestFn = function (tpl, ignoreRequestError) {
                const v17768 = handleRequestFn.totalPendingRequests;
                const v17769 = v17768++;
                v17769;
                const v17770 = isString(tpl);
                const v17771 = !v17770;
                const v17772 = $templateCache.get(tpl);
                const v17773 = isUndefined(v17772);
                const v17774 = v17771 || v17773;
                if (v17774) {
                    tpl = $sce.getTrustedResourceUrl(tpl);
                }
                const v17775 = $http.defaults;
                const v17776 = $http.defaults;
                const v17777 = v17776.transformResponse;
                var transformResponse = v17775 && v17777;
                const v17778 = isArray(transformResponse);
                if (v17778) {
                    const v17780 = function (transformer) {
                        const v17779 = transformer !== defaultHttpResponseTransform;
                        return v17779;
                    };
                    transformResponse = transformResponse.filter(v17780);
                } else {
                    const v17781 = transformResponse === defaultHttpResponseTransform;
                    if (v17781) {
                        transformResponse = null;
                    }
                }
                const v17782 = {
                    cache: $templateCache,
                    transformResponse: transformResponse
                };
                const v17783 = extend(v17782, httpOptions);
                const v17784 = $http.get(tpl, v17783);
                const v17787 = function () {
                    const v17785 = handleRequestFn.totalPendingRequests;
                    const v17786 = v17785--;
                    v17786;
                };
                const v17788 = v17784.finally(v17787);
                const v17791 = function (response) {
                    const v17789 = response.data;
                    const v17790 = $templateCache.put(tpl, v17789);
                    return v17790;
                };
                const v17792 = v17788.then(v17791, handleError);
                return v17792;
                const handleError = function (resp) {
                    const v17793 = !ignoreRequestError;
                    if (v17793) {
                        const v17794 = resp.status;
                        const v17795 = resp.statusText;
                        resp = $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, v17794, v17795);
                        const v17796 = $exceptionHandler(resp);
                        v17796;
                    }
                    const v17797 = $q.reject(resp);
                    return v17797;
                };
            };
            handleRequestFn.totalPendingRequests = 0;
            return handleRequestFn;
        };
        this.$get = [
            '$exceptionHandler',
            '$templateCache',
            '$http',
            '$q',
            '$sce',
            v17798
        ];
    };
    const $$TestabilityProvider = function () {
        const v17834 = function ($rootScope, $browser, $location) {
            var testability = {};
            const v17813 = function (element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName('ng-binding');
                var matches = [];
                const v17811 = function (binding) {
                    const v17799 = angular.element(binding);
                    var dataBinding = v17799.data('$binding');
                    if (dataBinding) {
                        const v17809 = function (bindingName) {
                            if (opt_exactMatch) {
                                const v17800 = escapeForRegexp(expression);
                                const v17801 = '(^|\\s)' + v17800;
                                const v17802 = v17801 + '(\\s|\\||$)';
                                var matcher = new RegExp(v17802);
                                const v17803 = matcher.test(bindingName);
                                if (v17803) {
                                    const v17804 = matches.push(binding);
                                    v17804;
                                }
                            } else {
                                const v17805 = bindingName.indexOf(expression);
                                const v17806 = -1;
                                const v17807 = v17805 !== v17806;
                                if (v17807) {
                                    const v17808 = matches.push(binding);
                                    v17808;
                                }
                            }
                        };
                        const v17810 = forEach(dataBinding, v17809);
                        v17810;
                    }
                };
                const v17812 = forEach(bindings, v17811);
                v17812;
                return matches;
            };
            testability.findBindings = v17813;
            const v17824 = function (element, expression, opt_exactMatch) {
                var prefixes = [
                    'ng-',
                    'data-ng-',
                    'ng\\:'
                ];
                var p = 0;
                const v17814 = prefixes.length;
                let v17815 = p < v17814;
                while (v17815) {
                    let attributeEquals;
                    if (opt_exactMatch) {
                        attributeEquals = '=';
                    } else {
                        attributeEquals = '*=';
                    }
                    const v17817 = prefixes[p];
                    const v17818 = '[' + v17817;
                    const v17819 = v17818 + 'model';
                    const v17820 = v17819 + attributeEquals;
                    const v17821 = v17820 + '"';
                    const v17822 = v17821 + expression;
                    var selector = v17822 + '"]';
                    var elements = element.querySelectorAll(selector);
                    const v17823 = elements.length;
                    if (v17823) {
                        return elements;
                    }
                    const v17816 = ++p;
                    v17815 = p < v17814;
                }
            };
            testability.findModels = v17824;
            const v17826 = function () {
                const v17825 = $location.url();
                return v17825;
            };
            testability.getLocation = v17826;
            const v17831 = function (url) {
                const v17827 = $location.url();
                const v17828 = url !== v17827;
                if (v17828) {
                    const v17829 = $location.url(url);
                    v17829;
                    const v17830 = $rootScope.$digest();
                    v17830;
                }
            };
            testability.setLocation = v17831;
            const v17833 = function (callback) {
                const v17832 = $browser.notifyWhenNoOutstandingRequests(callback);
                v17832;
            };
            testability.whenStable = v17833;
            return testability;
        };
        this.$get = [
            '$rootScope',
            '$browser',
            '$location',
            v17834
        ];
    };
    var $timeoutMinErr = minErr('$timeout');
    const $TimeoutProvider = function () {
        const v17865 = function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
            var deferreds = {};
            const timeout = function (fn, delay, invokeApply) {
                const v17835 = isFunction(fn);
                const v17836 = !v17835;
                if (v17836) {
                    invokeApply = delay;
                    delay = fn;
                    fn = noop;
                }
                var args = sliceArgs(arguments, 3);
                const v17837 = isDefined(invokeApply);
                const v17838 = !invokeApply;
                var skipApply = v17837 && v17838;
                let v17839;
                if (skipApply) {
                    v17839 = $$q;
                } else {
                    v17839 = $q;
                }
                var deferred = v17839.defer();
                var promise = deferred.promise;
                var timeoutId;
                const v17849 = function () {
                    try {
                        const v17840 = fn.apply(null, args);
                        const v17841 = deferred.resolve(v17840);
                        v17841;
                    } catch (e) {
                        const v17842 = deferred.reject(e);
                        v17842;
                        const v17843 = $exceptionHandler(e);
                        v17843;
                    } finally {
                        const v17844 = promise.$$timeoutId;
                        const v17845 = deferreds[v17844];
                        const v17846 = delete v17845;
                        v17846;
                    }
                    const v17847 = !skipApply;
                    if (v17847) {
                        const v17848 = $rootScope.$apply();
                        v17848;
                    }
                };
                timeoutId = $browser.defer(v17849, delay, '$timeout');
                promise.$$timeoutId = timeoutId;
                deferreds[timeoutId] = deferred;
                return promise;
            };
            const v17864 = function (promise) {
                const v17850 = !promise;
                if (v17850) {
                    return false;
                }
                const v17851 = promise.hasOwnProperty('$$timeoutId');
                const v17852 = !v17851;
                if (v17852) {
                    const v17853 = $timeoutMinErr('badprom', '`$timeout.cancel()` called with a promise that was not generated by `$timeout()`.');
                    throw v17853;
                }
                const v17854 = promise.$$timeoutId;
                const v17855 = deferreds.hasOwnProperty(v17854);
                const v17856 = !v17855;
                if (v17856) {
                    return false;
                }
                var id = promise.$$timeoutId;
                var deferred = deferreds[id];
                const v17857 = deferred.promise;
                const v17858 = markQExceptionHandled(v17857);
                v17858;
                const v17859 = deferred.reject('canceled');
                v17859;
                const v17860 = deferreds[id];
                const v17861 = delete v17860;
                v17861;
                const v17862 = $browser.defer;
                const v17863 = v17862.cancel(id);
                return v17863;
            };
            timeout.cancel = v17864;
            return timeout;
        };
        this.$get = [
            '$rootScope',
            '$browser',
            '$q',
            '$$q',
            '$exceptionHandler',
            v17865
        ];
    };
    const v17866 = window.document;
    var urlParsingNode = v17866.createElement('a');
    const v17867 = window.location;
    const v17868 = v17867.href;
    var originUrl = urlResolve(v17868);
    var baseUrlParsingNode;
    urlParsingNode.href = 'http://[::1]';
    const v17869 = urlParsingNode.hostname;
    var ipv6InBrackets = v17869 === '[::1]';
    const urlResolve = function (url) {
        const v17870 = isString(url);
        const v17871 = !v17870;
        if (v17871) {
            return url;
        }
        var href = url;
        if (msie) {
            const v17872 = urlParsingNode.setAttribute('href', href);
            v17872;
            href = urlParsingNode.href;
        }
        const v17873 = urlParsingNode.setAttribute('href', href);
        v17873;
        var hostname = urlParsingNode.hostname;
        const v17874 = !ipv6InBrackets;
        const v17875 = hostname.indexOf(':');
        const v17876 = -1;
        const v17877 = v17875 > v17876;
        const v17878 = v17874 && v17877;
        if (v17878) {
            const v17879 = '[' + hostname;
            hostname = v17879 + ']';
        }
        const v17880 = urlParsingNode.href;
        const v17881 = urlParsingNode.protocol;
        const v17882 = urlParsingNode.protocol;
        const v17883 = v17882.replace(/:$/, '');
        let v17884;
        if (v17881) {
            v17884 = v17883;
        } else {
            v17884 = '';
        }
        const v17885 = urlParsingNode.host;
        const v17886 = urlParsingNode.search;
        const v17887 = urlParsingNode.search;
        const v17888 = v17887.replace(/^\?/, '');
        let v17889;
        if (v17886) {
            v17889 = v17888;
        } else {
            v17889 = '';
        }
        const v17890 = urlParsingNode.hash;
        const v17891 = urlParsingNode.hash;
        const v17892 = v17891.replace(/^#/, '');
        let v17893;
        if (v17890) {
            v17893 = v17892;
        } else {
            v17893 = '';
        }
        const v17894 = urlParsingNode.port;
        const v17895 = urlParsingNode.pathname;
        const v17896 = v17895.charAt(0);
        const v17897 = v17896 === '/';
        const v17898 = urlParsingNode.pathname;
        const v17899 = urlParsingNode.pathname;
        const v17900 = '/' + v17899;
        let v17901;
        if (v17897) {
            v17901 = v17898;
        } else {
            v17901 = v17900;
        }
        const v17902 = {};
        v17902.href = v17880;
        v17902.protocol = v17884;
        v17902.host = v17885;
        v17902.search = v17889;
        v17902.hash = v17893;
        v17902.hostname = hostname;
        v17902.port = v17894;
        v17902.pathname = v17901;
        return v17902;
    };
    const urlIsSameOrigin = function (requestUrl) {
        const v17903 = urlsAreSameOrigin(requestUrl, originUrl);
        return v17903;
    };
    const urlIsSameOriginAsBaseUrl = function (requestUrl) {
        const v17904 = getBaseUrl();
        const v17905 = urlsAreSameOrigin(requestUrl, v17904);
        return v17905;
    };
    const urlIsAllowedOriginFactory = function (whitelistedOriginUrls) {
        const v17906 = [originUrl];
        const v17907 = whitelistedOriginUrls.map(urlResolve);
        var parsedAllowedOriginUrls = v17906.concat(v17907);
        const v17910 = function urlIsAllowedOrigin(requestUrl) {
            var parsedUrl = urlResolve(requestUrl);
            const v17908 = urlsAreSameOrigin.bind(null, parsedUrl);
            const v17909 = parsedAllowedOriginUrls.some(v17908);
            return v17909;
        };
        return v17910;
    };
    const urlsAreSameOrigin = function (url1, url2) {
        url1 = urlResolve(url1);
        url2 = urlResolve(url2);
        const v17911 = url1.protocol;
        const v17912 = url2.protocol;
        const v17913 = v17911 === v17912;
        const v17914 = url1.host;
        const v17915 = url2.host;
        const v17916 = v17914 === v17915;
        const v17917 = v17913 && v17916;
        return v17917;
    };
    const getBaseUrl = function () {
        const v17918 = window.document;
        const v17919 = v17918.baseURI;
        if (v17919) {
            const v17920 = window.document;
            const v17921 = v17920.baseURI;
            return v17921;
        }
        const v17922 = !baseUrlParsingNode;
        if (v17922) {
            const v17923 = window.document;
            baseUrlParsingNode = v17923.createElement('a');
            baseUrlParsingNode.href = '.';
            baseUrlParsingNode = baseUrlParsingNode.cloneNode(false);
        }
        const v17924 = baseUrlParsingNode.href;
        return v17924;
    };
    const $WindowProvider = function () {
        const v17925 = valueFn(window);
        this.$get = v17925;
    };
    const $$CookieReader = function ($document) {
        const v17926 = $document[0];
        const v17927 = {};
        var rawDocument = v17926 || v17927;
        var lastCookies = {};
        var lastCookieString = '';
        const safeGetCookie = function (rawDocument) {
            try {
                const v17928 = rawDocument.cookie;
                const v17929 = v17928 || '';
                return v17929;
            } catch (e) {
                return '';
            }
        };
        const safeDecodeURIComponent = function (str) {
            try {
                const v17930 = decodeURIComponent(str);
                return v17930;
            } catch (e) {
                return str;
            }
        };
        const v17942 = function () {
            var cookieArray;
            var cookie;
            var i;
            var index;
            var name;
            var currentCookieString = safeGetCookie(rawDocument);
            const v17931 = currentCookieString !== lastCookieString;
            if (v17931) {
                lastCookieString = currentCookieString;
                cookieArray = lastCookieString.split('; ');
                lastCookies = {};
                i = 0
                const v17932 = cookieArray.length;
                let v17933 = i < v17932;
                while (v17933) {
                    cookie = cookieArray[i];
                    index = cookie.indexOf('=');
                    const v17935 = index > 0;
                    if (v17935) {
                        const v17936 = cookie.substring(0, index);
                        name = safeDecodeURIComponent(v17936);
                        const v17937 = lastCookies[name];
                        const v17938 = isUndefined(v17937);
                        if (v17938) {
                            const v17939 = index + 1;
                            const v17940 = cookie.substring(v17939);
                            const v17941 = safeDecodeURIComponent(v17940);
                            lastCookies[name] = v17941;
                        }
                    }
                    const v17934 = i++;
                    v17933 = i < v17932;
                }
            }
            return lastCookies;
        };
        return v17942;
    };
    $$CookieReader.$inject = ['$document'];
    const $$CookieReaderProvider = function () {
        this.$get = $$CookieReader;
    };
    $FilterProvider.$inject = ['$provide'];
    const $FilterProvider = function ($provide) {
        var suffix = 'Filter';
        const register = function (name, factory) {
            const v17943 = isObject(name);
            if (v17943) {
                var filters = {};
                const v17945 = function (filter, key) {
                    const v17944 = register(key, filter);
                    filters[key] = v17944;
                };
                const v17946 = forEach(name, v17945);
                v17946;
                return filters;
            } else {
                const v17947 = name + suffix;
                const v17948 = $provide.factory(v17947, factory);
                return v17948;
            }
        };
        this.register = register;
        const v17952 = function ($injector) {
            const v17951 = function (name) {
                const v17949 = name + suffix;
                const v17950 = $injector.get(v17949);
                return v17950;
            };
            return v17951;
        };
        this.$get = [
            '$injector',
            v17952
        ];
        const v17953 = register('currency', currencyFilter);
        v17953;
        const v17954 = register('date', dateFilter);
        v17954;
        const v17955 = register('filter', filterFilter);
        v17955;
        const v17956 = register('json', jsonFilter);
        v17956;
        const v17957 = register('limitTo', limitToFilter);
        v17957;
        const v17958 = register('lowercase', lowercaseFilter);
        v17958;
        const v17959 = register('number', numberFilter);
        v17959;
        const v17960 = register('orderBy', orderByFilter);
        v17960;
        const v17961 = register('uppercase', uppercaseFilter);
        v17961;
    };
    const filterFilter = function () {
        const v17970 = function (array, expression, comparator, anyPropertyKey) {
            const v17962 = isArrayLike(array);
            const v17963 = !v17962;
            if (v17963) {
                const v17964 = array == null;
                if (v17964) {
                    return array;
                } else {
                    const v17965 = minErr('filter');
                    const v17966 = v17965('notarray', 'Expected array but received: {0}', array);
                    throw v17966;
                }
            }
            anyPropertyKey = anyPropertyKey || '$';
            var expressionType = getTypeForFilter(expression);
            var predicateFn;
            var matchAgainstAnyProp;
            switch (expressionType) {
            case 'function':
                predicateFn = expression;
                break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
                matchAgainstAnyProp = true;
            case 'object':
                predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                break;
            default:
                return array;
            }
            const v17967 = Array.prototype;
            const v17968 = v17967.filter;
            const v17969 = v17968.call(array, predicateFn);
            return v17969;
        };
        return v17970;
    };
    const createPredicateFn = function (expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
        const v17971 = isObject(expression);
        const v17972 = anyPropertyKey in expression;
        var shouldMatchPrimitives = v17971 && v17972;
        var predicateFn;
        const v17973 = comparator === true;
        if (v17973) {
            comparator = equals;
        } else {
            const v17974 = isFunction(comparator);
            const v17975 = !v17974;
            if (v17975) {
                const v17992 = function (actual, expected) {
                    const v17976 = isUndefined(actual);
                    if (v17976) {
                        return false;
                    }
                    const v17977 = actual === null;
                    const v17978 = expected === null;
                    const v17979 = v17977 || v17978;
                    if (v17979) {
                        const v17980 = actual === expected;
                        return v17980;
                    }
                    const v17981 = isObject(expected);
                    const v17982 = isObject(actual);
                    const v17983 = hasCustomToString(actual);
                    const v17984 = !v17983;
                    const v17985 = v17982 && v17984;
                    const v17986 = v17981 || v17985;
                    if (v17986) {
                        return false;
                    }
                    const v17987 = '' + actual;
                    actual = lowercase(v17987);
                    const v17988 = '' + expected;
                    expected = lowercase(v17988);
                    const v17989 = actual.indexOf(expected);
                    const v17990 = -1;
                    const v17991 = v17989 !== v17990;
                    return v17991;
                };
                comparator = v17992;
            }
        }
        const v17999 = function (item) {
            const v17993 = isObject(item);
            const v17994 = !v17993;
            const v17995 = shouldMatchPrimitives && v17994;
            if (v17995) {
                const v17996 = expression[anyPropertyKey];
                const v17997 = deepCompare(item, v17996, comparator, anyPropertyKey, false);
                return v17997;
            }
            const v17998 = deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
            return v17998;
        };
        predicateFn = v17999;
        return predicateFn;
    };
    const deepCompare = function (actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        const v18000 = expectedType === 'string';
        const v18001 = expected.charAt(0);
        const v18002 = v18001 === '!';
        const v18003 = v18000 && v18002;
        if (v18003) {
            const v18004 = expected.substring(1);
            const v18005 = deepCompare(actual, v18004, comparator, anyPropertyKey, matchAgainstAnyProp);
            const v18006 = !v18005;
            return v18006;
        } else {
            const v18007 = isArray(actual);
            if (v18007) {
                const v18009 = function (item) {
                    const v18008 = deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
                    return v18008;
                };
                const v18010 = actual.some(v18009);
                return v18010;
            }
        }
        switch (actualType) {
        case 'object':
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) {
                    const v18011 = key.charAt;
                    const v18012 = key.charAt(0);
                    const v18013 = v18012 !== '$';
                    const v18014 = v18011 && v18013;
                    const v18015 = actual[key];
                    const v18016 = deepCompare(v18015, expected, comparator, anyPropertyKey, true);
                    const v18017 = v18014 && v18016;
                    if (v18017) {
                        return true;
                    }
                }
                const v18018 = deepCompare(actual, expected, comparator, anyPropertyKey, false);
                let v18019;
                if (dontMatchWholeObject) {
                    v18019 = false;
                } else {
                    v18019 = v18018;
                }
                return v18019;
            } else {
                const v18020 = expectedType === 'object';
                if (v18020) {
                    for (key in expected) {
                        var expectedVal = expected[key];
                        const v18021 = isFunction(expectedVal);
                        const v18022 = isUndefined(expectedVal);
                        const v18023 = v18021 || v18022;
                        if (v18023) {
                            continue;
                        }
                        var matchAnyProperty = key === anyPropertyKey;
                        let actualVal;
                        const v18024 = actual[key];
                        if (matchAnyProperty) {
                            actualVal = actual;
                        } else {
                            actualVal = v18024;
                        }
                        const v18025 = deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty);
                        const v18026 = !v18025;
                        if (v18026) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    const v18027 = comparator(actual, expected);
                    return v18027;
                }
            }
        case 'function':
            return false;
        default:
            const v18028 = comparator(actual, expected);
            return v18028;
        }
    };
    const getTypeForFilter = function (val) {
        const v18029 = val === null;
        const v18030 = typeof val;
        let v18031;
        if (v18029) {
            v18031 = 'null';
        } else {
            v18031 = v18030;
        }
        return v18031;
    };
    var MAX_DIGITS = 22;
    var DECIMAL_SEP = '.';
    var ZERO_CHAR = '0';
    currencyFilter.$inject = ['$locale'];
    const currencyFilter = function ($locale) {
        var formats = $locale.NUMBER_FORMATS;
        const v18045 = function (amount, currencySymbol, fractionSize) {
            const v18032 = isUndefined(currencySymbol);
            if (v18032) {
                currencySymbol = formats.CURRENCY_SYM;
            }
            const v18033 = isUndefined(fractionSize);
            if (v18033) {
                const v18034 = formats.PATTERNS;
                const v18035 = v18034[1];
                fractionSize = v18035.maxFrac;
            }
            let currencySymbolRe;
            const v18036 = !currencySymbol;
            if (v18036) {
                currencySymbolRe = /\s*\u00A4\s*/g;
            } else {
                currencySymbolRe = /\u00A4/g;
            }
            const v18037 = amount == null;
            const v18038 = formats.PATTERNS;
            const v18039 = v18038[1];
            const v18040 = formats.GROUP_SEP;
            const v18041 = formats.DECIMAL_SEP;
            const v18042 = formatNumber(amount, v18039, v18040, v18041, fractionSize);
            const v18043 = v18042.replace(currencySymbolRe, currencySymbol);
            let v18044;
            if (v18037) {
                v18044 = amount;
            } else {
                v18044 = v18043;
            }
            return v18044;
        };
        return v18045;
    };
    numberFilter.$inject = ['$locale'];
    const numberFilter = function ($locale) {
        var formats = $locale.NUMBER_FORMATS;
        const v18053 = function (number, fractionSize) {
            const v18046 = number == null;
            const v18047 = formats.PATTERNS;
            const v18048 = v18047[0];
            const v18049 = formats.GROUP_SEP;
            const v18050 = formats.DECIMAL_SEP;
            const v18051 = formatNumber(number, v18048, v18049, v18050, fractionSize);
            let v18052;
            if (v18046) {
                v18052 = number;
            } else {
                v18052 = v18051;
            }
            return v18052;
        };
        return v18053;
    };
    const parse = function (numStr) {
        var exponent = 0;
        var digits;
        var numberOfIntegerDigits;
        var i;
        var j;
        var zeros;
        const v18054 = -1;
        const v18055 = (numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > v18054;
        if (v18055) {
            numStr = numStr.replace(DECIMAL_SEP, '');
        }
        const v18056 = (i = numStr.search(/e/i)) > 0;
        if (v18056) {
            const v18057 = numberOfIntegerDigits < 0;
            if (v18057) {
                numberOfIntegerDigits = i;
            }
            const v18058 = i + 1;
            const v18059 = numStr.slice(v18058);
            const v18060 = +v18059;
            numberOfIntegerDigits += v18060;
            numStr = numStr.substring(0, i);
        } else {
            const v18061 = numberOfIntegerDigits < 0;
            if (v18061) {
                numberOfIntegerDigits = numStr.length;
            }
        }
        (i = 0)
        const v18062 = numStr.charAt(i);
        let v18063 = v18062 === ZERO_CHAR;
        while (v18063) {
            const v18064 = i++;
            v18063 = v18062 === ZERO_CHAR;
        }
        const v18065 = i === (zeros = numStr.length);
        if (v18065) {
            digits = [0];
            numberOfIntegerDigits = 1;
        } else {
            const v18066 = zeros--;
            v18066;
            const v18067 = numStr.charAt(zeros);
            let v18068 = v18067 === ZERO_CHAR;
            while (v18068) {
                const v18069 = zeros--;
                v18069;
                v18068 = v18067 === ZERO_CHAR;
            }
            numberOfIntegerDigits -= i;
            digits = [];
            j = 0
            let v18070 = i <= zeros;
            while (v18070) {
                const v18073 = numStr.charAt(i);
                const v18074 = +v18073;
                digits[j] = v18074;
                const v18071 = i++;
                const v18072 = j++;
                v18070 = i <= zeros;
            }
        }
        const v18075 = numberOfIntegerDigits > MAX_DIGITS;
        if (v18075) {
            const v18076 = MAX_DIGITS - 1;
            digits = digits.splice(0, v18076);
            exponent = numberOfIntegerDigits - 1;
            numberOfIntegerDigits = 1;
        }
        const v18077 = {};
        v18077.d = digits;
        v18077.e = exponent;
        v18077.i = numberOfIntegerDigits;
        return v18077;
    };
    const roundNumber = function (parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d;
        const v18078 = digits.length;
        const v18079 = parsedNumber.i;
        var fractionLen = v18078 - v18079;
        const v18080 = isUndefined(fractionSize);
        const v18081 = Math.max(minFrac, fractionLen);
        const v18082 = Math.min(v18081, maxFrac);
        const v18083 = +fractionSize;
        if (v18080) {
            fractionSize = v18082;
        } else {
            fractionSize = v18083;
        }
        const v18084 = parsedNumber.i;
        var roundAt = fractionSize + v18084;
        var digit = digits[roundAt];
        const v18085 = roundAt > 0;
        if (v18085) {
            const v18086 = parsedNumber.i;
            const v18087 = Math.max(v18086, roundAt);
            const v18088 = digits.splice(v18087);
            v18088;
            var j = roundAt;
            const v18089 = digits.length;
            let v18090 = j < v18089;
            while (v18090) {
                digits[j] = 0;
                const v18091 = j++;
                v18090 = j < v18089;
            }
        } else {
            fractionLen = Math.max(0, fractionLen);
            parsedNumber.i = 1;
            roundAt = fractionSize + 1;
            const v18092 = Math.max(1, roundAt);
            digits.length = v18092;
            digits[0] = 0;
            var i = 1;
            let v18093 = i < roundAt;
            while (v18093) {
                digits[i] = 0;
                const v18094 = i++;
                v18093 = i < roundAt;
            }
        }
        const v18095 = digit >= 5;
        if (v18095) {
            const v18096 = roundAt - 1;
            const v18097 = v18096 < 0;
            if (v18097) {
                var k = 0;
                let v18098 = k > roundAt;
                while (v18098) {
                    const v18100 = digits.unshift(0);
                    v18100;
                    const v18101 = parsedNumber.i;
                    const v18102 = v18101++;
                    v18102;
                    const v18099 = k--;
                    v18098 = k > roundAt;
                }
                const v18103 = digits.unshift(1);
                v18103;
                const v18104 = parsedNumber.i;
                const v18105 = v18104++;
                v18105;
            } else {
                const v18106 = roundAt - 1;
                const v18107 = digits[v18106];
                const v18108 = v18107++;
                v18108;
            }
        }
        const v18109 = Math.max(0, fractionSize);
        let v18110 = fractionLen < v18109;
        while (v18110) {
            const v18112 = digits.push(0);
            v18112;
            const v18111 = fractionLen++;
            v18110 = fractionLen < v18109;
        }
        const v18115 = function (carry, d, i, digits) {
            d = d + carry;
            digits[i] = d % 10;
            const v18113 = d / 10;
            const v18114 = Math.floor(v18113);
            return v18114;
        };
        var carry = digits.reduceRight(v18115, 0);
        if (carry) {
            const v18116 = digits.unshift(carry);
            v18116;
            const v18117 = parsedNumber.i;
            const v18118 = v18117++;
            v18118;
        }
    };
    const formatNumber = function (number, pattern, groupSep, decimalSep, fractionSize) {
        const v18119 = isString(number);
        const v18120 = isNumber(number);
        const v18121 = v18119 || v18120;
        const v18122 = !v18121;
        const v18123 = isNaN(number);
        const v18124 = v18122 || v18123;
        if (v18124) {
            return '';
        }
        const v18125 = isFinite(number);
        const v18126 = !v18125;
        var isInfinity = v18126;
        var isZero = false;
        const v18127 = Math.abs(number);
        var numStr = v18127 + '';
        var formattedText = '';
        var parsedNumber;
        if (isInfinity) {
            formattedText = '\u221E';
        } else {
            parsedNumber = parse(numStr);
            const v18128 = pattern.minFrac;
            const v18129 = pattern.maxFrac;
            const v18130 = roundNumber(parsedNumber, fractionSize, v18128, v18129);
            v18130;
            var digits = parsedNumber.d;
            var integerLen = parsedNumber.i;
            var exponent = parsedNumber.e;
            var decimals = [];
            const v18133 = function (isZero, d) {
                const v18131 = !d;
                const v18132 = isZero && v18131;
                return v18132;
            };
            isZero = digits.reduce(v18133, true);
            let v18134 = integerLen < 0;
            while (v18134) {
                const v18135 = digits.unshift(0);
                v18135;
                const v18136 = integerLen++;
                v18136;
                v18134 = integerLen < 0;
            }
            const v18137 = integerLen > 0;
            if (v18137) {
                const v18138 = digits.length;
                decimals = digits.splice(integerLen, v18138);
            } else {
                decimals = digits;
                digits = [0];
            }
            var groups = [];
            const v18139 = digits.length;
            const v18140 = pattern.lgSize;
            const v18141 = v18139 >= v18140;
            if (v18141) {
                const v18142 = pattern.lgSize;
                const v18143 = -v18142;
                const v18144 = digits.length;
                const v18145 = digits.splice(v18143, v18144);
                const v18146 = v18145.join('');
                const v18147 = groups.unshift(v18146);
                v18147;
            }
            const v18148 = digits.length;
            const v18149 = pattern.gSize;
            let v18150 = v18148 > v18149;
            while (v18150) {
                const v18151 = pattern.gSize;
                const v18152 = -v18151;
                const v18153 = digits.length;
                const v18154 = digits.splice(v18152, v18153);
                const v18155 = v18154.join('');
                const v18156 = groups.unshift(v18155);
                v18156;
                v18150 = v18148 > v18149;
            }
            const v18157 = digits.length;
            if (v18157) {
                const v18158 = digits.join('');
                const v18159 = groups.unshift(v18158);
                v18159;
            }
            formattedText = groups.join(groupSep);
            const v18160 = decimals.length;
            if (v18160) {
                const v18161 = decimals.join('');
                formattedText += decimalSep + v18161;
            }
            if (exponent) {
                formattedText += 'e+' + exponent;
            }
        }
        const v18162 = number < 0;
        const v18163 = !isZero;
        const v18164 = v18162 && v18163;
        if (v18164) {
            const v18165 = pattern.negPre;
            const v18166 = v18165 + formattedText;
            const v18167 = pattern.negSuf;
            const v18168 = v18166 + v18167;
            return v18168;
        } else {
            const v18169 = pattern.posPre;
            const v18170 = v18169 + formattedText;
            const v18171 = pattern.posSuf;
            const v18172 = v18170 + v18171;
            return v18172;
        }
    };
    const padNumber = function (num, digits, trim, negWrap) {
        var neg = '';
        const v18173 = num < 0;
        const v18174 = num <= 0;
        const v18175 = negWrap && v18174;
        const v18176 = v18173 || v18175;
        if (v18176) {
            if (negWrap) {
                const v18177 = -num;
                num = v18177 + 1;
            } else {
                const v18178 = -num;
                num = v18178;
                neg = '-';
            }
        }
        num = '' + num;
        const v18179 = num.length;
        let v18180 = v18179 < digits;
        while (v18180) {
            num = ZERO_CHAR + num;
            v18180 = v18179 < digits;
        }
        if (trim) {
            const v18181 = num.length;
            const v18182 = v18181 - digits;
            num = num.substr(v18182);
        }
        const v18183 = neg + num;
        return v18183;
    };
    const dateGetter = function (name, size, offset, trim, negWrap) {
        offset = offset || 0;
        const v18194 = function (date) {
            const v18184 = 'get' + name;
            var value = date[v18184]();
            const v18185 = offset > 0;
            const v18186 = -offset;
            const v18187 = value > v18186;
            const v18188 = v18185 || v18187;
            if (v18188) {
                value += offset;
            }
            const v18189 = value === 0;
            const v18190 = -12;
            const v18191 = offset === v18190;
            const v18192 = v18189 && v18191;
            if (v18192) {
                value = 12;
            }
            const v18193 = padNumber(value, size, trim, negWrap);
            return v18193;
        };
        return v18194;
    };
    const dateStrGetter = function (name, shortForm, standAlone) {
        const v18201 = function (date, formats) {
            const v18195 = 'get' + name;
            var value = date[v18195]();
            let v18196;
            if (standAlone) {
                v18196 = 'STANDALONE';
            } else {
                v18196 = '';
            }
            let v18197;
            if (shortForm) {
                v18197 = 'SHORT';
            } else {
                v18197 = '';
            }
            var propPrefix = v18196 + v18197;
            const v18198 = propPrefix + name;
            var get = uppercase(v18198);
            const v18199 = formats[get];
            const v18200 = v18199[value];
            return v18200;
        };
        return v18201;
    };
    const timeZoneGetter = function (date, formats, offset) {
        const v18202 = -1;
        var zone = v18202 * offset;
        let paddedZone;
        const v18203 = zone >= 0;
        if (v18203) {
            paddedZone = '+';
        } else {
            paddedZone = '';
        }
        const v18204 = zone > 0;
        let v18205;
        if (v18204) {
            v18205 = 'floor';
        } else {
            v18205 = 'ceil';
        }
        const v18206 = zone / 60;
        const v18207 = Math[v18205](v18206);
        const v18208 = padNumber(v18207, 2);
        const v18209 = zone % 60;
        const v18210 = Math.abs(v18209);
        const v18211 = padNumber(v18210, 2);
        paddedZone += v18208 + v18211;
        return paddedZone;
    };
    const getFirstThursdayOfYear = function (year) {
        const v18212 = new Date(year, 0, 1);
        var dayOfWeekOnFirst = v18212.getDay();
        const v18213 = dayOfWeekOnFirst <= 4;
        let v18214;
        if (v18213) {
            v18214 = 5;
        } else {
            v18214 = 12;
        }
        const v18215 = v18214 - dayOfWeekOnFirst;
        const v18216 = new Date(year, 0, v18215);
        return v18216;
    };
    const getThursdayThisWeek = function (datetime) {
        const v18217 = datetime.getFullYear();
        const v18218 = datetime.getMonth();
        const v18219 = datetime.getDate();
        const v18220 = datetime.getDay();
        const v18221 = 4 - v18220;
        const v18222 = v18219 + v18221;
        const v18223 = new Date(v18217, v18218, v18222);
        return v18223;
    };
    const weekGetter = function (size) {
        const v18230 = function (date) {
            const v18224 = date.getFullYear();
            var firstThurs = getFirstThursdayOfYear(v18224);
            var thisThurs = getThursdayThisWeek(date);
            const v18225 = +thisThurs;
            const v18226 = +firstThurs;
            var diff = v18225 - v18226;
            const v18227 = diff / 604800000;
            const v18228 = Math.round(v18227);
            var result = 1 + v18228;
            const v18229 = padNumber(result, size);
            return v18229;
        };
        return v18230;
    };
    const ampmGetter = function (date, formats) {
        const v18231 = date.getHours();
        const v18232 = v18231 < 12;
        const v18233 = formats.AMPMS;
        const v18234 = v18233[0];
        const v18235 = formats.AMPMS;
        const v18236 = v18235[1];
        let v18237;
        if (v18232) {
            v18237 = v18234;
        } else {
            v18237 = v18236;
        }
        return v18237;
    };
    const eraGetter = function (date, formats) {
        const v18238 = date.getFullYear();
        const v18239 = v18238 <= 0;
        const v18240 = formats.ERAS;
        const v18241 = v18240[0];
        const v18242 = formats.ERAS;
        const v18243 = v18242[1];
        let v18244;
        if (v18239) {
            v18244 = v18241;
        } else {
            v18244 = v18243;
        }
        return v18244;
    };
    const longEraGetter = function (date, formats) {
        const v18245 = date.getFullYear();
        const v18246 = v18245 <= 0;
        const v18247 = formats.ERANAMES;
        const v18248 = v18247[0];
        const v18249 = formats.ERANAMES;
        const v18250 = v18249[1];
        let v18251;
        if (v18246) {
            v18251 = v18248;
        } else {
            v18251 = v18250;
        }
        return v18251;
    };
    const v18252 = dateGetter('FullYear', 4, 0, false, true);
    const v18253 = dateGetter('FullYear', 2, 0, true, true);
    const v18254 = dateGetter('FullYear', 1, 0, false, true);
    const v18255 = dateStrGetter('Month');
    const v18256 = dateStrGetter('Month', true);
    const v18257 = dateGetter('Month', 2, 1);
    const v18258 = dateGetter('Month', 1, 1);
    const v18259 = dateStrGetter('Month', false, true);
    const v18260 = dateGetter('Date', 2);
    const v18261 = dateGetter('Date', 1);
    const v18262 = dateGetter('Hours', 2);
    const v18263 = dateGetter('Hours', 1);
    const v18264 = -12;
    const v18265 = dateGetter('Hours', 2, v18264);
    const v18266 = -12;
    const v18267 = dateGetter('Hours', 1, v18266);
    const v18268 = dateGetter('Minutes', 2);
    const v18269 = dateGetter('Minutes', 1);
    const v18270 = dateGetter('Seconds', 2);
    const v18271 = dateGetter('Seconds', 1);
    const v18272 = dateGetter('Milliseconds', 3);
    const v18273 = dateStrGetter('Day');
    const v18274 = dateStrGetter('Day', true);
    const v18275 = weekGetter(2);
    const v18276 = weekGetter(1);
    var DATE_FORMATS = {};
    DATE_FORMATS.yyyy = v18252;
    DATE_FORMATS.yy = v18253;
    DATE_FORMATS.y = v18254;
    DATE_FORMATS.MMMM = v18255;
    DATE_FORMATS.MMM = v18256;
    DATE_FORMATS.MM = v18257;
    DATE_FORMATS.M = v18258;
    DATE_FORMATS.LLLL = v18259;
    DATE_FORMATS.dd = v18260;
    DATE_FORMATS.d = v18261;
    DATE_FORMATS.HH = v18262;
    DATE_FORMATS.H = v18263;
    DATE_FORMATS.hh = v18265;
    DATE_FORMATS.h = v18267;
    DATE_FORMATS.mm = v18268;
    DATE_FORMATS.m = v18269;
    DATE_FORMATS.ss = v18270;
    DATE_FORMATS.s = v18271;
    DATE_FORMATS.sss = v18272;
    DATE_FORMATS.EEEE = v18273;
    DATE_FORMATS.EEE = v18274;
    DATE_FORMATS.a = ampmGetter;
    DATE_FORMATS.Z = timeZoneGetter;
    DATE_FORMATS.ww = v18275;
    DATE_FORMATS.w = v18276;
    DATE_FORMATS.G = eraGetter;
    DATE_FORMATS.GG = eraGetter;
    DATE_FORMATS.GGG = eraGetter;
    DATE_FORMATS.GGGG = longEraGetter;
    var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/;
    var NUMBER_STRING = /^-?\d+$/;
    dateFilter.$inject = ['$locale'];
    const dateFilter = function ($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        const jsonStringToDate = function (string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0);
                var tzHour = 0;
                var tzMin = 0;
                let dateSetter;
                const v18277 = match[8];
                const v18278 = date.setUTCFullYear;
                const v18279 = date.setFullYear;
                if (v18277) {
                    dateSetter = v18278;
                } else {
                    dateSetter = v18279;
                }
                let timeSetter;
                const v18280 = match[8];
                const v18281 = date.setUTCHours;
                const v18282 = date.setHours;
                if (v18280) {
                    timeSetter = v18281;
                } else {
                    timeSetter = v18282;
                }
                const v18283 = match[9];
                if (v18283) {
                    const v18284 = match[9];
                    const v18285 = match[10];
                    const v18286 = v18284 + v18285;
                    tzHour = toInt(v18286);
                    const v18287 = match[9];
                    const v18288 = match[11];
                    const v18289 = v18287 + v18288;
                    tzMin = toInt(v18289);
                }
                const v18290 = match[1];
                const v18291 = toInt(v18290);
                const v18292 = match[2];
                const v18293 = toInt(v18292);
                const v18294 = v18293 - 1;
                const v18295 = match[3];
                const v18296 = toInt(v18295);
                const v18297 = dateSetter.call(date, v18291, v18294, v18296);
                v18297;
                const v18298 = match[4];
                const v18299 = v18298 || 0;
                const v18300 = toInt(v18299);
                var h = v18300 - tzHour;
                const v18301 = match[5];
                const v18302 = v18301 || 0;
                const v18303 = toInt(v18302);
                var m = v18303 - tzMin;
                const v18304 = match[6];
                const v18305 = v18304 || 0;
                var s = toInt(v18305);
                const v18306 = match[7];
                const v18307 = v18306 || 0;
                const v18308 = '0.' + v18307;
                const v18309 = parseFloat(v18308);
                const v18310 = v18309 * 1000;
                var ms = Math.round(v18310);
                const v18311 = timeSetter.call(date, h, m, s, ms);
                v18311;
                return date;
            }
            return string;
        };
        const v18334 = function (date, format, timezone) {
            var text = '';
            var parts = [];
            var fn;
            var match;
            format = format || 'mediumDate';
            const v18312 = $locale.DATETIME_FORMATS;
            const v18313 = v18312[format];
            format = v18313 || format;
            const v18314 = isString(date);
            if (v18314) {
                const v18315 = NUMBER_STRING.test(date);
                const v18316 = toInt(date);
                const v18317 = jsonStringToDate(date);
                if (v18315) {
                    date = v18316;
                } else {
                    date = v18317;
                }
            }
            const v18318 = isNumber(date);
            if (v18318) {
                date = new Date(date);
            }
            const v18319 = isDate(date);
            const v18320 = !v18319;
            const v18321 = date.getTime();
            const v18322 = isFinite(v18321);
            const v18323 = !v18322;
            const v18324 = v18320 || v18323;
            if (v18324) {
                return date;
            }
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                } else {
                    const v18325 = parts.push(format);
                    v18325;
                    format = null;
                }
            }
            var dateTimezoneOffset = date.getTimezoneOffset();
            if (timezone) {
                dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
                date = convertTimezoneToLocal(date, timezone, true);
            }
            const v18332 = function (value) {
                fn = DATE_FORMATS[value];
                const v18326 = $locale.DATETIME_FORMATS;
                const v18327 = fn(date, v18326, dateTimezoneOffset);
                const v18328 = value === '\'\'';
                const v18329 = value.replace(/(^'|'$)/g, '');
                const v18330 = v18329.replace(/''/g, '\'');
                let v18331;
                if (v18328) {
                    v18331 = '\'';
                } else {
                    v18331 = v18330;
                }
                if (fn) {
                    text = v18327;
                } else {
                    text = v18331;
                }
            };
            const v18333 = forEach(parts, v18332);
            v18333;
            return text;
        };
        return v18334;
    };
    const jsonFilter = function () {
        const v18337 = function (object, spacing) {
            const v18335 = isUndefined(spacing);
            if (v18335) {
                spacing = 2;
            }
            const v18336 = toJson(object, spacing);
            return v18336;
        };
        return v18337;
    };
    var lowercaseFilter = valueFn(lowercase);
    var uppercaseFilter = valueFn(uppercase);
    const limitToFilter = function () {
        const v18362 = function (input, limit, begin) {
            const v18338 = Number(limit);
            const v18339 = Math.abs(v18338);
            const v18340 = v18339 === Infinity;
            if (v18340) {
                limit = Number(limit);
            } else {
                limit = toInt(limit);
            }
            const v18341 = isNumberNaN(limit);
            if (v18341) {
                return input;
            }
            const v18342 = isNumber(input);
            if (v18342) {
                input = input.toString();
            }
            const v18343 = isArrayLike(input);
            const v18344 = !v18343;
            if (v18344) {
                return input;
            }
            const v18345 = !begin;
            const v18346 = isNaN(begin);
            const v18347 = v18345 || v18346;
            const v18348 = toInt(begin);
            if (v18347) {
                begin = 0;
            } else {
                begin = v18348;
            }
            const v18349 = begin < 0;
            const v18350 = input.length;
            const v18351 = v18350 + begin;
            const v18352 = Math.max(0, v18351);
            if (v18349) {
                begin = v18352;
            } else {
                begin = begin;
            }
            const v18353 = limit >= 0;
            if (v18353) {
                const v18354 = begin + limit;
                const v18355 = sliceFn(input, begin, v18354);
                return v18355;
            } else {
                const v18356 = begin === 0;
                if (v18356) {
                    const v18357 = input.length;
                    const v18358 = sliceFn(input, limit, v18357);
                    return v18358;
                } else {
                    const v18359 = begin + limit;
                    const v18360 = Math.max(0, v18359);
                    const v18361 = sliceFn(input, v18360, begin);
                    return v18361;
                }
            }
        };
        return v18362;
    };
    const sliceFn = function (input, begin, end) {
        const v18363 = isString(input);
        if (v18363) {
            const v18364 = input.slice(begin, end);
            return v18364;
        }
        const v18365 = slice.call(input, begin, end);
        return v18365;
    };
    orderByFilter.$inject = ['$parse'];
    const orderByFilter = function ($parse) {
        const v18406 = function (array, sortPredicate, reverseOrder, compareFn) {
            const v18366 = array == null;
            if (v18366) {
                return array;
            }
            const v18367 = isArrayLike(array);
            const v18368 = !v18367;
            if (v18368) {
                const v18369 = minErr('orderBy');
                const v18370 = v18369('notarray', 'Expected array but received: {0}', array);
                throw v18370;
            }
            const v18371 = isArray(sortPredicate);
            const v18372 = !v18371;
            if (v18372) {
                sortPredicate = [sortPredicate];
            }
            const v18373 = sortPredicate.length;
            const v18374 = v18373 === 0;
            if (v18374) {
                sortPredicate = ['+'];
            }
            var predicates = processPredicates(sortPredicate);
            let descending;
            const v18375 = -1;
            if (reverseOrder) {
                descending = v18375;
            } else {
                descending = 1;
            }
            let compare;
            const v18376 = isFunction(compareFn);
            if (v18376) {
                compare = compareFn;
            } else {
                compare = defaultCompare;
            }
            const v18377 = Array.prototype;
            const v18378 = v18377.map;
            var compareValues = v18378.call(array, getComparisonObject);
            const v18379 = compareValues.sort(doComparison);
            v18379;
            const v18381 = function (item) {
                const v18380 = item.value;
                return v18380;
            };
            array = compareValues.map(v18381);
            return array;
            const getComparisonObject = function (value, index) {
                const v18382 = {};
                v18382.value = index;
                v18382.type = 'number';
                v18382.index = index;
                const v18385 = function (predicate) {
                    const v18383 = predicate.get(value);
                    const v18384 = getPredicateValue(v18383, index);
                    return v18384;
                };
                const v18386 = predicates.map(v18385);
                const v18387 = {};
                v18387.value = value;
                v18387.tieBreaker = v18382;
                v18387.predicateValues = v18386;
                return v18387;
            };
            const doComparison = function (v1, v2) {
                var i = 0;
                var ii = predicates.length;
                let v18388 = i < ii;
                while (v18388) {
                    const v18390 = v1.predicateValues;
                    const v18391 = v18390[i];
                    const v18392 = v2.predicateValues;
                    const v18393 = v18392[i];
                    var result = compare(v18391, v18393);
                    if (result) {
                        const v18394 = predicates[i];
                        const v18395 = v18394.descending;
                        const v18396 = result * v18395;
                        const v18397 = v18396 * descending;
                        return v18397;
                    }
                    const v18389 = i++;
                    v18388 = i < ii;
                }
                const v18398 = v1.tieBreaker;
                const v18399 = v2.tieBreaker;
                const v18400 = compare(v18398, v18399);
                const v18401 = v1.tieBreaker;
                const v18402 = v2.tieBreaker;
                const v18403 = defaultCompare(v18401, v18402);
                const v18404 = v18400 || v18403;
                const v18405 = v18404 * descending;
                return v18405;
            };
        };
        return v18406;
        const processPredicates = function (sortPredicates) {
            const v18422 = function (predicate) {
                var descending = 1;
                var get = identity;
                const v18407 = isFunction(predicate);
                if (v18407) {
                    get = predicate;
                } else {
                    const v18408 = isString(predicate);
                    if (v18408) {
                        const v18409 = predicate.charAt(0);
                        const v18410 = v18409 === '+';
                        const v18411 = predicate.charAt(0);
                        const v18412 = v18411 === '-';
                        const v18413 = v18410 || v18412;
                        if (v18413) {
                            const v18414 = predicate.charAt(0);
                            const v18415 = v18414 === '-';
                            const v18416 = -1;
                            if (v18415) {
                                descending = v18416;
                            } else {
                                descending = 1;
                            }
                            predicate = predicate.substring(1);
                        }
                        const v18417 = predicate !== '';
                        if (v18417) {
                            get = $parse(predicate);
                            const v18418 = get.constant;
                            if (v18418) {
                                var key = get();
                                const v18420 = function (value) {
                                    const v18419 = value[key];
                                    return v18419;
                                };
                                get = v18420;
                            }
                        }
                    }
                }
                const v18421 = {};
                v18421.get = get;
                v18421.descending = descending;
                return v18421;
            };
            const v18423 = sortPredicates.map(v18422);
            return v18423;
        };
        const isPrimitive = function (value) {
            const v18424 = typeof value;
            switch (v18424) {
            case 'number':
            case 'boolean':
            case 'string':
                return true;
            default:
                return false;
            }
        };
        const objectValue = function (value) {
            const v18425 = value.valueOf;
            const v18426 = isFunction(v18425);
            if (v18426) {
                value = value.valueOf();
                const v18427 = isPrimitive(value);
                if (v18427) {
                    return value;
                }
            }
            const v18428 = hasCustomToString(value);
            if (v18428) {
                value = value.toString();
                const v18429 = isPrimitive(value);
                if (v18429) {
                    return value;
                }
            }
            return value;
        };
        const getPredicateValue = function (value, index) {
            const v18430 = typeof value;
            var type = v18430;
            const v18431 = value === null;
            if (v18431) {
                type = 'null';
            } else {
                const v18432 = type === 'object';
                if (v18432) {
                    value = objectValue(value);
                }
            }
            const v18433 = {};
            v18433.value = value;
            v18433.type = type;
            v18433.index = index;
            return v18433;
        };
        const defaultCompare = function (v1, v2) {
            var result = 0;
            var type1 = v1.type;
            var type2 = v2.type;
            const v18434 = type1 === type2;
            if (v18434) {
                var value1 = v1.value;
                var value2 = v2.value;
                const v18435 = type1 === 'string';
                if (v18435) {
                    value1 = value1.toLowerCase();
                    value2 = value2.toLowerCase();
                } else {
                    const v18436 = type1 === 'object';
                    if (v18436) {
                        const v18437 = isObject(value1);
                        if (v18437) {
                            value1 = v1.index;
                        }
                        const v18438 = isObject(value2);
                        if (v18438) {
                            value2 = v2.index;
                        }
                    }
                }
                const v18439 = value1 !== value2;
                if (v18439) {
                    const v18440 = value1 < value2;
                    const v18441 = -1;
                    if (v18440) {
                        result = v18441;
                    } else {
                        result = 1;
                    }
                }
            } else {
                const v18442 = type1 === 'undefined';
                const v18443 = type2 === 'undefined';
                const v18444 = -1;
                const v18445 = type1 === 'null';
                const v18446 = type2 === 'null';
                const v18447 = -1;
                const v18448 = type1 < type2;
                const v18449 = -1;
                let v18450;
                if (v18448) {
                    v18450 = v18449;
                } else {
                    v18450 = 1;
                }
                let v18451;
                if (v18446) {
                    v18451 = v18447;
                } else {
                    v18451 = v18450;
                }
                let v18452;
                if (v18445) {
                    v18452 = 1;
                } else {
                    v18452 = v18451;
                }
                let v18453;
                if (v18443) {
                    v18453 = v18444;
                } else {
                    v18453 = v18452;
                }
                if (v18442) {
                    result = 1;
                } else {
                    result = v18453;
                }
            }
            return result;
        };
    };
    const ngDirective = function (directive) {
        const v18454 = isFunction(directive);
        if (v18454) {
            directive.link = directive;
            directive = {};
            directive = {};
        }
        const v18455 = directive.restrict;
        directive.restrict = v18455 || 'AC';
        const v18456 = valueFn(directive);
        return v18456;
    };
    const v18475 = function (element, attr) {
        const v18457 = attr.href;
        const v18458 = !v18457;
        const v18459 = attr.xlinkHref;
        const v18460 = !v18459;
        const v18461 = v18458 && v18460;
        if (v18461) {
            const v18474 = function (scope, element) {
                const v18462 = element[0];
                const v18463 = v18462.nodeName;
                const v18464 = v18463.toLowerCase();
                const v18465 = v18464 !== 'a';
                if (v18465) {
                    return;
                }
                let href;
                const v18466 = element.prop('href');
                const v18467 = toString.call(v18466);
                const v18468 = v18467 === '[object SVGAnimatedString]';
                if (v18468) {
                    href = 'xlink:href';
                } else {
                    href = 'href';
                }
                const v18472 = function (event) {
                    const v18469 = element.attr(href);
                    const v18470 = !v18469;
                    if (v18470) {
                        const v18471 = event.preventDefault();
                        v18471;
                    }
                };
                const v18473 = element.on('click', v18472);
                v18473;
            };
            return v18474;
        }
    };
    const v18476 = {
        restrict: 'E',
        compile: v18475
    };
    var htmlAnchorDirective = valueFn(v18476);
    var ngAttributeAliasDirectives = {};
    const v18493 = function (propName, attrName) {
        const v18477 = propName === 'multiple';
        if (v18477) {
            return;
        }
        const defaultLinkFn = function (scope, element, attr) {
            const v18478 = attr[normalized];
            const v18482 = function ngBooleanAttrWatchAction(value) {
                const v18479 = !value;
                const v18480 = !v18479;
                const v18481 = attr.$set(attrName, v18480);
                v18481;
            };
            const v18483 = scope.$watch(v18478, v18482);
            v18483;
        };
        const v18484 = 'ng-' + attrName;
        var normalized = directiveNormalize(v18484);
        var linkFn = defaultLinkFn;
        const v18485 = propName === 'checked';
        if (v18485) {
            const v18490 = function (scope, element, attr) {
                const v18486 = attr.ngModel;
                const v18487 = attr[normalized];
                const v18488 = v18486 !== v18487;
                if (v18488) {
                    const v18489 = defaultLinkFn(scope, element, attr);
                    v18489;
                }
            };
            linkFn = v18490;
        }
        const v18492 = function () {
            const v18491 = {};
            v18491.restrict = 'A';
            v18491.priority = 100;
            v18491.link = linkFn;
            return v18491;
        };
        ngAttributeAliasDirectives[normalized] = v18492;
    };
    const v18494 = forEach(BOOLEAN_ATTR, v18493);
    v18494;
    const v18512 = function (htmlAttr, ngAttr) {
        const v18511 = function () {
            const v18509 = function (scope, element, attr) {
                const v18495 = ngAttr === 'ngPattern';
                const v18496 = attr.ngPattern;
                const v18497 = v18496.charAt(0);
                const v18498 = v18497 === '/';
                const v18499 = v18495 && v18498;
                if (v18499) {
                    const v18500 = attr.ngPattern;
                    var match = v18500.match(REGEX_STRING_REGEXP);
                    if (match) {
                        const v18501 = match[1];
                        const v18502 = match[2];
                        const v18503 = new RegExp(v18501, v18502);
                        const v18504 = attr.$set('ngPattern', v18503);
                        v18504;
                        return;
                    }
                }
                const v18505 = attr[ngAttr];
                const v18507 = function ngAttrAliasWatchAction(value) {
                    const v18506 = attr.$set(ngAttr, value);
                    v18506;
                };
                const v18508 = scope.$watch(v18505, v18507);
                v18508;
            };
            const v18510 = {};
            v18510.priority = 100;
            v18510.link = v18509;
            return v18510;
        };
        ngAttributeAliasDirectives[ngAttr] = v18511;
    };
    const v18513 = forEach(ALIASED_ATTR, v18512);
    v18513;
    const v18514 = [
        'src',
        'srcset',
        'href'
    ];
    const v18537 = function (attrName) {
        const v18515 = 'ng-' + attrName;
        var normalized = directiveNormalize(v18515);
        const v18536 = function ($sce) {
            const v18534 = function (scope, element, attr) {
                var propName = attrName;
                var name = attrName;
                const v18516 = attrName === 'href';
                const v18517 = element.prop('href');
                const v18518 = toString.call(v18517);
                const v18519 = v18518 === '[object SVGAnimatedString]';
                const v18520 = v18516 && v18519;
                if (v18520) {
                    name = 'xlinkHref';
                    const v18521 = attr.$attr;
                    v18521[name] = 'xlink:href';
                    propName = null;
                }
                const v18522 = attr[normalized];
                const v18523 = $sce.getTrustedMediaUrl(v18522);
                const v18524 = attr.$set(normalized, v18523);
                v18524;
                const v18532 = function (value) {
                    const v18525 = !value;
                    if (v18525) {
                        const v18526 = attrName === 'href';
                        if (v18526) {
                            const v18527 = attr.$set(name, null);
                            v18527;
                        }
                        return;
                    }
                    const v18528 = attr.$set(name, value);
                    v18528;
                    const v18529 = msie && propName;
                    if (v18529) {
                        const v18530 = attr[name];
                        const v18531 = element.prop(propName, v18530);
                        v18531;
                    }
                };
                const v18533 = attr.$observe(normalized, v18532);
                v18533;
            };
            const v18535 = {};
            v18535.priority = 99;
            v18535.link = v18534;
            return v18535;
        };
        ngAttributeAliasDirectives[normalized] = [
            '$sce',
            v18536
        ];
    };
    const v18538 = forEach(v18514, v18537);
    v18538;
    const v18539 = [];
    const v18540 = valueFn(v18539);
    var nullFormCtrl = {};
    nullFormCtrl.$addControl = noop;
    nullFormCtrl.$getControls = v18540;
    nullFormCtrl.$$renameControl = nullFormRenameControl;
    nullFormCtrl.$removeControl = noop;
    nullFormCtrl.$setValidity = noop;
    nullFormCtrl.$setDirty = noop;
    nullFormCtrl.$setPristine = noop;
    nullFormCtrl.$setSubmitted = noop;
    nullFormCtrl.$$setSubmitted = noop;
    var PENDING_CLASS = 'ng-pending';
    var SUBMITTED_CLASS = 'ng-submitted';
    const nullFormRenameControl = function (control, name) {
        control.$name = name;
    };
    FormController.$inject = [
        '$element',
        '$attrs',
        '$scope',
        '$animate',
        '$interpolate'
    ];
    const FormController = function ($element, $attrs, $scope, $animate, $interpolate) {
        this.$$controls = [];
        const v18541 = {};
        this.$error = v18541;
        const v18542 = {};
        this.$$success = v18542;
        this.$pending = undefined;
        const v18543 = $attrs.name;
        const v18544 = $attrs.ngForm;
        const v18545 = v18543 || v18544;
        const v18546 = v18545 || '';
        const v18547 = $interpolate(v18546);
        const v18548 = v18547($scope);
        this.$name = v18548;
        this.$dirty = false;
        this.$pristine = true;
        this.$valid = true;
        this.$invalid = false;
        this.$submitted = false;
        this.$$parentForm = nullFormCtrl;
        this.$$element = $element;
        this.$$animate = $animate;
        const v18549 = setupValidity(this);
        v18549;
    };
    const v18554 = function () {
        const v18550 = this.$$controls;
        const v18552 = function (control) {
            const v18551 = control.$rollbackViewValue();
            v18551;
        };
        const v18553 = forEach(v18550, v18552);
        v18553;
    };
    const v18559 = function () {
        const v18555 = this.$$controls;
        const v18557 = function (control) {
            const v18556 = control.$commitViewValue();
            v18556;
        };
        const v18558 = forEach(v18555, v18557);
        v18558;
    };
    const v18566 = function (control) {
        const v18560 = control.$name;
        const v18561 = assertNotHasOwnProperty(v18560, 'input');
        v18561;
        const v18562 = this.$$controls;
        const v18563 = v18562.push(control);
        v18563;
        const v18564 = control.$name;
        if (v18564) {
            const v18565 = control.$name;
            this[v18565] = control;
        }
        control.$$parentForm = this;
    };
    const v18569 = function () {
        const v18567 = this.$$controls;
        const v18568 = shallowCopy(v18567);
        return v18568;
    };
    const v18574 = function (control, newName) {
        var oldName = control.$name;
        const v18570 = this[oldName];
        const v18571 = v18570 === control;
        if (v18571) {
            const v18572 = this[oldName];
            const v18573 = delete v18572;
            v18573;
        }
        this[newName] = control;
        control.$name = newName;
    };
    const v18597 = function (control) {
        const v18575 = control.$name;
        const v18576 = control.$name;
        const v18577 = this[v18576];
        const v18578 = v18577 === control;
        const v18579 = v18575 && v18578;
        if (v18579) {
            const v18580 = control.$name;
            const v18581 = this[v18580];
            const v18582 = delete v18581;
            v18582;
        }
        const v18583 = this.$pending;
        const v18585 = function (value, name) {
            const v18584 = this.$setValidity(name, null, control);
            v18584;
        };
        const v18586 = forEach(v18583, v18585, this);
        v18586;
        const v18587 = this.$error;
        const v18589 = function (value, name) {
            const v18588 = this.$setValidity(name, null, control);
            v18588;
        };
        const v18590 = forEach(v18587, v18589, this);
        v18590;
        const v18591 = this.$$success;
        const v18593 = function (value, name) {
            const v18592 = this.$setValidity(name, null, control);
            v18592;
        };
        const v18594 = forEach(v18591, v18593, this);
        v18594;
        const v18595 = this.$$controls;
        const v18596 = arrayRemove(v18595, control);
        v18596;
        control.$$parentForm = nullFormCtrl;
    };
    const v18606 = function () {
        const v18598 = this.$$animate;
        const v18599 = this.$$element;
        const v18600 = v18598.removeClass(v18599, PRISTINE_CLASS);
        v18600;
        const v18601 = this.$$animate;
        const v18602 = this.$$element;
        const v18603 = v18601.addClass(v18602, DIRTY_CLASS);
        v18603;
        this.$dirty = true;
        this.$pristine = false;
        const v18604 = this.$$parentForm;
        const v18605 = v18604.$setDirty();
        v18605;
    };
    const v18616 = function () {
        const v18607 = this.$$animate;
        const v18608 = this.$$element;
        const v18609 = DIRTY_CLASS + ' ';
        const v18610 = v18609 + SUBMITTED_CLASS;
        const v18611 = v18607.setClass(v18608, PRISTINE_CLASS, v18610);
        v18611;
        this.$dirty = false;
        this.$pristine = true;
        this.$submitted = false;
        const v18612 = this.$$controls;
        const v18614 = function (control) {
            const v18613 = control.$setPristine();
            v18613;
        };
        const v18615 = forEach(v18612, v18614);
        v18615;
    };
    const v18621 = function () {
        const v18617 = this.$$controls;
        const v18619 = function (control) {
            const v18618 = control.$setUntouched();
            v18618;
        };
        const v18620 = forEach(v18617, v18619);
        v18620;
    };
    const v18627 = function () {
        var rootForm = this;
        const v18622 = rootForm.$$parentForm;
        const v18623 = rootForm.$$parentForm;
        const v18624 = v18623 !== nullFormCtrl;
        let v18625 = v18622 && v18624;
        while (v18625) {
            rootForm = rootForm.$$parentForm;
            v18625 = v18622 && v18624;
        }
        const v18626 = rootForm.$$setSubmitted();
        v18626;
    };
    const v18636 = function () {
        const v18628 = this.$$animate;
        const v18629 = this.$$element;
        const v18630 = v18628.addClass(v18629, SUBMITTED_CLASS);
        v18630;
        this.$submitted = true;
        const v18631 = this.$$controls;
        const v18634 = function (control) {
            const v18632 = control.$$setSubmitted;
            if (v18632) {
                const v18633 = control.$$setSubmitted();
                v18633;
            }
        };
        const v18635 = forEach(v18631, v18634);
        v18635;
    };
    const v18637 = {};
    v18637.$rollbackViewValue = v18554;
    v18637.$commitViewValue = v18559;
    v18637.$addControl = v18566;
    v18637.$getControls = v18569;
    v18637.$$renameControl = v18574;
    v18637.$removeControl = v18597;
    v18637.$setDirty = v18606;
    v18637.$setPristine = v18616;
    v18637.$setUntouched = v18621;
    v18637.$setSubmitted = v18627;
    v18637.$$setSubmitted = v18636;
    FormController.prototype = v18637;
    const v18642 = function (object, property, controller) {
        var list = object[property];
        const v18638 = !list;
        if (v18638) {
            object[property] = [controller];
        } else {
            var index = list.indexOf(controller);
            const v18639 = -1;
            const v18640 = index === v18639;
            if (v18640) {
                const v18641 = list.push(controller);
                v18641;
            }
        }
    };
    const v18649 = function (object, property, controller) {
        var list = object[property];
        const v18643 = !list;
        if (v18643) {
            return;
        }
        const v18644 = arrayRemove(list, controller);
        v18644;
        const v18645 = list.length;
        const v18646 = v18645 === 0;
        if (v18646) {
            const v18647 = object[property];
            const v18648 = delete v18647;
            v18648;
        }
    };
    const v18650 = {
        clazz: FormController,
        set: v18642,
        unset: v18649
    };
    const v18651 = addSetValidityMethod(v18650);
    v18651;
    var formDirectiveFactory = function (isNgForm) {
        const v18705 = function ($timeout, $parse) {
            let v18652;
            if (isNgForm) {
                v18652 = 'EAC';
            } else {
                v18652 = 'E';
            }
            const v18653 = [
                'form',
                '^^?form'
            ];
            const v18698 = function ngFormCompile(formElement, attr) {
                const v18654 = formElement.addClass(PRISTINE_CLASS);
                const v18655 = v18654.addClass(VALID_CLASS);
                v18655;
                let nameAttr;
                const v18656 = attr.name;
                const v18657 = attr.ngForm;
                const v18658 = isNgForm && v18657;
                let v18659;
                if (v18658) {
                    v18659 = 'ngForm';
                } else {
                    v18659 = false;
                }
                if (v18656) {
                    nameAttr = 'name';
                } else {
                    nameAttr = v18659;
                }
                const v18696 = function ngFormPreLink(scope, formElement, attr, ctrls) {
                    var controller = ctrls[0];
                    const v18660 = 'action' in attr;
                    const v18661 = !v18660;
                    if (v18661) {
                        var handleFormSubmission = function (event) {
                            const v18664 = function () {
                                const v18662 = controller.$commitViewValue();
                                v18662;
                                const v18663 = controller.$setSubmitted();
                                v18663;
                            };
                            const v18665 = scope.$apply(v18664);
                            v18665;
                            const v18666 = event.preventDefault();
                            v18666;
                        };
                        const v18667 = formElement[0];
                        const v18668 = v18667.addEventListener('submit', handleFormSubmission);
                        v18668;
                        const v18673 = function () {
                            const v18671 = function () {
                                const v18669 = formElement[0];
                                const v18670 = v18669.removeEventListener('submit', handleFormSubmission);
                                v18670;
                            };
                            const v18672 = $timeout(v18671, 0, false);
                            v18672;
                        };
                        const v18674 = formElement.on('$destroy', v18673);
                        v18674;
                    }
                    const v18675 = ctrls[1];
                    const v18676 = controller.$$parentForm;
                    var parentFormCtrl = v18675 || v18676;
                    const v18677 = parentFormCtrl.$addControl(controller);
                    v18677;
                    let setter;
                    const v18678 = controller.$name;
                    const v18679 = getSetter(v18678);
                    if (nameAttr) {
                        setter = v18679;
                    } else {
                        setter = noop;
                    }
                    if (nameAttr) {
                        const v18680 = setter(scope, controller);
                        v18680;
                        const v18688 = function (newValue) {
                            const v18681 = controller.$name;
                            const v18682 = v18681 === newValue;
                            if (v18682) {
                                return;
                            }
                            const v18683 = setter(scope, undefined);
                            v18683;
                            const v18684 = controller.$$parentForm;
                            const v18685 = v18684.$$renameControl(controller, newValue);
                            v18685;
                            const v18686 = controller.$name;
                            setter = getSetter(v18686);
                            const v18687 = setter(scope, controller);
                            v18687;
                        };
                        const v18689 = attr.$observe(nameAttr, v18688);
                        v18689;
                    }
                    const v18694 = function () {
                        const v18690 = controller.$$parentForm;
                        const v18691 = v18690.$removeControl(controller);
                        v18691;
                        const v18692 = setter(scope, undefined);
                        v18692;
                        const v18693 = extend(controller, nullFormCtrl);
                        v18693;
                    };
                    const v18695 = formElement.on('$destroy', v18694);
                    v18695;
                };
                const v18697 = {};
                v18697.pre = v18696;
                return v18697;
            };
            var formDirective = {};
            formDirective.name = 'form';
            formDirective.restrict = v18652;
            formDirective.require = v18653;
            formDirective.controller = FormController;
            formDirective.compile = v18698;
            return formDirective;
            const getSetter = function (expression) {
                const v18699 = expression === '';
                if (v18699) {
                    const v18700 = $parse('this[""]');
                    const v18701 = v18700.assign;
                    return v18701;
                }
                const v18702 = $parse(expression);
                const v18703 = v18702.assign;
                const v18704 = v18703 || noop;
                return v18704;
            };
        };
        const v18706 = [
            '$timeout',
            '$parse',
            v18705
        ];
        return v18706;
    };
    var formDirective = formDirectiveFactory();
    var ngFormDirective = formDirectiveFactory(true);
    const setupValidity = function (instance) {
        const v18707 = {};
        instance.$$classCache = v18707;
        const v18708 = instance.$$classCache;
        const v18710 = instance.$$element;
        const v18711 = v18710.hasClass(VALID_CLASS);
        const v18712 = !(v18709[VALID_CLASS] = v18711);
        v18708[INVALID_CLASS] = v18712;
    };
    const addSetValidityMethod = function (context) {
        var clazz = context.clazz;
        var set = context.set;
        var unset = context.unset;
        const v18713 = clazz.prototype;
        const v18752 = function (validationErrorKey, state, controller) {
            const v18714 = isUndefined(state);
            if (v18714) {
                const v18715 = createAndSet(this, '$pending', validationErrorKey, controller);
                v18715;
            } else {
                const v18716 = unsetAndCleanup(this, '$pending', validationErrorKey, controller);
                v18716;
            }
            const v18717 = isBoolean(state);
            const v18718 = !v18717;
            if (v18718) {
                const v18719 = this.$error;
                const v18720 = unset(v18719, validationErrorKey, controller);
                v18720;
                const v18721 = this.$$success;
                const v18722 = unset(v18721, validationErrorKey, controller);
                v18722;
            } else {
                if (state) {
                    const v18723 = this.$error;
                    const v18724 = unset(v18723, validationErrorKey, controller);
                    v18724;
                    const v18725 = this.$$success;
                    const v18726 = set(v18725, validationErrorKey, controller);
                    v18726;
                } else {
                    const v18727 = this.$error;
                    const v18728 = set(v18727, validationErrorKey, controller);
                    v18728;
                    const v18729 = this.$$success;
                    const v18730 = unset(v18729, validationErrorKey, controller);
                    v18730;
                }
            }
            const v18731 = this.$pending;
            if (v18731) {
                const v18732 = cachedToggleClass(this, PENDING_CLASS, true);
                v18732;
                this.$valid = this.$invalid = undefined;
                const v18733 = toggleValidationCss(this, '', null);
                v18733;
            } else {
                const v18734 = cachedToggleClass(this, PENDING_CLASS, false);
                v18734;
                const v18735 = this.$error;
                const v18736 = isObjectEmpty(v18735);
                this.$valid = v18736;
                const v18737 = this.$valid;
                const v18738 = !v18737;
                this.$invalid = v18738;
                const v18739 = this.$valid;
                const v18740 = toggleValidationCss(this, '', v18739);
                v18740;
            }
            var combinedState;
            const v18741 = this.$pending;
            const v18742 = this.$pending;
            const v18743 = v18742[validationErrorKey];
            const v18744 = v18741 && v18743;
            if (v18744) {
                combinedState = undefined;
            } else {
                const v18745 = this.$error;
                const v18746 = v18745[validationErrorKey];
                if (v18746) {
                    combinedState = false;
                } else {
                    const v18747 = this.$$success;
                    const v18748 = v18747[validationErrorKey];
                    if (v18748) {
                        combinedState = true;
                    } else {
                        combinedState = null;
                    }
                }
            }
            const v18749 = toggleValidationCss(this, validationErrorKey, combinedState);
            v18749;
            const v18750 = this.$$parentForm;
            const v18751 = v18750.$setValidity(validationErrorKey, combinedState, this);
            v18751;
        };
        v18713.$setValidity = v18752;
        const createAndSet = function (ctrl, name, value, controller) {
            const v18753 = ctrl[name];
            const v18754 = !v18753;
            if (v18754) {
                const v18755 = {};
                ctrl[name] = v18755;
            }
            const v18756 = ctrl[name];
            const v18757 = set(v18756, value, controller);
            v18757;
        };
        const unsetAndCleanup = function (ctrl, name, value, controller) {
            const v18758 = ctrl[name];
            if (v18758) {
                const v18759 = ctrl[name];
                const v18760 = unset(v18759, value, controller);
                v18760;
            }
            const v18761 = ctrl[name];
            const v18762 = isObjectEmpty(v18761);
            if (v18762) {
                ctrl[name] = undefined;
            }
        };
        const cachedToggleClass = function (ctrl, className, switchValue) {
            const v18763 = ctrl.$$classCache;
            const v18764 = v18763[className];
            const v18765 = !v18764;
            const v18766 = switchValue && v18765;
            if (v18766) {
                const v18767 = ctrl.$$animate;
                const v18768 = ctrl.$$element;
                const v18769 = v18767.addClass(v18768, className);
                v18769;
                const v18770 = ctrl.$$classCache;
                v18770[className] = true;
            } else {
                const v18771 = !switchValue;
                const v18772 = ctrl.$$classCache;
                const v18773 = v18772[className];
                const v18774 = v18771 && v18773;
                if (v18774) {
                    const v18775 = ctrl.$$animate;
                    const v18776 = ctrl.$$element;
                    const v18777 = v18775.removeClass(v18776, className);
                    v18777;
                    const v18778 = ctrl.$$classCache;
                    v18778[className] = false;
                }
            }
        };
        const toggleValidationCss = function (ctrl, validationErrorKey, isValid) {
            const v18779 = snake_case(validationErrorKey, '-');
            const v18780 = '-' + v18779;
            if (validationErrorKey) {
                validationErrorKey = v18780;
            } else {
                validationErrorKey = '';
            }
            const v18781 = VALID_CLASS + validationErrorKey;
            const v18782 = isValid === true;
            const v18783 = cachedToggleClass(ctrl, v18781, v18782);
            v18783;
            const v18784 = INVALID_CLASS + validationErrorKey;
            const v18785 = isValid === false;
            const v18786 = cachedToggleClass(ctrl, v18784, v18785);
            v18786;
        };
    };
    const isObjectEmpty = function (obj) {
        if (obj) {
            let prop;
            for (prop in obj) {
                const v18787 = obj.hasOwnProperty(prop);
                if (v18787) {
                    return false;
                }
            }
        }
        return true;
    };
    var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
    var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
    var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
    var NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
    var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
    var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
    var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
    var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
    var PARTIAL_VALIDATION_TYPES = createMap();
    const v18788 = 'date,datetime-local,month,time,week'.split(',');
    const v18789 = function (type) {
        PARTIAL_VALIDATION_TYPES[type] = true;
    };
    const v18790 = forEach(v18788, v18789);
    v18790;
    const v18791 = [
        'yyyy',
        'MM',
        'dd'
    ];
    const v18792 = createDateParser(DATE_REGEXP, v18791);
    const v18793 = createDateInputType('date', DATE_REGEXP, v18792, 'yyyy-MM-dd');
    const v18794 = [
        'yyyy',
        'MM',
        'dd',
        'HH',
        'mm',
        'ss',
        'sss'
    ];
    const v18795 = createDateParser(DATETIMELOCAL_REGEXP, v18794);
    const v18796 = createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, v18795, 'yyyy-MM-ddTHH:mm:ss.sss');
    const v18797 = [
        'HH',
        'mm',
        'ss',
        'sss'
    ];
    const v18798 = createDateParser(TIME_REGEXP, v18797);
    const v18799 = createDateInputType('time', TIME_REGEXP, v18798, 'HH:mm:ss.sss');
    const v18800 = createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www');
    const v18801 = [
        'yyyy',
        'MM'
    ];
    const v18802 = createDateParser(MONTH_REGEXP, v18801);
    const v18803 = createDateInputType('month', MONTH_REGEXP, v18802, 'yyyy-MM');
    var inputType = {};
    inputType['text'] = textInputType;
    inputType['date'] = v18793;
    inputType['datetime-local'] = v18796;
    inputType['time'] = v18799;
    inputType['week'] = v18800;
    inputType['month'] = v18803;
    inputType['number'] = numberInputType;
    inputType['url'] = urlInputType;
    inputType['email'] = emailInputType;
    inputType['radio'] = radioInputType;
    inputType['range'] = rangeInputType;
    inputType['checkbox'] = checkboxInputType;
    inputType['hidden'] = noop;
    inputType['button'] = noop;
    inputType['submit'] = noop;
    inputType['reset'] = noop;
    inputType['file'] = noop;
    const stringBasedInputType = function (ctrl) {
        const v18804 = ctrl.$formatters;
        const v18808 = function (value) {
            const v18805 = ctrl.$isEmpty(value);
            const v18806 = value.toString();
            let v18807;
            if (v18805) {
                v18807 = value;
            } else {
                v18807 = v18806;
            }
            return v18807;
        };
        const v18809 = v18804.push(v18808);
        v18809;
    };
    const textInputType = function (scope, element, attr, ctrl, $sniffer, $browser) {
        const v18810 = baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        v18810;
        const v18811 = stringBasedInputType(ctrl);
        v18811;
    };
    const baseInputType = function (scope, element, attr, ctrl, $sniffer, $browser) {
        const v18812 = element[0];
        const v18813 = v18812.type;
        var type = lowercase(v18813);
        const v18814 = $sniffer.android;
        const v18815 = !v18814;
        if (v18815) {
            var composing = false;
            const v18816 = function () {
                composing = true;
            };
            const v18817 = element.on('compositionstart', v18816);
            v18817;
            const v18823 = function (ev) {
                const v18818 = ev.data;
                const v18819 = isUndefined(v18818);
                const v18820 = ev.data;
                const v18821 = v18820 === '';
                const v18822 = v18819 || v18821;
                if (v18822) {
                    composing = false;
                }
            };
            const v18824 = element.on('compositionupdate', v18823);
            v18824;
            const v18826 = function () {
                composing = false;
                const v18825 = listener();
                v18825;
            };
            const v18827 = element.on('compositionend', v18826);
            v18827;
        }
        var timeout;
        var listener = function (ev) {
            if (timeout) {
                const v18828 = $browser.defer;
                const v18829 = v18828.cancel(timeout);
                v18829;
                timeout = null;
            }
            if (composing) {
                return;
            }
            var value = element.val();
            const v18830 = ev.type;
            var event = ev && v18830;
            const v18831 = type !== 'password';
            const v18832 = attr.ngTrim;
            const v18833 = !v18832;
            const v18834 = attr.ngTrim;
            const v18835 = v18834 !== 'false';
            const v18836 = v18833 || v18835;
            const v18837 = v18831 && v18836;
            if (v18837) {
                value = trim(value);
            }
            const v18838 = ctrl.$viewValue;
            const v18839 = v18838 !== value;
            const v18840 = value === '';
            const v18841 = ctrl.$$hasNativeValidators;
            const v18842 = v18840 && v18841;
            const v18843 = v18839 || v18842;
            if (v18843) {
                const v18844 = ctrl.$setViewValue(value, event);
                v18844;
            }
        };
        const v18845 = $sniffer.hasEvent('input');
        if (v18845) {
            const v18846 = element.on('input', listener);
            v18846;
        } else {
            var deferListener = function (ev, input, origValue) {
                const v18847 = !timeout;
                if (v18847) {
                    const v18853 = function () {
                        timeout = null;
                        const v18848 = !input;
                        const v18849 = input.value;
                        const v18850 = v18849 !== origValue;
                        const v18851 = v18848 || v18850;
                        if (v18851) {
                            const v18852 = listener(ev);
                            v18852;
                        }
                    };
                    timeout = $browser.defer(v18853);
                }
            };
            const v18865 = function (event) {
                var key = event.keyCode;
                const v18854 = key === 91;
                const v18855 = 15 < key;
                const v18856 = key < 19;
                const v18857 = v18855 && v18856;
                const v18858 = v18854 || v18857;
                const v18859 = 37 <= key;
                const v18860 = key <= 40;
                const v18861 = v18859 && v18860;
                const v18862 = v18858 || v18861;
                if (v18862) {
                    return;
                }
                const v18863 = this.value;
                const v18864 = deferListener(event, this, v18863);
                v18864;
            };
            const v18866 = element.on('keydown', v18865);
            v18866;
            const v18867 = $sniffer.hasEvent('paste');
            if (v18867) {
                const v18868 = element.on('paste cut drop', deferListener);
                v18868;
            }
        }
        const v18869 = element.on('change', listener);
        v18869;
        const v18870 = PARTIAL_VALIDATION_TYPES[type];
        const v18871 = ctrl.$$hasNativeValidators;
        const v18872 = v18870 && v18871;
        const v18873 = attr.type;
        const v18874 = type === v18873;
        const v18875 = v18872 && v18874;
        if (v18875) {
            const v18884 = function (ev) {
                const v18876 = !timeout;
                if (v18876) {
                    var validity = this[VALIDITY_STATE_PROPERTY];
                    var origBadInput = validity.badInput;
                    var origTypeMismatch = validity.typeMismatch;
                    const v18883 = function () {
                        timeout = null;
                        const v18877 = validity.badInput;
                        const v18878 = v18877 !== origBadInput;
                        const v18879 = validity.typeMismatch;
                        const v18880 = v18879 !== origTypeMismatch;
                        const v18881 = v18878 || v18880;
                        if (v18881) {
                            const v18882 = listener(ev);
                            v18882;
                        }
                    };
                    timeout = $browser.defer(v18883);
                }
            };
            const v18885 = element.on(PARTIAL_VALIDATION_EVENTS, v18884);
            v18885;
        }
        const v18892 = function () {
            let value;
            const v18886 = ctrl.$viewValue;
            const v18887 = ctrl.$isEmpty(v18886);
            const v18888 = ctrl.$viewValue;
            if (v18887) {
                value = '';
            } else {
                value = v18888;
            }
            const v18889 = element.val();
            const v18890 = v18889 !== value;
            if (v18890) {
                const v18891 = element.val(value);
                v18891;
            }
        };
        ctrl.$render = v18892;
    };
    const weekParser = function (isoWeek, existingDate) {
        const v18893 = isDate(isoWeek);
        if (v18893) {
            return isoWeek;
        }
        const v18894 = isString(isoWeek);
        if (v18894) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                const v18895 = parts[1];
                const v18896 = +v18895;
                var year = v18896;
                const v18897 = parts[2];
                const v18898 = +v18897;
                var week = v18898;
                var hours = 0;
                var minutes = 0;
                var seconds = 0;
                var milliseconds = 0;
                var firstThurs = getFirstThursdayOfYear(year);
                const v18899 = week - 1;
                var addDays = v18899 * 7;
                if (existingDate) {
                    hours = existingDate.getHours();
                    minutes = existingDate.getMinutes();
                    seconds = existingDate.getSeconds();
                    milliseconds = existingDate.getMilliseconds();
                }
                const v18900 = firstThurs.getDate();
                const v18901 = v18900 + addDays;
                const v18902 = new Date(year, 0, v18901, hours, minutes, seconds, milliseconds);
                return v18902;
            }
        }
        return NaN;
    };
    const createDateParser = function (regexp, mapping) {
        const v18947 = function (iso, previousDate) {
            var parts;
            var map;
            const v18903 = isDate(iso);
            if (v18903) {
                return iso;
            }
            const v18904 = isString(iso);
            if (v18904) {
                const v18905 = iso.charAt(0);
                const v18906 = v18905 === '"';
                const v18907 = iso.length;
                const v18908 = v18907 - 1;
                const v18909 = iso.charAt(v18908);
                const v18910 = v18909 === '"';
                const v18911 = v18906 && v18910;
                if (v18911) {
                    const v18912 = iso.length;
                    const v18913 = v18912 - 1;
                    iso = iso.substring(1, v18913);
                }
                const v18914 = ISO_DATE_REGEXP.test(iso);
                if (v18914) {
                    const v18915 = new Date(iso);
                    return v18915;
                }
                regexp.lastIndex = 0;
                parts = regexp.exec(iso);
                if (parts) {
                    const v18916 = parts.shift();
                    v18916;
                    if (previousDate) {
                        const v18917 = previousDate.getFullYear();
                        const v18918 = previousDate.getMonth();
                        const v18919 = v18918 + 1;
                        const v18920 = previousDate.getDate();
                        const v18921 = previousDate.getHours();
                        const v18922 = previousDate.getMinutes();
                        const v18923 = previousDate.getSeconds();
                        const v18924 = previousDate.getMilliseconds();
                        const v18925 = v18924 / 1000;
                        map.yyyy = v18917;
                        map.MM = v18919;
                        map.dd = v18920;
                        map.HH = v18921;
                        map.mm = v18922;
                        map.ss = v18923;
                        map.sss = v18925;
                        map = {};
                        map = {};
                    } else {
                        map.yyyy = 1970;
                        map.MM = 1;
                        map.dd = 1;
                        map.HH = 0;
                        map.mm = 0;
                        map.ss = 0;
                        map.sss = 0;
                        map = {};
                        map = {};
                    }
                    const v18930 = function (part, index) {
                        const v18926 = mapping.length;
                        const v18927 = index < v18926;
                        if (v18927) {
                            const v18928 = mapping[index];
                            const v18929 = +part;
                            map[v18928] = v18929;
                        }
                    };
                    const v18931 = forEach(parts, v18930);
                    v18931;
                    const v18932 = map.yyyy;
                    const v18933 = map.MM;
                    const v18934 = v18933 - 1;
                    const v18935 = map.dd;
                    const v18936 = map.HH;
                    const v18937 = map.mm;
                    const v18938 = map.ss;
                    const v18939 = v18938 || 0;
                    const v18940 = map.sss;
                    const v18941 = v18940 * 1000;
                    const v18942 = v18941 || 0;
                    var date = new Date(v18932, v18934, v18935, v18936, v18937, v18939, v18942);
                    const v18943 = map.yyyy;
                    const v18944 = v18943 < 100;
                    if (v18944) {
                        const v18945 = map.yyyy;
                        const v18946 = date.setFullYear(v18945);
                        v18946;
                    }
                    return date;
                }
            }
            return NaN;
        };
        return v18947;
    };
    const createDateInputType = function (type, regexp, parseDate, format) {
        const v19042 = function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            const v18948 = badInputChecker(scope, element, attr, ctrl, type);
            v18948;
            const v18949 = baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            v18949;
            const v18950 = type === 'time';
            const v18951 = type === 'datetimelocal';
            var isTimeType = v18950 || v18951;
            var previousDate;
            var previousTimezone;
            const v18952 = ctrl.$parsers;
            const v18956 = function (value) {
                const v18953 = ctrl.$isEmpty(value);
                if (v18953) {
                    return null;
                }
                const v18954 = regexp.test(value);
                if (v18954) {
                    const v18955 = parseDateAndConvertTimeZoneToLocal(value, previousDate);
                    return v18955;
                }
                ctrl.$$parserName = type;
                return undefined;
            };
            const v18957 = v18952.push(v18956);
            v18957;
            const v18958 = ctrl.$formatters;
            const v18966 = function (value) {
                const v18959 = isDate(value);
                const v18960 = !v18959;
                const v18961 = value && v18960;
                if (v18961) {
                    const v18962 = ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
                    throw v18962;
                }
                const v18963 = isValidDate(value);
                if (v18963) {
                    previousDate = value;
                    const v18964 = ctrl.$options;
                    var timezone = v18964.getOption('timezone');
                    if (timezone) {
                        previousTimezone = timezone;
                        previousDate = convertTimezoneToLocal(previousDate, timezone, true);
                    }
                    const v18965 = formatter(value, timezone);
                    return v18965;
                } else {
                    previousDate = null;
                    previousTimezone = null;
                    return '';
                }
            };
            const v18967 = v18958.push(v18966);
            v18967;
            const v18968 = attr.min;
            const v18969 = isDefined(v18968);
            const v18970 = attr.ngMin;
            const v18971 = v18969 || v18970;
            if (v18971) {
                const v18972 = attr.min;
                const v18973 = attr.ngMin;
                const v18974 = $parse(v18973);
                const v18975 = v18974(scope);
                var minVal = v18972 || v18975;
                var parsedMinVal = parseObservedDateValue(minVal);
                const v18976 = ctrl.$validators;
                const v18984 = function (value) {
                    const v18977 = isValidDate(value);
                    const v18978 = !v18977;
                    const v18979 = isUndefined(parsedMinVal);
                    const v18980 = v18978 || v18979;
                    const v18981 = parseDate(value);
                    const v18982 = v18981 >= parsedMinVal;
                    const v18983 = v18980 || v18982;
                    return v18983;
                };
                v18976.min = v18984;
                const v18987 = function (val) {
                    const v18985 = val !== minVal;
                    if (v18985) {
                        parsedMinVal = parseObservedDateValue(val);
                        minVal = val;
                        const v18986 = ctrl.$validate();
                        v18986;
                    }
                };
                const v18988 = attr.$observe('min', v18987);
                v18988;
            }
            const v18989 = attr.max;
            const v18990 = isDefined(v18989);
            const v18991 = attr.ngMax;
            const v18992 = v18990 || v18991;
            if (v18992) {
                const v18993 = attr.max;
                const v18994 = attr.ngMax;
                const v18995 = $parse(v18994);
                const v18996 = v18995(scope);
                var maxVal = v18993 || v18996;
                var parsedMaxVal = parseObservedDateValue(maxVal);
                const v18997 = ctrl.$validators;
                const v19005 = function (value) {
                    const v18998 = isValidDate(value);
                    const v18999 = !v18998;
                    const v19000 = isUndefined(parsedMaxVal);
                    const v19001 = v18999 || v19000;
                    const v19002 = parseDate(value);
                    const v19003 = v19002 <= parsedMaxVal;
                    const v19004 = v19001 || v19003;
                    return v19004;
                };
                v18997.max = v19005;
                const v19008 = function (val) {
                    const v19006 = val !== maxVal;
                    if (v19006) {
                        parsedMaxVal = parseObservedDateValue(val);
                        maxVal = val;
                        const v19007 = ctrl.$validate();
                        v19007;
                    }
                };
                const v19009 = attr.$observe('max', v19008);
                v19009;
            }
            const isValidDate = function (value) {
                const v19010 = value.getTime;
                const v19011 = value.getTime();
                const v19012 = value.getTime();
                const v19013 = v19011 !== v19012;
                const v19014 = v19010 && v19013;
                const v19015 = !v19014;
                const v19016 = value && v19015;
                return v19016;
            };
            const parseObservedDateValue = function (val) {
                const v19017 = isDefined(val);
                const v19018 = isDate(val);
                const v19019 = !v19018;
                const v19020 = v19017 && v19019;
                const v19021 = parseDateAndConvertTimeZoneToLocal(val);
                const v19022 = v19021 || undefined;
                let v19023;
                if (v19020) {
                    v19023 = v19022;
                } else {
                    v19023 = val;
                }
                return v19023;
            };
            const parseDateAndConvertTimeZoneToLocal = function (value, previousDate) {
                const v19024 = ctrl.$options;
                var timezone = v19024.getOption('timezone');
                const v19025 = previousTimezone !== timezone;
                const v19026 = previousTimezone && v19025;
                if (v19026) {
                    const v19027 = timezoneToOffset(previousTimezone);
                    previousDate = addDateMinutes(previousDate, v19027);
                }
                var parsedDate = parseDate(value, previousDate);
                const v19028 = isNaN(parsedDate);
                const v19029 = !v19028;
                const v19030 = v19029 && timezone;
                if (v19030) {
                    parsedDate = convertTimezoneToLocal(parsedDate, timezone);
                }
                return parsedDate;
            };
            const formatter = function (value, timezone) {
                var targetFormat = format;
                const v19031 = ctrl.$options;
                const v19032 = v19031.getOption('timeSecondsFormat');
                const v19033 = isString(v19032);
                const v19034 = isTimeType && v19033;
                if (v19034) {
                    const v19035 = ctrl.$options;
                    const v19036 = v19035.getOption('timeSecondsFormat');
                    const v19037 = format.replace('ss.sss', v19036);
                    targetFormat = v19037.replace(/:$/, '');
                }
                const v19038 = $filter('date');
                var formatted = v19038(value, targetFormat, timezone);
                const v19039 = ctrl.$options;
                const v19040 = v19039.getOption('timeStripZeroSeconds');
                const v19041 = isTimeType && v19040;
                if (v19041) {
                    formatted = formatted.replace(/(?::00)?(?:\.000)?$/, '');
                }
                return formatted;
            };
        };
        return v19042;
    };
    const badInputChecker = function (scope, element, attr, ctrl, parserName) {
        var node = element[0];
        const v19043 = node.validity;
        const v19044 = isObject(v19043);
        ctrl.$$hasNativeValidators = v19044;
        var nativeValidation = ctrl.$$hasNativeValidators;
        if (nativeValidation) {
            const v19045 = ctrl.$parsers;
            const v19051 = function (value) {
                const v19046 = element.prop(VALIDITY_STATE_PROPERTY);
                const v19047 = {};
                var validity = v19046 || v19047;
                const v19048 = validity.badInput;
                const v19049 = validity.typeMismatch;
                const v19050 = v19048 || v19049;
                if (v19050) {
                    ctrl.$$parserName = parserName;
                    return undefined;
                }
                return value;
            };
            const v19052 = v19045.push(v19051);
            v19052;
        }
    };
    const numberFormatterParser = function (ctrl) {
        const v19053 = ctrl.$parsers;
        const v19057 = function (value) {
            const v19054 = ctrl.$isEmpty(value);
            if (v19054) {
                return null;
            }
            const v19055 = NUMBER_REGEXP.test(value);
            if (v19055) {
                const v19056 = parseFloat(value);
                return v19056;
            }
            ctrl.$$parserName = 'number';
            return undefined;
        };
        const v19058 = v19053.push(v19057);
        v19058;
        const v19059 = ctrl.$formatters;
        const v19065 = function (value) {
            const v19060 = ctrl.$isEmpty(value);
            const v19061 = !v19060;
            if (v19061) {
                const v19062 = isNumber(value);
                const v19063 = !v19062;
                if (v19063) {
                    const v19064 = ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
                    throw v19064;
                }
                value = value.toString();
            }
            return value;
        };
        const v19066 = v19059.push(v19065);
        v19066;
    };
    const parseNumberAttrVal = function (val) {
        const v19067 = isDefined(val);
        const v19068 = isNumber(val);
        const v19069 = !v19068;
        const v19070 = v19067 && v19069;
        if (v19070) {
            val = parseFloat(val);
        }
        const v19071 = isNumberNaN(val);
        const v19072 = !v19071;
        let v19073;
        if (v19072) {
            v19073 = val;
        } else {
            v19073 = undefined;
        }
        return v19073;
    };
    const isNumberInteger = function (num) {
        const v19074 = num | 0;
        const v19075 = v19074 === num;
        return v19075;
    };
    const countDecimals = function (num) {
        var numString = num.toString();
        var decimalSymbolIndex = numString.indexOf('.');
        const v19076 = -1;
        const v19077 = decimalSymbolIndex === v19076;
        if (v19077) {
            const v19078 = -1;
            const v19079 = v19078 < num;
            const v19080 = num < 1;
            const v19081 = v19079 && v19080;
            if (v19081) {
                var match = /e-(\d+)$/.exec(numString);
                if (match) {
                    const v19082 = match[1];
                    const v19083 = Number(v19082);
                    return v19083;
                }
            }
            return 0;
        }
        const v19084 = numString.length;
        const v19085 = v19084 - decimalSymbolIndex;
        const v19086 = v19085 - 1;
        return v19086;
    };
    const isValidForStep = function (viewValue, stepBase, step) {
        var value = Number(viewValue);
        const v19087 = isNumberInteger(value);
        const v19088 = !v19087;
        var isNonIntegerValue = v19088;
        const v19089 = isNumberInteger(stepBase);
        const v19090 = !v19089;
        var isNonIntegerStepBase = v19090;
        const v19091 = isNumberInteger(step);
        const v19092 = !v19091;
        var isNonIntegerStep = v19092;
        const v19093 = isNonIntegerValue || isNonIntegerStepBase;
        const v19094 = v19093 || isNonIntegerStep;
        if (v19094) {
            let valueDecimals;
            const v19095 = countDecimals(value);
            if (isNonIntegerValue) {
                valueDecimals = v19095;
            } else {
                valueDecimals = 0;
            }
            let stepBaseDecimals;
            const v19096 = countDecimals(stepBase);
            if (isNonIntegerStepBase) {
                stepBaseDecimals = v19096;
            } else {
                stepBaseDecimals = 0;
            }
            let stepDecimals;
            const v19097 = countDecimals(step);
            if (isNonIntegerStep) {
                stepDecimals = v19097;
            } else {
                stepDecimals = 0;
            }
            var decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals);
            var multiplier = Math.pow(10, decimalCount);
            value = value * multiplier;
            stepBase = stepBase * multiplier;
            step = step * multiplier;
            if (isNonIntegerValue) {
                value = Math.round(value);
            }
            if (isNonIntegerStepBase) {
                stepBase = Math.round(stepBase);
            }
            if (isNonIntegerStep) {
                step = Math.round(step);
            }
        }
        const v19098 = value - stepBase;
        const v19099 = v19098 % step;
        const v19100 = v19099 === 0;
        return v19100;
    };
    const numberInputType = function (scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        const v19101 = badInputChecker(scope, element, attr, ctrl, 'number');
        v19101;
        const v19102 = numberFormatterParser(ctrl);
        v19102;
        const v19103 = baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        v19103;
        var parsedMinVal;
        const v19104 = attr.min;
        const v19105 = isDefined(v19104);
        const v19106 = attr.ngMin;
        const v19107 = v19105 || v19106;
        if (v19107) {
            const v19108 = attr.min;
            const v19109 = attr.ngMin;
            const v19110 = $parse(v19109);
            const v19111 = v19110(scope);
            var minVal = v19108 || v19111;
            parsedMinVal = parseNumberAttrVal(minVal);
            const v19112 = ctrl.$validators;
            const v19118 = function (modelValue, viewValue) {
                const v19113 = ctrl.$isEmpty(viewValue);
                const v19114 = isUndefined(parsedMinVal);
                const v19115 = v19113 || v19114;
                const v19116 = viewValue >= parsedMinVal;
                const v19117 = v19115 || v19116;
                return v19117;
            };
            v19112.min = v19118;
            const v19121 = function (val) {
                const v19119 = val !== minVal;
                if (v19119) {
                    parsedMinVal = parseNumberAttrVal(val);
                    minVal = val;
                    const v19120 = ctrl.$validate();
                    v19120;
                }
            };
            const v19122 = attr.$observe('min', v19121);
            v19122;
        }
        const v19123 = attr.max;
        const v19124 = isDefined(v19123);
        const v19125 = attr.ngMax;
        const v19126 = v19124 || v19125;
        if (v19126) {
            const v19127 = attr.max;
            const v19128 = attr.ngMax;
            const v19129 = $parse(v19128);
            const v19130 = v19129(scope);
            var maxVal = v19127 || v19130;
            var parsedMaxVal = parseNumberAttrVal(maxVal);
            const v19131 = ctrl.$validators;
            const v19137 = function (modelValue, viewValue) {
                const v19132 = ctrl.$isEmpty(viewValue);
                const v19133 = isUndefined(parsedMaxVal);
                const v19134 = v19132 || v19133;
                const v19135 = viewValue <= parsedMaxVal;
                const v19136 = v19134 || v19135;
                return v19136;
            };
            v19131.max = v19137;
            const v19140 = function (val) {
                const v19138 = val !== maxVal;
                if (v19138) {
                    parsedMaxVal = parseNumberAttrVal(val);
                    maxVal = val;
                    const v19139 = ctrl.$validate();
                    v19139;
                }
            };
            const v19141 = attr.$observe('max', v19140);
            v19141;
        }
        const v19142 = attr.step;
        const v19143 = isDefined(v19142);
        const v19144 = attr.ngStep;
        const v19145 = v19143 || v19144;
        if (v19145) {
            const v19146 = attr.step;
            const v19147 = attr.ngStep;
            const v19148 = $parse(v19147);
            const v19149 = v19148(scope);
            var stepVal = v19146 || v19149;
            var parsedStepVal = parseNumberAttrVal(stepVal);
            const v19150 = ctrl.$validators;
            const v19157 = function (modelValue, viewValue) {
                const v19151 = ctrl.$isEmpty(viewValue);
                const v19152 = isUndefined(parsedStepVal);
                const v19153 = v19151 || v19152;
                const v19154 = parsedMinVal || 0;
                const v19155 = isValidForStep(viewValue, v19154, parsedStepVal);
                const v19156 = v19153 || v19155;
                return v19156;
            };
            v19150.step = v19157;
            const v19160 = function (val) {
                const v19158 = val !== stepVal;
                if (v19158) {
                    parsedStepVal = parseNumberAttrVal(val);
                    stepVal = val;
                    const v19159 = ctrl.$validate();
                    v19159;
                }
            };
            const v19161 = attr.$observe('step', v19160);
            v19161;
        }
    };
    const rangeInputType = function (scope, element, attr, ctrl, $sniffer, $browser) {
        const v19162 = badInputChecker(scope, element, attr, ctrl, 'range');
        v19162;
        const v19163 = numberFormatterParser(ctrl);
        v19163;
        const v19164 = baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        v19164;
        const v19165 = ctrl.$$hasNativeValidators;
        const v19166 = element[0];
        const v19167 = v19166.type;
        const v19168 = v19167 === 'range';
        var supportsRange = v19165 && v19168;
        let minVal;
        if (supportsRange) {
            minVal = 0;
        } else {
            minVal = undefined;
        }
        let maxVal;
        if (supportsRange) {
            maxVal = 100;
        } else {
            maxVal = undefined;
        }
        let stepVal;
        if (supportsRange) {
            stepVal = 1;
        } else {
            stepVal = undefined;
        }
        const v19169 = element[0];
        var validity = v19169.validity;
        const v19170 = attr.min;
        var hasMinAttr = isDefined(v19170);
        const v19171 = attr.max;
        var hasMaxAttr = isDefined(v19171);
        const v19172 = attr.step;
        var hasStepAttr = isDefined(v19172);
        var originalRender = ctrl.$render;
        const v19173 = validity.rangeUnderflow;
        const v19174 = isDefined(v19173);
        const v19175 = supportsRange && v19174;
        const v19176 = validity.rangeOverflow;
        const v19177 = isDefined(v19176);
        const v19178 = v19175 && v19177;
        const v19182 = function rangeRender() {
            const v19179 = originalRender();
            v19179;
            const v19180 = element.val();
            const v19181 = ctrl.$setViewValue(v19180);
            v19181;
        };
        let v19183;
        if (v19178) {
            v19183 = v19182;
        } else {
            v19183 = originalRender;
        }
        ctrl.$render = v19183;
        if (hasMinAttr) {
            const v19184 = attr.min;
            minVal = parseNumberAttrVal(v19184);
            const v19185 = ctrl.$validators;
            const v19186 = function noopMinValidator() {
                return true;
            };
            const v19192 = function minValidator(modelValue, viewValue) {
                const v19187 = ctrl.$isEmpty(viewValue);
                const v19188 = isUndefined(minVal);
                const v19189 = v19187 || v19188;
                const v19190 = viewValue >= minVal;
                const v19191 = v19189 || v19190;
                return v19191;
            };
            let v19193;
            if (supportsRange) {
                v19193 = v19186;
            } else {
                v19193 = v19192;
            }
            v19185.min = v19193;
            const v19194 = setInitialValueAndObserver('min', minChange);
            v19194;
        }
        if (hasMaxAttr) {
            const v19195 = attr.max;
            maxVal = parseNumberAttrVal(v19195);
            const v19196 = ctrl.$validators;
            const v19197 = function noopMaxValidator() {
                return true;
            };
            const v19203 = function maxValidator(modelValue, viewValue) {
                const v19198 = ctrl.$isEmpty(viewValue);
                const v19199 = isUndefined(maxVal);
                const v19200 = v19198 || v19199;
                const v19201 = viewValue <= maxVal;
                const v19202 = v19200 || v19201;
                return v19202;
            };
            let v19204;
            if (supportsRange) {
                v19204 = v19197;
            } else {
                v19204 = v19203;
            }
            v19196.max = v19204;
            const v19205 = setInitialValueAndObserver('max', maxChange);
            v19205;
        }
        if (hasStepAttr) {
            const v19206 = attr.step;
            stepVal = parseNumberAttrVal(v19206);
            const v19207 = ctrl.$validators;
            const v19210 = function nativeStepValidator() {
                const v19208 = validity.stepMismatch;
                const v19209 = !v19208;
                return v19209;
            };
            const v19217 = function stepValidator(modelValue, viewValue) {
                const v19211 = ctrl.$isEmpty(viewValue);
                const v19212 = isUndefined(stepVal);
                const v19213 = v19211 || v19212;
                const v19214 = minVal || 0;
                const v19215 = isValidForStep(viewValue, v19214, stepVal);
                const v19216 = v19213 || v19215;
                return v19216;
            };
            let v19218;
            if (supportsRange) {
                v19218 = v19210;
            } else {
                v19218 = v19217;
            }
            v19207.step = v19218;
            const v19219 = setInitialValueAndObserver('step', stepChange);
            v19219;
        }
        const setInitialValueAndObserver = function (htmlAttrName, changeFn) {
            const v19220 = attr[htmlAttrName];
            const v19221 = element.attr(htmlAttrName, v19220);
            v19221;
            var oldVal = attr[htmlAttrName];
            const v19224 = function wrappedObserver(val) {
                const v19222 = val !== oldVal;
                if (v19222) {
                    oldVal = val;
                    const v19223 = changeFn(val);
                    v19223;
                }
            };
            const v19225 = attr.$observe(htmlAttrName, v19224);
            v19225;
        };
        const minChange = function (val) {
            minVal = parseNumberAttrVal(val);
            const v19226 = ctrl.$modelValue;
            const v19227 = isNumberNaN(v19226);
            if (v19227) {
                return;
            }
            if (supportsRange) {
                var elVal = element.val();
                const v19228 = minVal > elVal;
                if (v19228) {
                    elVal = minVal;
                    const v19229 = element.val(elVal);
                    v19229;
                }
                const v19230 = ctrl.$setViewValue(elVal);
                v19230;
            } else {
                const v19231 = ctrl.$validate();
                v19231;
            }
        };
        const maxChange = function (val) {
            maxVal = parseNumberAttrVal(val);
            const v19232 = ctrl.$modelValue;
            const v19233 = isNumberNaN(v19232);
            if (v19233) {
                return;
            }
            if (supportsRange) {
                var elVal = element.val();
                const v19234 = maxVal < elVal;
                if (v19234) {
                    const v19235 = element.val(maxVal);
                    v19235;
                    const v19236 = maxVal < minVal;
                    if (v19236) {
                        elVal = minVal;
                    } else {
                        elVal = maxVal;
                    }
                }
                const v19237 = ctrl.$setViewValue(elVal);
                v19237;
            } else {
                const v19238 = ctrl.$validate();
                v19238;
            }
        };
        const stepChange = function (val) {
            stepVal = parseNumberAttrVal(val);
            const v19239 = ctrl.$modelValue;
            const v19240 = isNumberNaN(v19239);
            if (v19240) {
                return;
            }
            const v19241 = !supportsRange;
            if (v19241) {
                const v19242 = ctrl.$validate();
                v19242;
            } else {
                const v19243 = ctrl.$viewValue;
                const v19244 = element.val();
                const v19245 = v19243 !== v19244;
                if (v19245) {
                    const v19246 = element.val();
                    const v19247 = ctrl.$setViewValue(v19246);
                    v19247;
                }
            }
        };
    };
    const urlInputType = function (scope, element, attr, ctrl, $sniffer, $browser) {
        const v19248 = baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        v19248;
        const v19249 = stringBasedInputType(ctrl);
        v19249;
        const v19250 = ctrl.$validators;
        const v19254 = function (modelValue, viewValue) {
            var value = modelValue || viewValue;
            const v19251 = ctrl.$isEmpty(value);
            const v19252 = URL_REGEXP.test(value);
            const v19253 = v19251 || v19252;
            return v19253;
        };
        v19250.url = v19254;
    };
    const emailInputType = function (scope, element, attr, ctrl, $sniffer, $browser) {
        const v19255 = baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        v19255;
        const v19256 = stringBasedInputType(ctrl);
        v19256;
        const v19257 = ctrl.$validators;
        const v19261 = function (modelValue, viewValue) {
            var value = modelValue || viewValue;
            const v19258 = ctrl.$isEmpty(value);
            const v19259 = EMAIL_REGEXP.test(value);
            const v19260 = v19258 || v19259;
            return v19260;
        };
        v19257.email = v19261;
    };
    const radioInputType = function (scope, element, attr, ctrl) {
        const v19262 = attr.ngTrim;
        const v19263 = !v19262;
        const v19264 = attr.ngTrim;
        const v19265 = trim(v19264);
        const v19266 = v19265 !== 'false';
        var doTrim = v19263 || v19266;
        const v19267 = attr.name;
        const v19268 = isUndefined(v19267);
        if (v19268) {
            const v19269 = nextUid();
            const v19270 = element.attr('name', v19269);
            v19270;
        }
        var listener = function (ev) {
            var value;
            const v19271 = element[0];
            const v19272 = v19271.checked;
            if (v19272) {
                value = attr.value;
                if (doTrim) {
                    value = trim(value);
                }
                const v19273 = ev.type;
                const v19274 = ev && v19273;
                const v19275 = ctrl.$setViewValue(value, v19274);
                v19275;
            }
        };
        const v19276 = element.on('change', listener);
        v19276;
        const v19279 = function () {
            var value = attr.value;
            if (doTrim) {
                value = trim(value);
            }
            const v19277 = element[0];
            const v19278 = ctrl.$viewValue;
            v19277.checked = value === v19278;
        };
        ctrl.$render = v19279;
        const v19280 = ctrl.$render;
        const v19281 = attr.$observe('value', v19280);
        v19281;
    };
    const parseConstantExpr = function ($parse, context, name, expression, fallback) {
        var parseFn;
        const v19282 = isDefined(expression);
        if (v19282) {
            parseFn = $parse(expression);
            const v19283 = parseFn.constant;
            const v19284 = !v19283;
            if (v19284) {
                const v19285 = 'Expected constant expression for `{0}`, but saw ' + '`{1}`.';
                const v19286 = ngModelMinErr('constexpr', v19285, name, expression);
                throw v19286;
            }
            const v19287 = parseFn(context);
            return v19287;
        }
        return fallback;
    };
    const checkboxInputType = function (scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        const v19288 = attr.ngTrueValue;
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', v19288, true);
        const v19289 = attr.ngFalseValue;
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', v19289, false);
        var listener = function (ev) {
            const v19290 = element[0];
            const v19291 = v19290.checked;
            const v19292 = ev.type;
            const v19293 = ev && v19292;
            const v19294 = ctrl.$setViewValue(v19291, v19293);
            v19294;
        };
        const v19295 = element.on('change', listener);
        v19295;
        const v19298 = function () {
            const v19296 = element[0];
            const v19297 = ctrl.$viewValue;
            v19296.checked = v19297;
        };
        ctrl.$render = v19298;
        const v19300 = function (value) {
            const v19299 = value === false;
            return v19299;
        };
        ctrl.$isEmpty = v19300;
        const v19301 = ctrl.$formatters;
        const v19303 = function (value) {
            const v19302 = equals(value, trueValue);
            return v19302;
        };
        const v19304 = v19301.push(v19303);
        v19304;
        const v19305 = ctrl.$parsers;
        const v19307 = function (value) {
            let v19306;
            if (value) {
                v19306 = trueValue;
            } else {
                v19306 = falseValue;
            }
            return v19306;
        };
        const v19308 = v19305.push(v19307);
        v19308;
    };
    const v19321 = function ($browser, $sniffer, $filter, $parse) {
        const v19309 = ['?ngModel'];
        const v19318 = function (scope, element, attr, ctrls) {
            const v19310 = ctrls[0];
            if (v19310) {
                const v19311 = attr.type;
                const v19312 = lowercase(v19311);
                const v19313 = inputType[v19312];
                const v19314 = inputType.text;
                const v19315 = v19313 || v19314;
                const v19316 = ctrls[0];
                const v19317 = v19315(scope, element, attr, v19316, $sniffer, $browser, $filter, $parse);
                v19317;
            }
        };
        const v19319 = {};
        v19319.pre = v19318;
        const v19320 = {};
        v19320.restrict = 'E';
        v19320.require = v19309;
        v19320.link = v19319;
        return v19320;
    };
    var inputDirective = [
        '$browser',
        '$sniffer',
        '$filter',
        '$parse',
        v19321
    ];
    var hiddenInputBrowserCacheDirective = function () {
        const v19324 = function () {
            const v19322 = this.getAttribute('value');
            const v19323 = v19322 || '';
            return v19323;
        };
        const v19326 = function (val) {
            const v19325 = this.setAttribute('value', val);
            v19325;
        };
        var valueProperty = {};
        valueProperty.configurable = true;
        valueProperty.enumerable = false;
        valueProperty.get = v19324;
        valueProperty.set = v19326;
        const v19338 = function (_, attr) {
            const v19327 = attr.type;
            const v19328 = lowercase(v19327);
            const v19329 = v19328 !== 'hidden';
            if (v19329) {
                return;
            }
            const v19336 = function (scope, element, attr, ctrls) {
                var node = element[0];
                const v19330 = node.parentNode;
                if (v19330) {
                    const v19331 = node.parentNode;
                    const v19332 = node.nextSibling;
                    const v19333 = v19331.insertBefore(node, v19332);
                    v19333;
                }
                const v19334 = Object.defineProperty;
                if (v19334) {
                    const v19335 = Object.defineProperty(node, 'value', valueProperty);
                    v19335;
                }
            };
            const v19337 = {};
            v19337.pre = v19336;
            return v19337;
        };
        const v19339 = {};
        v19339.restrict = 'E';
        v19339.priority = 200;
        v19339.compile = v19338;
        return v19339;
    };
    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
    var ngValueDirective = function () {
        const updateElementValue = function (element, attr, value) {
            let propValue;
            const v19340 = isDefined(value);
            const v19341 = msie === 9;
            let v19342;
            if (v19341) {
                v19342 = '';
            } else {
                v19342 = null;
            }
            if (v19340) {
                propValue = value;
            } else {
                propValue = v19342;
            }
            const v19343 = element.prop('value', propValue);
            v19343;
            const v19344 = attr.$set('value', value);
            v19344;
        };
        const v19355 = function (tpl, tplAttr) {
            const v19345 = tplAttr.ngValue;
            const v19346 = CONSTANT_VALUE_REGEXP.test(v19345);
            if (v19346) {
                const v19349 = function ngValueConstantLink(scope, elm, attr) {
                    const v19347 = attr.ngValue;
                    var value = scope.$eval(v19347);
                    const v19348 = updateElementValue(elm, attr, value);
                    v19348;
                };
                return v19349;
            } else {
                const v19354 = function ngValueLink(scope, elm, attr) {
                    const v19350 = attr.ngValue;
                    const v19352 = function valueWatchAction(value) {
                        const v19351 = updateElementValue(elm, attr, value);
                        v19351;
                    };
                    const v19353 = scope.$watch(v19350, v19352);
                    v19353;
                };
                return v19354;
            }
        };
        const v19356 = {};
        v19356.restrict = 'A';
        v19356.priority = 100;
        v19356.compile = v19355;
        return v19356;
    };
    const v19367 = function ($compile) {
        const v19365 = function ngBindCompile(templateElement) {
            const v19357 = $compile.$$addBindingClass(templateElement);
            v19357;
            const v19364 = function ngBindLink(scope, element, attr) {
                const v19358 = attr.ngBind;
                const v19359 = $compile.$$addBindingInfo(element, v19358);
                v19359;
                element = element[0];
                const v19360 = attr.ngBind;
                const v19362 = function ngBindWatchAction(value) {
                    const v19361 = stringify(value);
                    element.textContent = v19361;
                };
                const v19363 = scope.$watch(v19360, v19362);
                v19363;
            };
            return v19364;
        };
        const v19366 = {};
        v19366.restrict = 'AC';
        v19366.compile = v19365;
        return v19366;
    };
    var ngBindDirective = [
        '$compile',
        v19367
    ];
    const v19381 = function ($interpolate, $compile) {
        const v19379 = function ngBindTemplateCompile(templateElement) {
            const v19368 = $compile.$$addBindingClass(templateElement);
            v19368;
            const v19378 = function ngBindTemplateLink(scope, element, attr) {
                const v19369 = attr.$attr;
                const v19370 = v19369.ngBindTemplate;
                const v19371 = element.attr(v19370);
                var interpolateFn = $interpolate(v19371);
                const v19372 = interpolateFn.expressions;
                const v19373 = $compile.$$addBindingInfo(element, v19372);
                v19373;
                element = element[0];
                const v19376 = function (value) {
                    const v19374 = isUndefined(value);
                    let v19375;
                    if (v19374) {
                        v19375 = '';
                    } else {
                        v19375 = value;
                    }
                    element.textContent = v19375;
                };
                const v19377 = attr.$observe('ngBindTemplate', v19376);
                v19377;
            };
            return v19378;
        };
        const v19380 = {};
        v19380.compile = v19379;
        return v19380;
    };
    var ngBindTemplateDirective = [
        '$interpolate',
        '$compile',
        v19381
    ];
    const v19397 = function ($sce, $parse, $compile) {
        const v19395 = function ngBindHtmlCompile(tElement, tAttrs) {
            const v19382 = tAttrs.ngBindHtml;
            var ngBindHtmlGetter = $parse(v19382);
            const v19383 = tAttrs.ngBindHtml;
            const v19385 = function sceValueOf(val) {
                const v19384 = $sce.valueOf(val);
                return v19384;
            };
            var ngBindHtmlWatch = $parse(v19383, v19385);
            const v19386 = $compile.$$addBindingClass(tElement);
            v19386;
            const v19394 = function ngBindHtmlLink(scope, element, attr) {
                const v19387 = attr.ngBindHtml;
                const v19388 = $compile.$$addBindingInfo(element, v19387);
                v19388;
                const v19392 = function ngBindHtmlWatchAction() {
                    var value = ngBindHtmlGetter(scope);
                    const v19389 = $sce.getTrustedHtml(value);
                    const v19390 = v19389 || '';
                    const v19391 = element.html(v19390);
                    v19391;
                };
                const v19393 = scope.$watch(ngBindHtmlWatch, v19392);
                v19393;
            };
            return v19394;
        };
        const v19396 = {};
        v19396.restrict = 'A';
        v19396.compile = v19395;
        return v19396;
    };
    var ngBindHtmlDirective = [
        '$sce',
        '$parse',
        '$compile',
        v19397
    ];
    const v19403 = function (scope, element, attr, ctrl) {
        const v19398 = ctrl.$viewChangeListeners;
        const v19401 = function () {
            const v19399 = attr.ngChange;
            const v19400 = scope.$eval(v19399);
            v19400;
        };
        const v19402 = v19398.push(v19401);
        v19402;
    };
    const v19404 = {
        restrict: 'A',
        require: 'ngModel',
        link: v19403
    };
    var ngChangeDirective = valueFn(v19404);
    const classDirective = function (name, selector) {
        name = 'ngClass' + name;
        var indexWatchExpression;
        const v19443 = function ($parse) {
            const v19441 = function (scope, element, attr) {
                var classCounts = element.data('$classCounts');
                var oldModulo = true;
                var oldClassString;
                const v19405 = !classCounts;
                if (v19405) {
                    classCounts = createMap();
                    const v19406 = element.data('$classCounts', classCounts);
                    v19406;
                }
                const v19407 = name !== 'ngClass';
                if (v19407) {
                    const v19408 = !indexWatchExpression;
                    if (v19408) {
                        const v19410 = function moduloTwo($index) {
                            const v19409 = $index & 1;
                            return v19409;
                        };
                        indexWatchExpression = $parse('$index', v19410);
                    }
                    const v19411 = scope.$watch(indexWatchExpression, ngClassIndexWatchAction);
                    v19411;
                }
                const v19412 = attr[name];
                const v19413 = $parse(v19412, toClassString);
                const v19414 = scope.$watch(v19413, ngClassWatchAction);
                v19414;
                const addClasses = function (classString) {
                    const v19415 = split(classString);
                    classString = digestClassCounts(v19415, 1);
                    const v19416 = attr.$addClass(classString);
                    v19416;
                };
                const removeClasses = function (classString) {
                    const v19417 = split(classString);
                    const v19418 = -1;
                    classString = digestClassCounts(v19417, v19418);
                    const v19419 = attr.$removeClass(classString);
                    v19419;
                };
                const updateClasses = function (oldClassString, newClassString) {
                    var oldClassArray = split(oldClassString);
                    var newClassArray = split(newClassString);
                    var toRemoveArray = arrayDifference(oldClassArray, newClassArray);
                    var toAddArray = arrayDifference(newClassArray, oldClassArray);
                    const v19420 = -1;
                    var toRemoveString = digestClassCounts(toRemoveArray, v19420);
                    var toAddString = digestClassCounts(toAddArray, 1);
                    const v19421 = attr.$addClass(toAddString);
                    v19421;
                    const v19422 = attr.$removeClass(toRemoveString);
                    v19422;
                };
                const digestClassCounts = function (classArray, count) {
                    var classesToUpdate = [];
                    const v19433 = function (className) {
                        const v19423 = count > 0;
                        const v19424 = classCounts[className];
                        const v19425 = v19423 || v19424;
                        if (v19425) {
                            const v19426 = classCounts[className];
                            const v19427 = v19426 || 0;
                            classCounts[className] = v19427 + count;
                            const v19428 = classCounts[className];
                            const v19429 = count > 0;
                            const v19430 = +v19429;
                            const v19431 = v19428 === v19430;
                            if (v19431) {
                                const v19432 = classesToUpdate.push(className);
                                v19432;
                            }
                        }
                    };
                    const v19434 = forEach(classArray, v19433);
                    v19434;
                    const v19435 = classesToUpdate.join(' ');
                    return v19435;
                };
                const ngClassIndexWatchAction = function (newModulo) {
                    const v19436 = newModulo === selector;
                    if (v19436) {
                        const v19437 = addClasses(oldClassString);
                        v19437;
                    } else {
                        const v19438 = removeClasses(oldClassString);
                        v19438;
                    }
                    oldModulo = newModulo;
                };
                const ngClassWatchAction = function (newClassString) {
                    const v19439 = oldModulo === selector;
                    if (v19439) {
                        const v19440 = updateClasses(oldClassString, newClassString);
                        v19440;
                    }
                    oldClassString = newClassString;
                };
            };
            const v19442 = {};
            v19442.restrict = 'AC';
            v19442.link = v19441;
            return v19442;
        };
        const v19444 = [
            '$parse',
            v19443
        ];
        return v19444;
        const arrayDifference = function (tokens1, tokens2) {
            const v19445 = !tokens1;
            const v19446 = tokens1.length;
            const v19447 = !v19446;
            const v19448 = v19445 || v19447;
            if (v19448) {
                const v19449 = [];
                return v19449;
            }
            const v19450 = !tokens2;
            const v19451 = tokens2.length;
            const v19452 = !v19451;
            const v19453 = v19450 || v19452;
            if (v19453) {
                return tokens1;
            }
            var values = [];
            outer: {
                var i = 0;
                const v19454 = tokens1.length;
                let v19455 = i < v19454;
                while (v19455) {
                    var token = tokens1[i];
                    var j = 0;
                    const v19457 = tokens2.length;
                    let v19458 = j < v19457;
                    while (v19458) {
                        const v19460 = tokens2[j];
                        const v19461 = token === v19460;
                        if (v19461) {
                            continue outer;
                        }
                        const v19459 = j++;
                        v19458 = j < v19457;
                    }
                    const v19462 = values.push(token);
                    v19462;
                    const v19456 = i++;
                    v19455 = i < v19454;
                }
            }
            return values;
        };
        const split = function (classString) {
            const v19463 = classString.split(' ');
            const v19464 = classString && v19463;
            return v19464;
        };
        const toClassString = function (classValue) {
            const v19465 = !classValue;
            if (v19465) {
                return classValue;
            }
            var classString = classValue;
            const v19466 = isArray(classValue);
            if (v19466) {
                const v19467 = classValue.map(toClassString);
                classString = v19467.join(' ');
            } else {
                const v19468 = isObject(classValue);
                if (v19468) {
                    const v19469 = Object.keys(classValue);
                    const v19471 = function (key) {
                        const v19470 = classValue[key];
                        return v19470;
                    };
                    const v19472 = v19469.filter(v19471);
                    classString = v19472.join(' ');
                } else {
                    const v19473 = isString(classValue);
                    const v19474 = !v19473;
                    if (v19474) {
                        classString = classValue + '';
                    }
                }
            }
            return classString;
        };
    };
    var ngClassDirective = classDirective('', true);
    var ngClassOddDirective = classDirective('Odd', 0);
    var ngClassEvenDirective = classDirective('Even', 1);
    const v19477 = function (element, attr) {
        const v19475 = attr.$set('ngCloak', undefined);
        v19475;
        const v19476 = element.removeClass('ng-cloak');
        v19476;
    };
    const v19478 = { compile: v19477 };
    var ngCloakDirective = ngDirective(v19478);
    const v19480 = function () {
        const v19479 = {};
        v19479.restrict = 'A';
        v19479.scope = true;
        v19479.controller = '@';
        v19479.priority = 500;
        return v19479;
    };
    var ngControllerDirective = [v19480];
    var ngEventDirectives = {};
    var forceAsyncEvents = {};
    forceAsyncEvents['blur'] = true;
    forceAsyncEvents['focus'] = true;
    const v19481 = 'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' ');
    const v19486 = function (eventName) {
        const v19482 = 'ng-' + eventName;
        var directiveName = directiveNormalize(v19482);
        const v19485 = function ($parse, $rootScope, $exceptionHandler) {
            const v19483 = forceAsyncEvents[eventName];
            const v19484 = createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, v19483);
            return v19484;
        };
        ngEventDirectives[directiveName] = [
            '$parse',
            '$rootScope',
            '$exceptionHandler',
            v19485
        ];
    };
    const v19487 = forEach(v19481, v19486);
    v19487;
    const createEventDirective = function ($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsync) {
        const v19500 = function ($element, attr) {
            const v19488 = attr[directiveName];
            var fn = $parse(v19488);
            const v19499 = function ngEventHandler(scope, element) {
                const v19497 = function (event) {
                    var callback = function () {
                        const v19489 = { $event: event };
                        const v19490 = fn(scope, v19489);
                        v19490;
                    };
                    const v19491 = $rootScope.$$phase;
                    const v19492 = !v19491;
                    if (v19492) {
                        const v19493 = scope.$apply(callback);
                        v19493;
                    } else {
                        if (forceAsync) {
                            const v19494 = scope.$evalAsync(callback);
                            v19494;
                        } else {
                            try {
                                const v19495 = callback();
                                v19495;
                            } catch (error) {
                                const v19496 = $exceptionHandler(error);
                                v19496;
                            }
                        }
                    }
                };
                const v19498 = element.on(eventName, v19497);
                v19498;
            };
            return v19499;
        };
        const v19501 = {};
        v19501.restrict = 'A';
        v19501.compile = v19500;
        return v19501;
    };
    const v19523 = function ($animate, $compile) {
        const v19521 = function ($scope, $element, $attr, ctrl, $transclude) {
            var block;
            var childScope;
            var previousElements;
            const v19502 = $attr.ngIf;
            const v19519 = function ngIfWatchAction(value) {
                if (value) {
                    const v19503 = !childScope;
                    if (v19503) {
                        const v19510 = function (clone, newScope) {
                            childScope = newScope;
                            const v19506 = $attr.ngIf;
                            const v19507 = $compile.$$createComment('end ngIf', v19506);
                            clone[v19505] = v19507;
                            block.clone = clone;
                            block = {};
                            block = {};
                            const v19508 = $element.parent();
                            const v19509 = $animate.enter(clone, v19508, $element);
                            v19509;
                        };
                        const v19511 = $transclude(v19510);
                        v19511;
                    }
                } else {
                    if (previousElements) {
                        const v19512 = previousElements.remove();
                        v19512;
                        previousElements = null;
                    }
                    if (childScope) {
                        const v19513 = childScope.$destroy();
                        v19513;
                        childScope = null;
                    }
                    if (block) {
                        const v19514 = block.clone;
                        previousElements = getBlockNodes(v19514);
                        const v19515 = $animate.leave(previousElements);
                        const v19517 = function (response) {
                            const v19516 = response !== false;
                            if (v19516) {
                                previousElements = null;
                            }
                        };
                        const v19518 = v19515.done(v19517);
                        v19518;
                        block = null;
                    }
                }
            };
            const v19520 = $scope.$watch(v19502, v19519);
            v19520;
        };
        const v19522 = {};
        v19522.multiElement = true;
        v19522.transclude = 'element';
        v19522.priority = 600;
        v19522.terminal = true;
        v19522.restrict = 'A';
        v19522.$$tlb = true;
        v19522.link = v19521;
        return v19522;
    };
    var ngIfDirective = [
        '$animate',
        '$compile',
        v19523
    ];
    const v19566 = function ($templateRequest, $anchorScroll, $animate) {
        const v19524 = angular.noop;
        const v19564 = function (element, attr) {
            const v19525 = attr.ngInclude;
            const v19526 = attr.src;
            var srcExp = v19525 || v19526;
            const v19527 = attr.onload;
            var onloadExp = v19527 || '';
            var autoScrollExp = attr.autoscroll;
            const v19563 = function (scope, $element, $attr, ctrl, $transclude) {
                var changeCounter = 0;
                var currentScope;
                var previousElement;
                var currentElement;
                var cleanupLastIncludeContent = function () {
                    if (previousElement) {
                        const v19528 = previousElement.remove();
                        v19528;
                        previousElement = null;
                    }
                    if (currentScope) {
                        const v19529 = currentScope.$destroy();
                        v19529;
                        currentScope = null;
                    }
                    if (currentElement) {
                        const v19530 = $animate.leave(currentElement);
                        const v19532 = function (response) {
                            const v19531 = response !== false;
                            if (v19531) {
                                previousElement = null;
                            }
                        };
                        const v19533 = v19530.done(v19532);
                        v19533;
                        previousElement = currentElement;
                        currentElement = null;
                    }
                };
                const v19561 = function ngIncludeWatchAction(src) {
                    var afterAnimation = function (response) {
                        const v19534 = response !== false;
                        const v19535 = isDefined(autoScrollExp);
                        const v19536 = v19534 && v19535;
                        const v19537 = !autoScrollExp;
                        const v19538 = scope.$eval(autoScrollExp);
                        const v19539 = v19537 || v19538;
                        const v19540 = v19536 && v19539;
                        if (v19540) {
                            const v19541 = $anchorScroll();
                            v19541;
                        }
                    };
                    const v19542 = ++changeCounter;
                    var thisChangeId = v19542;
                    if (src) {
                        const v19543 = $templateRequest(src, true);
                        const v19552 = function (response) {
                            const v19544 = scope.$$destroyed;
                            if (v19544) {
                                return;
                            }
                            const v19545 = thisChangeId !== changeCounter;
                            if (v19545) {
                                return;
                            }
                            var newScope = scope.$new();
                            ctrl.template = response;
                            const v19549 = function (clone) {
                                const v19546 = cleanupLastIncludeContent();
                                v19546;
                                const v19547 = $animate.enter(clone, null, $element);
                                const v19548 = v19547.done(afterAnimation);
                                v19548;
                            };
                            var clone = $transclude(newScope, v19549);
                            currentScope = newScope;
                            currentElement = clone;
                            const v19550 = currentScope.$emit('$includeContentLoaded', src);
                            v19550;
                            const v19551 = scope.$eval(onloadExp);
                            v19551;
                        };
                        const v19557 = function () {
                            const v19553 = scope.$$destroyed;
                            if (v19553) {
                                return;
                            }
                            const v19554 = thisChangeId === changeCounter;
                            if (v19554) {
                                const v19555 = cleanupLastIncludeContent();
                                v19555;
                                const v19556 = scope.$emit('$includeContentError', src);
                                v19556;
                            }
                        };
                        const v19558 = v19543.then(v19552, v19557);
                        v19558;
                        const v19559 = scope.$emit('$includeContentRequested', src);
                        v19559;
                    } else {
                        const v19560 = cleanupLastIncludeContent();
                        v19560;
                        ctrl.template = null;
                    }
                };
                const v19562 = scope.$watch(srcExp, v19561);
                v19562;
            };
            return v19563;
        };
        const v19565 = {};
        v19565.restrict = 'ECA';
        v19565.priority = 400;
        v19565.terminal = true;
        v19565.transclude = 'element';
        v19565.controller = v19524;
        v19565.compile = v19564;
        return v19565;
    };
    var ngIncludeDirective = [
        '$templateRequest',
        '$anchorScroll',
        '$animate',
        v19566
    ];
    const v19588 = function ($compile) {
        const v19567 = -400;
        const v19586 = function (scope, $element, $attr, ctrl) {
            const v19568 = $element[0];
            const v19569 = toString.call(v19568);
            const v19570 = v19569.match(/SVG/);
            if (v19570) {
                const v19571 = $element.empty();
                v19571;
                const v19572 = ctrl.template;
                const v19573 = window.document;
                const v19574 = jqLiteBuildFragment(v19572, v19573);
                const v19575 = v19574.childNodes;
                const v19576 = $compile(v19575);
                const v19578 = function namespaceAdaptedClone(clone) {
                    const v19577 = $element.append(clone);
                    v19577;
                };
                const v19579 = { futureParentElement: $element };
                const v19580 = v19576(scope, v19578, v19579);
                v19580;
                return;
            }
            const v19581 = ctrl.template;
            const v19582 = $element.html(v19581);
            v19582;
            const v19583 = $element.contents();
            const v19584 = $compile(v19583);
            const v19585 = v19584(scope);
            v19585;
        };
        const v19587 = {};
        v19587.restrict = 'ECA';
        v19587.priority = v19567;
        v19587.require = 'ngInclude';
        v19587.link = v19586;
        return v19587;
    };
    var ngIncludeFillContentDirective = [
        '$compile',
        v19588
    ];
    const v19593 = function () {
        const v19591 = function (scope, element, attrs) {
            const v19589 = attrs.ngInit;
            const v19590 = scope.$eval(v19589);
            v19590;
        };
        const v19592 = {};
        v19592.pre = v19591;
        return v19592;
    };
    const v19594 = {
        priority: 450,
        compile: v19593
    };
    var ngInitDirective = ngDirective(v19594);
    var ngListDirective = function () {
        const v19617 = function (scope, element, attr, ctrl) {
            const v19595 = attr.ngList;
            var ngList = v19595 || ', ';
            const v19596 = attr.ngTrim;
            var trimValues = v19596 !== 'false';
            let separator;
            const v19597 = trim(ngList);
            if (trimValues) {
                separator = v19597;
            } else {
                separator = ngList;
            }
            var parse = function (viewValue) {
                const v19598 = isUndefined(viewValue);
                if (v19598) {
                    return;
                }
                var list = [];
                if (viewValue) {
                    const v19599 = viewValue.split(separator);
                    const v19603 = function (value) {
                        if (value) {
                            const v19600 = trim(value);
                            let v19601;
                            if (trimValues) {
                                v19601 = v19600;
                            } else {
                                v19601 = value;
                            }
                            const v19602 = list.push(v19601);
                            v19602;
                        }
                    };
                    const v19604 = forEach(v19599, v19603);
                    v19604;
                }
                return list;
            };
            const v19605 = ctrl.$parsers;
            const v19606 = v19605.push(parse);
            v19606;
            const v19607 = ctrl.$formatters;
            const v19610 = function (value) {
                const v19608 = isArray(value);
                if (v19608) {
                    const v19609 = value.join(ngList);
                    return v19609;
                }
                return undefined;
            };
            const v19611 = v19607.push(v19610);
            v19611;
            const v19616 = function (value) {
                const v19612 = !value;
                const v19613 = value.length;
                const v19614 = !v19613;
                const v19615 = v19612 || v19614;
                return v19615;
            };
            ctrl.$isEmpty = v19616;
        };
        const v19618 = {};
        v19618.restrict = 'A';
        v19618.priority = 100;
        v19618.require = 'ngModel';
        v19618.link = v19617;
        return v19618;
    };
    var VALID_CLASS = 'ng-valid';
    var INVALID_CLASS = 'ng-invalid';
    var PRISTINE_CLASS = 'ng-pristine';
    var DIRTY_CLASS = 'ng-dirty';
    var UNTOUCHED_CLASS = 'ng-untouched';
    var TOUCHED_CLASS = 'ng-touched';
    var EMPTY_CLASS = 'ng-empty';
    var NOT_EMPTY_CLASS = 'ng-not-empty';
    var ngModelMinErr = minErr('ngModel');
    NgModelController.$inject = [
        '$scope',
        '$exceptionHandler',
        '$attrs',
        '$element',
        '$parse',
        '$animate',
        '$timeout',
        '$q',
        '$interpolate'
    ];
    const NgModelController = function ($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
        const v19619 = Number.NaN;
        this.$viewValue = v19619;
        const v19620 = Number.NaN;
        this.$modelValue = v19620;
        this.$$rawModelValue = undefined;
        const v19621 = {};
        this.$validators = v19621;
        const v19622 = {};
        this.$asyncValidators = v19622;
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        const v19623 = {};
        this.$error = v19623;
        const v19624 = {};
        this.$$success = v19624;
        this.$pending = undefined;
        const v19625 = $attr.name;
        const v19626 = v19625 || '';
        const v19627 = $interpolate(v19626, false);
        const v19628 = v19627($scope);
        this.$name = v19628;
        this.$$parentForm = nullFormCtrl;
        this.$options = defaultModelOptions;
        this.$$updateEvents = '';
        const v19629 = this.$$updateEventHandler;
        const v19630 = v19629.bind(this);
        this.$$updateEventHandler = v19630;
        const v19631 = $attr.ngModel;
        const v19632 = $parse(v19631);
        this.$$parsedNgModel = v19632;
        const v19633 = this.$$parsedNgModel;
        const v19634 = v19633.assign;
        this.$$parsedNgModelAssign = v19634;
        const v19635 = this.$$parsedNgModel;
        this.$$ngModelGet = v19635;
        const v19636 = this.$$parsedNgModelAssign;
        this.$$ngModelSet = v19636;
        this.$$pendingDebounce = null;
        this.$$parserValid = undefined;
        this.$$parserName = 'parse';
        this.$$currentValidationRunId = 0;
        this.$$scope = $scope;
        const v19637 = $scope.$root;
        this.$$rootScope = v19637;
        this.$$attr = $attr;
        this.$$element = $element;
        this.$$animate = $animate;
        this.$$timeout = $timeout;
        this.$$parse = $parse;
        this.$$q = $q;
        this.$$exceptionHandler = $exceptionHandler;
        const v19638 = setupValidity(this);
        v19638;
        const v19639 = setupModelWatcher(this);
        v19639;
    };
    const v19664 = function () {
        const v19640 = this.$options;
        const v19641 = v19640.getOption('getterSetter');
        if (v19641) {
            const v19642 = this.$$attr;
            const v19643 = v19642.ngModel;
            const v19644 = v19643 + '()';
            var invokeModelGetter = this.$$parse(v19644);
            const v19645 = this.$$attr;
            const v19646 = v19645.ngModel;
            const v19647 = v19646 + '($$$p)';
            var invokeModelSetter = this.$$parse(v19647);
            const v19649 = function ($scope) {
                var modelValue = this.$$parsedNgModel($scope);
                const v19648 = isFunction(modelValue);
                if (v19648) {
                    modelValue = invokeModelGetter($scope);
                }
                return modelValue;
            };
            this.$$ngModelGet = v19649;
            const v19655 = function ($scope, newValue) {
                const v19650 = this.$$parsedNgModel($scope);
                const v19651 = isFunction(v19650);
                if (v19651) {
                    const v19652 = { $$$p: newValue };
                    const v19653 = invokeModelSetter($scope, v19652);
                    v19653;
                } else {
                    const v19654 = this.$$parsedNgModelAssign($scope, newValue);
                    v19654;
                }
            };
            this.$$ngModelSet = v19655;
        } else {
            const v19656 = this.$$parsedNgModel;
            const v19657 = v19656.assign;
            const v19658 = !v19657;
            if (v19658) {
                const v19659 = this.$$attr;
                const v19660 = v19659.ngModel;
                const v19661 = this.$$element;
                const v19662 = startingTag(v19661);
                const v19663 = ngModelMinErr('nonassign', 'Expression \'{0}\' is non-assignable. Element: {1}', v19660, v19662);
                throw v19663;
            }
        }
    };
    const v19672 = function (value) {
        const v19665 = isUndefined(value);
        const v19666 = value === '';
        const v19667 = v19665 || v19666;
        const v19668 = value === null;
        const v19669 = v19667 || v19668;
        const v19670 = value !== value;
        const v19671 = v19669 || v19670;
        return v19671;
    };
    const v19686 = function (value) {
        const v19673 = this.$isEmpty(value);
        if (v19673) {
            const v19674 = this.$$animate;
            const v19675 = this.$$element;
            const v19676 = v19674.removeClass(v19675, NOT_EMPTY_CLASS);
            v19676;
            const v19677 = this.$$animate;
            const v19678 = this.$$element;
            const v19679 = v19677.addClass(v19678, EMPTY_CLASS);
            v19679;
        } else {
            const v19680 = this.$$animate;
            const v19681 = this.$$element;
            const v19682 = v19680.removeClass(v19681, EMPTY_CLASS);
            v19682;
            const v19683 = this.$$animate;
            const v19684 = this.$$element;
            const v19685 = v19683.addClass(v19684, NOT_EMPTY_CLASS);
            v19685;
        }
    };
    const v19693 = function () {
        this.$dirty = false;
        this.$pristine = true;
        const v19687 = this.$$animate;
        const v19688 = this.$$element;
        const v19689 = v19687.removeClass(v19688, DIRTY_CLASS);
        v19689;
        const v19690 = this.$$animate;
        const v19691 = this.$$element;
        const v19692 = v19690.addClass(v19691, PRISTINE_CLASS);
        v19692;
    };
    const v19702 = function () {
        this.$dirty = true;
        this.$pristine = false;
        const v19694 = this.$$animate;
        const v19695 = this.$$element;
        const v19696 = v19694.removeClass(v19695, PRISTINE_CLASS);
        v19696;
        const v19697 = this.$$animate;
        const v19698 = this.$$element;
        const v19699 = v19697.addClass(v19698, DIRTY_CLASS);
        v19699;
        const v19700 = this.$$parentForm;
        const v19701 = v19700.$setDirty();
        v19701;
    };
    const v19706 = function () {
        this.$touched = false;
        this.$untouched = true;
        const v19703 = this.$$animate;
        const v19704 = this.$$element;
        const v19705 = v19703.setClass(v19704, UNTOUCHED_CLASS, TOUCHED_CLASS);
        v19705;
    };
    const v19710 = function () {
        this.$touched = true;
        this.$untouched = false;
        const v19707 = this.$$animate;
        const v19708 = this.$$element;
        const v19709 = v19707.setClass(v19708, TOUCHED_CLASS, UNTOUCHED_CLASS);
        v19709;
    };
    const v19716 = function () {
        const v19711 = this.$$timeout;
        const v19712 = this.$$pendingDebounce;
        const v19713 = v19711.cancel(v19712);
        v19713;
        const v19714 = this.$$lastCommittedViewValue;
        this.$viewValue = v19714;
        const v19715 = this.$render();
        v19715;
    };
    const v19729 = function () {
        const v19717 = this.$modelValue;
        const v19718 = isNumberNaN(v19717);
        if (v19718) {
            return;
        }
        var viewValue = this.$$lastCommittedViewValue;
        var modelValue = this.$$rawModelValue;
        var prevValid = this.$valid;
        var prevModelValue = this.$modelValue;
        const v19719 = this.$options;
        var allowInvalid = v19719.getOption('allowInvalid');
        var that = this;
        const v19727 = function (allValid) {
            const v19720 = !allowInvalid;
            const v19721 = prevValid !== allValid;
            const v19722 = v19720 && v19721;
            if (v19722) {
                let v19723;
                if (allValid) {
                    v19723 = modelValue;
                } else {
                    v19723 = undefined;
                }
                that.$modelValue = v19723;
                const v19724 = that.$modelValue;
                const v19725 = v19724 !== prevModelValue;
                if (v19725) {
                    const v19726 = that.$$writeModelToScope();
                    v19726;
                }
            }
        };
        const v19728 = this.$$runValidators(modelValue, viewValue, v19727);
        v19728;
    };
    const v19792 = function (modelValue, viewValue, doneCallback) {
        const v19730 = this.$$currentValidationRunId;
        const v19731 = v19730++;
        v19731;
        var localValidationRunId = this.$$currentValidationRunId;
        var that = this;
        const v19732 = processParseErrors();
        const v19733 = !v19732;
        if (v19733) {
            const v19734 = validationDone(false);
            v19734;
            return;
        }
        const v19735 = processSyncValidators();
        const v19736 = !v19735;
        if (v19736) {
            const v19737 = validationDone(false);
            v19737;
            return;
        }
        const v19738 = processAsyncValidators();
        v19738;
        const processParseErrors = function () {
            var errorKey = that.$$parserName;
            const v19739 = that.$$parserValid;
            const v19740 = isUndefined(v19739);
            if (v19740) {
                const v19741 = setValidity(errorKey, null);
                v19741;
            } else {
                const v19742 = that.$$parserValid;
                const v19743 = !v19742;
                if (v19743) {
                    const v19744 = that.$validators;
                    const v19746 = function (v, name) {
                        const v19745 = setValidity(name, null);
                        v19745;
                    };
                    const v19747 = forEach(v19744, v19746);
                    v19747;
                    const v19748 = that.$asyncValidators;
                    const v19750 = function (v, name) {
                        const v19749 = setValidity(name, null);
                        v19749;
                    };
                    const v19751 = forEach(v19748, v19750);
                    v19751;
                }
                const v19752 = that.$$parserValid;
                const v19753 = setValidity(errorKey, v19752);
                v19753;
                const v19754 = that.$$parserValid;
                return v19754;
            }
            return true;
        };
        const processSyncValidators = function () {
            var syncValidatorsValid = true;
            const v19755 = that.$validators;
            const v19758 = function (validator, name) {
                const v19756 = validator(modelValue, viewValue);
                var result = Boolean(v19756);
                syncValidatorsValid = syncValidatorsValid && result;
                const v19757 = setValidity(name, result);
                v19757;
            };
            const v19759 = forEach(v19755, v19758);
            v19759;
            const v19760 = !syncValidatorsValid;
            if (v19760) {
                const v19761 = that.$asyncValidators;
                const v19763 = function (v, name) {
                    const v19762 = setValidity(name, null);
                    v19762;
                };
                const v19764 = forEach(v19761, v19763);
                v19764;
                return false;
            }
            return true;
        };
        const processAsyncValidators = function () {
            var validatorPromises = [];
            var allValid = true;
            const v19765 = that.$asyncValidators;
            const v19776 = function (validator, name) {
                var promise = validator(modelValue, viewValue);
                const v19766 = isPromiseLike(promise);
                const v19767 = !v19766;
                if (v19767) {
                    const v19768 = ngModelMinErr('nopromise', 'Expected asynchronous validator to return a promise but got \'{0}\' instead.', promise);
                    throw v19768;
                }
                const v19769 = setValidity(name, undefined);
                v19769;
                const v19771 = function () {
                    const v19770 = setValidity(name, true);
                    v19770;
                };
                const v19773 = function () {
                    allValid = false;
                    const v19772 = setValidity(name, false);
                    v19772;
                };
                const v19774 = promise.then(v19771, v19773);
                const v19775 = validatorPromises.push(v19774);
                v19775;
            };
            const v19777 = forEach(v19765, v19776);
            v19777;
            const v19778 = validatorPromises.length;
            const v19779 = !v19778;
            if (v19779) {
                const v19780 = validationDone(true);
                v19780;
            } else {
                const v19781 = that.$$q;
                const v19782 = v19781.all(validatorPromises);
                const v19784 = function () {
                    const v19783 = validationDone(allValid);
                    v19783;
                };
                const v19785 = v19782.then(v19784, noop);
                v19785;
            }
        };
        const setValidity = function (name, isValid) {
            const v19786 = that.$$currentValidationRunId;
            const v19787 = localValidationRunId === v19786;
            if (v19787) {
                const v19788 = that.$setValidity(name, isValid);
                v19788;
            }
        };
        const validationDone = function (allValid) {
            const v19789 = that.$$currentValidationRunId;
            const v19790 = localValidationRunId === v19789;
            if (v19790) {
                const v19791 = doneCallback(allValid);
                v19791;
            }
        };
    };
    const v19807 = function () {
        var viewValue = this.$viewValue;
        const v19793 = this.$$timeout;
        const v19794 = this.$$pendingDebounce;
        const v19795 = v19793.cancel(v19794);
        v19795;
        const v19796 = this.$$lastCommittedViewValue;
        const v19797 = v19796 === viewValue;
        const v19798 = viewValue !== '';
        const v19799 = this.$$hasNativeValidators;
        const v19800 = !v19799;
        const v19801 = v19798 || v19800;
        const v19802 = v19797 && v19801;
        if (v19802) {
            return;
        }
        const v19803 = this.$$updateEmptyClasses(viewValue);
        v19803;
        this.$$lastCommittedViewValue = viewValue;
        const v19804 = this.$pristine;
        if (v19804) {
            const v19805 = this.$setDirty();
            v19805;
        }
        const v19806 = this.$$parseAndValidate();
        v19806;
    };
    const v19834 = function () {
        var viewValue = this.$$lastCommittedViewValue;
        var modelValue = viewValue;
        var that = this;
        const v19808 = isUndefined(modelValue);
        let v19809;
        if (v19808) {
            v19809 = undefined;
        } else {
            v19809 = true;
        }
        this.$$parserValid = v19809;
        const v19810 = this.$$parserName;
        const v19811 = this.$setValidity(v19810, null);
        v19811;
        this.$$parserName = 'parse';
        const v19812 = this.$$parserValid;
        if (v19812) {
            var i = 0;
            const v19813 = this.$parsers;
            const v19814 = v19813.length;
            let v19815 = i < v19814;
            while (v19815) {
                const v19817 = this.$parsers;
                modelValue = v19817[i](modelValue);
                const v19818 = isUndefined(modelValue);
                if (v19818) {
                    this.$$parserValid = false;
                    break;
                }
                const v19816 = i++;
                v19815 = i < v19814;
            }
        }
        const v19819 = this.$modelValue;
        const v19820 = isNumberNaN(v19819);
        if (v19820) {
            const v19821 = this.$$scope;
            const v19822 = this.$$ngModelGet(v19821);
            this.$modelValue = v19822;
        }
        var prevModelValue = this.$modelValue;
        const v19823 = this.$options;
        var allowInvalid = v19823.getOption('allowInvalid');
        this.$$rawModelValue = modelValue;
        if (allowInvalid) {
            this.$modelValue = modelValue;
            const v19824 = writeToModelIfNeeded();
            v19824;
        }
        const v19825 = this.$$lastCommittedViewValue;
        const v19829 = function (allValid) {
            const v19826 = !allowInvalid;
            if (v19826) {
                let v19827;
                if (allValid) {
                    v19827 = modelValue;
                } else {
                    v19827 = undefined;
                }
                that.$modelValue = v19827;
                const v19828 = writeToModelIfNeeded();
                v19828;
            }
        };
        const v19830 = this.$$runValidators(modelValue, v19825, v19829);
        v19830;
        const writeToModelIfNeeded = function () {
            const v19831 = that.$modelValue;
            const v19832 = v19831 !== prevModelValue;
            if (v19832) {
                const v19833 = that.$$writeModelToScope();
                v19833;
            }
        };
    };
    const v19843 = function () {
        const v19835 = this.$$scope;
        const v19836 = this.$modelValue;
        const v19837 = this.$$ngModelSet(v19835, v19836);
        v19837;
        const v19838 = this.$viewChangeListeners;
        const v19841 = function (listener) {
            try {
                const v19839 = listener();
                v19839;
            } catch (e) {
                const v19840 = this.$$exceptionHandler(e);
                v19840;
            }
        };
        const v19842 = forEach(v19838, v19841, this);
        v19842;
    };
    const v19847 = function (value, trigger) {
        this.$viewValue = value;
        const v19844 = this.$options;
        const v19845 = v19844.getOption('updateOnDefault');
        if (v19845) {
            const v19846 = this.$$debounceViewValueCommit(trigger);
            v19846;
        }
    };
    const v19875 = function (trigger) {
        const v19848 = this.$options;
        var debounceDelay = v19848.getOption('debounce');
        const v19849 = debounceDelay[trigger];
        const v19850 = isNumber(v19849);
        if (v19850) {
            debounceDelay = debounceDelay[trigger];
        } else {
            const v19851 = debounceDelay['default'];
            const v19852 = isNumber(v19851);
            const v19853 = this.$options;
            const v19854 = v19853.getOption('updateOn');
            const v19855 = v19854.indexOf(trigger);
            const v19856 = -1;
            const v19857 = v19855 === v19856;
            const v19858 = v19852 && v19857;
            if (v19858) {
                debounceDelay = debounceDelay['default'];
            } else {
                const v19859 = debounceDelay['*'];
                const v19860 = isNumber(v19859);
                if (v19860) {
                    debounceDelay = debounceDelay['*'];
                }
            }
        }
        const v19861 = this.$$timeout;
        const v19862 = this.$$pendingDebounce;
        const v19863 = v19861.cancel(v19862);
        v19863;
        var that = this;
        const v19864 = debounceDelay > 0;
        if (v19864) {
            const v19866 = function () {
                const v19865 = that.$commitViewValue();
                v19865;
            };
            const v19867 = this.$$timeout(v19866, debounceDelay);
            this.$$pendingDebounce = v19867;
        } else {
            const v19868 = this.$$rootScope;
            const v19869 = v19868.$$phase;
            if (v19869) {
                const v19870 = this.$commitViewValue();
                v19870;
            } else {
                const v19871 = this.$$scope;
                const v19873 = function () {
                    const v19872 = that.$commitViewValue();
                    v19872;
                };
                const v19874 = v19871.$apply(v19873);
                v19874;
            }
        }
    };
    const v19879 = function (options) {
        const v19876 = this.$options;
        const v19877 = v19876.createChild(options);
        this.$options = v19877;
        const v19878 = this.$$setUpdateOnEvents();
        v19878;
    };
    const v19887 = function () {
        var viewValue = this.$$format();
        const v19880 = this.$viewValue;
        const v19881 = v19880 !== viewValue;
        if (v19881) {
            const v19882 = this.$$updateEmptyClasses(viewValue);
            v19882;
            this.$viewValue = this.$$lastCommittedViewValue = viewValue;
            const v19883 = this.$render();
            v19883;
            const v19884 = this.$modelValue;
            const v19885 = this.$viewValue;
            const v19886 = this.$$runValidators(v19884, v19885, noop);
            v19886;
        }
    };
    const v19889 = function () {
        var formatters = this.$formatters;
        var idx = formatters.length;
        var viewValue = this.$modelValue;
        let v19888 = idx--;
        while (v19888) {
            viewValue = formatters[idx](viewValue);
            v19888 = idx--;
        }
        return viewValue;
    };
    const v19891 = function (modelValue) {
        this.$modelValue = this.$$rawModelValue = modelValue;
        this.$$parserValid = undefined;
        const v19890 = this.$processModelValue();
        v19890;
    };
    const v19904 = function () {
        const v19892 = this.$$updateEvents;
        if (v19892) {
            const v19893 = this.$$element;
            const v19894 = this.$$updateEvents;
            const v19895 = this.$$updateEventHandler;
            const v19896 = v19893.off(v19894, v19895);
            v19896;
        }
        const v19897 = this.$options;
        const v19898 = v19897.getOption('updateOn');
        this.$$updateEvents = v19898;
        const v19899 = this.$$updateEvents;
        if (v19899) {
            const v19900 = this.$$element;
            const v19901 = this.$$updateEvents;
            const v19902 = this.$$updateEventHandler;
            const v19903 = v19900.on(v19901, v19902);
            v19903;
        }
    };
    const v19908 = function (ev) {
        const v19905 = ev.type;
        const v19906 = ev && v19905;
        const v19907 = this.$$debounceViewValueCommit(v19906);
        v19907;
    };
    const v19909 = {};
    v19909.$$initGetterSetters = v19664;
    v19909.$render = noop;
    v19909.$isEmpty = v19672;
    v19909.$$updateEmptyClasses = v19686;
    v19909.$setPristine = v19693;
    v19909.$setDirty = v19702;
    v19909.$setUntouched = v19706;
    v19909.$setTouched = v19710;
    v19909.$rollbackViewValue = v19716;
    v19909.$validate = v19729;
    v19909.$$runValidators = v19792;
    v19909.$commitViewValue = v19807;
    v19909.$$parseAndValidate = v19834;
    v19909.$$writeModelToScope = v19843;
    v19909.$setViewValue = v19847;
    v19909.$$debounceViewValueCommit = v19875;
    v19909.$overrideModelOptions = v19879;
    v19909.$processModelValue = v19887;
    v19909.$$format = v19889;
    v19909.$$setModelValue = v19891;
    v19909.$$setUpdateOnEvents = v19904;
    v19909.$$updateEventHandler = v19908;
    NgModelController.prototype = v19909;
    const setupModelWatcher = function (ctrl) {
        const v19910 = ctrl.$$scope;
        const v19920 = function ngModelWatch(scope) {
            var modelValue = ctrl.$$ngModelGet(scope);
            const v19911 = ctrl.$modelValue;
            const v19912 = modelValue !== v19911;
            const v19913 = ctrl.$modelValue;
            const v19914 = ctrl.$modelValue;
            const v19915 = v19913 === v19914;
            const v19916 = modelValue === modelValue;
            const v19917 = v19915 || v19916;
            const v19918 = v19912 && v19917;
            if (v19918) {
                const v19919 = ctrl.$$setModelValue(modelValue);
                v19919;
            }
            return modelValue;
        };
        const v19921 = v19910.$watch(v19920);
        v19921;
    };
    const v19922 = function (object, property) {
        object[property] = true;
    };
    const v19925 = function (object, property) {
        const v19923 = object[property];
        const v19924 = delete v19923;
        v19924;
    };
    const v19926 = {
        clazz: NgModelController,
        set: v19922,
        unset: v19925
    };
    const v19927 = addSetValidityMethod(v19926);
    v19927;
    const v19960 = function ($rootScope) {
        const v19928 = [
            'ngModel',
            '^?form',
            '^?ngModelOptions'
        ];
        const v19958 = function ngModelCompile(element) {
            const v19929 = element.addClass(PRISTINE_CLASS);
            const v19930 = v19929.addClass(UNTOUCHED_CLASS);
            const v19931 = v19930.addClass(VALID_CLASS);
            v19931;
            const v19947 = function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                const v19932 = ctrls[1];
                const v19933 = modelCtrl.$$parentForm;
                var formCtrl = v19932 || v19933;
                var optionsCtrl = ctrls[2];
                if (optionsCtrl) {
                    const v19934 = optionsCtrl.$options;
                    modelCtrl.$options = v19934;
                }
                const v19935 = modelCtrl.$$initGetterSetters();
                v19935;
                const v19936 = formCtrl.$addControl(modelCtrl);
                v19936;
                const v19941 = function (newValue) {
                    const v19937 = modelCtrl.$name;
                    const v19938 = v19937 !== newValue;
                    if (v19938) {
                        const v19939 = modelCtrl.$$parentForm;
                        const v19940 = v19939.$$renameControl(modelCtrl, newValue);
                        v19940;
                    }
                };
                const v19942 = attr.$observe('name', v19941);
                v19942;
                const v19945 = function () {
                    const v19943 = modelCtrl.$$parentForm;
                    const v19944 = v19943.$removeControl(modelCtrl);
                    v19944;
                };
                const v19946 = scope.$on('$destroy', v19945);
                v19946;
            };
            const v19956 = function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                const v19948 = modelCtrl.$$setUpdateOnEvents();
                v19948;
                const setTouched = function () {
                    const v19949 = modelCtrl.$setTouched();
                    v19949;
                };
                const v19954 = function () {
                    const v19950 = modelCtrl.$touched;
                    if (v19950) {
                        return;
                    }
                    const v19951 = $rootScope.$$phase;
                    if (v19951) {
                        const v19952 = scope.$evalAsync(setTouched);
                        v19952;
                    } else {
                        const v19953 = scope.$apply(setTouched);
                        v19953;
                    }
                };
                const v19955 = element.on('blur', v19954);
                v19955;
            };
            const v19957 = {};
            v19957.pre = v19947;
            v19957.post = v19956;
            return v19957;
        };
        const v19959 = {};
        v19959.restrict = 'A';
        v19959.require = v19928;
        v19959.controller = NgModelController;
        v19959.priority = 1;
        v19959.compile = v19958;
        return v19959;
    };
    var ngModelDirective = [
        '$rootScope',
        v19960
    ];
    var defaultModelOptions;
    var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    const ModelOptions = function (options) {
        this.$$options = options;
    };
    const v19963 = function (name) {
        const v19961 = this.$$options;
        const v19962 = v19961[name];
        return v19962;
    };
    const v19985 = function (options) {
        var inheritAll = false;
        const v19964 = {};
        options = extend(v19964, options);
        const v19976 = function (option, key) {
            const v19965 = option === '$inherit';
            if (v19965) {
                const v19966 = key === '*';
                if (v19966) {
                    inheritAll = true;
                } else {
                    const v19967 = this.$$options;
                    const v19968 = v19967[key];
                    options[key] = v19968;
                    const v19969 = key === 'updateOn';
                    if (v19969) {
                        const v19970 = this.$$options;
                        const v19971 = v19970.updateOnDefault;
                        options.updateOnDefault = v19971;
                    }
                }
            } else {
                const v19972 = key === 'updateOn';
                if (v19972) {
                    options.updateOnDefault = false;
                    const v19973 = function () {
                        options.updateOnDefault = true;
                        return ' ';
                    };
                    const v19974 = option.replace(DEFAULT_REGEXP, v19973);
                    const v19975 = trim(v19974);
                    options[key] = v19975;
                }
            }
        };
        const v19977 = forEach(options, v19976, this);
        v19977;
        if (inheritAll) {
            const v19978 = options['*'];
            const v19979 = delete v19978;
            v19979;
            const v19980 = this.$$options;
            const v19981 = defaults(options, v19980);
            v19981;
        }
        const v19982 = defaultModelOptions.$$options;
        const v19983 = defaults(options, v19982);
        v19983;
        const v19984 = new ModelOptions(options);
        return v19984;
    };
    const v19986 = {};
    v19986.getOption = v19963;
    v19986.createChild = v19985;
    ModelOptions.prototype = v19986;
    const v19987 = {
        updateOn: '',
        updateOnDefault: true,
        debounce: 0,
        getterSetter: false,
        allowInvalid: false,
        timezone: null
    };
    defaultModelOptions = new ModelOptions(v19987);
    var ngModelOptionsDirective = function () {
        NgModelOptionsController.$inject = [
            '$attrs',
            '$scope'
        ];
        const NgModelOptionsController = function ($attrs, $scope) {
            this.$$attrs = $attrs;
            this.$$scope = $scope;
        };
        const v19995 = function () {
            let parentOptions;
            const v19988 = this.parentCtrl;
            const v19989 = this.parentCtrl;
            const v19990 = v19989.$options;
            if (v19988) {
                parentOptions = v19990;
            } else {
                parentOptions = defaultModelOptions;
            }
            const v19991 = this.$$scope;
            const v19992 = this.$$attrs;
            const v19993 = v19992.ngModelOptions;
            var modelOptionsDefinition = v19991.$eval(v19993);
            const v19994 = parentOptions.createChild(modelOptionsDefinition);
            this.$options = v19994;
        };
        const v19996 = {};
        v19996.$onInit = v19995;
        NgModelOptionsController.prototype = v19996;
        const v19997 = {};
        v19997.parentCtrl = '?^^ngModelOptions';
        const v19998 = {};
        v19998.restrict = 'A';
        v19998.priority = 10;
        v19998.require = v19997;
        v19998.bindToController = true;
        v19998.controller = NgModelOptionsController;
        return v19998;
    };
    const defaults = function (dst, src) {
        const v20002 = function (value, key) {
            const v19999 = dst[key];
            const v20000 = isDefined(v19999);
            const v20001 = !v20000;
            if (v20001) {
                dst[key] = value;
            }
        };
        const v20003 = forEach(src, v20002);
        v20003;
    };
    const v20004 = {
        terminal: true,
        priority: 1000
    };
    var ngNonBindableDirective = ngDirective(v20004);
    var ngOptionsMinErr = minErr('ngOptions');
    var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
    const v20240 = function ($compile, $document, $parse) {
        const parseOptionsExpression = function (optionsExp, selectElement, scope) {
            var match = optionsExp.match(NG_OPTIONS_REGEXP);
            const v20005 = !match;
            if (v20005) {
                const v20006 = 'Expected expression in form of ' + '\'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'';
                const v20007 = v20006 + ' but got \'{0}\'. Element: {1}';
                const v20008 = startingTag(selectElement);
                const v20009 = ngOptionsMinErr('iexp', v20007, optionsExp, v20008);
                throw v20009;
            }
            const v20010 = match[5];
            const v20011 = match[7];
            var valueName = v20010 || v20011;
            var keyName = match[6];
            const v20012 = match[0];
            const v20013 = / as /.test(v20012);
            const v20014 = match[1];
            var selectAs = v20013 && v20014;
            var trackBy = match[9];
            const v20015 = match[2];
            const v20016 = match[1];
            let v20017;
            if (v20015) {
                v20017 = v20016;
            } else {
                v20017 = valueName;
            }
            var valueFn = $parse(v20017);
            const v20018 = $parse(selectAs);
            var selectAsFn = selectAs && v20018;
            var viewValueFn = selectAsFn || valueFn;
            const v20019 = $parse(trackBy);
            var trackByFn = trackBy && v20019;
            let getTrackByValueFn;
            const v20021 = function (value, locals) {
                const v20020 = trackByFn(scope, locals);
                return v20020;
            };
            const v20023 = function getHashOfValue(value) {
                const v20022 = hashKey(value);
                return v20022;
            };
            if (trackBy) {
                getTrackByValueFn = v20021;
            } else {
                getTrackByValueFn = v20023;
            }
            var getTrackByValue = function (value, key) {
                const v20024 = getLocals(value, key);
                const v20025 = getTrackByValueFn(value, v20024);
                return v20025;
            };
            const v20026 = match[2];
            const v20027 = match[1];
            const v20028 = v20026 || v20027;
            var displayFn = $parse(v20028);
            const v20029 = match[3];
            const v20030 = v20029 || '';
            var groupByFn = $parse(v20030);
            const v20031 = match[4];
            const v20032 = v20031 || '';
            var disableWhenFn = $parse(v20032);
            const v20033 = match[8];
            var valuesFn = $parse(v20033);
            var locals = {};
            let getLocals;
            const v20034 = function (value, key) {
                locals[keyName] = key;
                locals[valueName] = value;
                return locals;
            };
            const v20035 = function (value) {
                locals[valueName] = value;
                return locals;
            };
            if (keyName) {
                getLocals = v20034;
            } else {
                getLocals = v20035;
            }
            const Option = function (selectValue, viewValue, label, group, disabled) {
                this.selectValue = selectValue;
                this.viewValue = viewValue;
                this.label = label;
                this.group = group;
                this.disabled = disabled;
            };
            const getOptionValuesKeys = function (optionValues) {
                var optionValuesKeys;
                const v20036 = !keyName;
                const v20037 = isArrayLike(optionValues);
                const v20038 = v20036 && v20037;
                if (v20038) {
                    optionValuesKeys = optionValues;
                } else {
                    optionValuesKeys = [];
                    let itemKey;
                    for (itemKey in optionValues) {
                        const v20039 = optionValues.hasOwnProperty(itemKey);
                        const v20040 = itemKey.charAt(0);
                        const v20041 = v20040 !== '$';
                        const v20042 = v20039 && v20041;
                        if (v20042) {
                            const v20043 = optionValuesKeys.push(itemKey);
                            v20043;
                        }
                    }
                }
                return optionValuesKeys;
            };
            const v20056 = function (optionValues) {
                var watchedArray = [];
                const v20044 = [];
                optionValues = optionValues || v20044;
                var optionValuesKeys = getOptionValuesKeys(optionValues);
                var optionValuesLength = optionValuesKeys.length;
                var index = 0;
                let v20045 = index < optionValuesLength;
                while (v20045) {
                    let key;
                    const v20047 = optionValues === optionValuesKeys;
                    const v20048 = optionValuesKeys[index];
                    if (v20047) {
                        key = index;
                    } else {
                        key = v20048;
                    }
                    var value = optionValues[key];
                    var locals = getLocals(value, key);
                    var selectValue = getTrackByValueFn(value, locals);
                    const v20049 = watchedArray.push(selectValue);
                    v20049;
                    const v20050 = match[2];
                    const v20051 = match[1];
                    const v20052 = v20050 || v20051;
                    if (v20052) {
                        var label = displayFn(scope, locals);
                        const v20053 = watchedArray.push(label);
                        v20053;
                    }
                    const v20054 = match[4];
                    if (v20054) {
                        var disableWhen = disableWhenFn(scope, locals);
                        const v20055 = watchedArray.push(disableWhen);
                        v20055;
                    }
                    const v20046 = index++;
                    v20045 = index < optionValuesLength;
                }
                return watchedArray;
            };
            const v20057 = $parse(valuesFn, v20056);
            const v20074 = function () {
                var optionItems = [];
                var selectValueMap = {};
                const v20058 = valuesFn(scope);
                const v20059 = [];
                var optionValues = v20058 || v20059;
                var optionValuesKeys = getOptionValuesKeys(optionValues);
                var optionValuesLength = optionValuesKeys.length;
                var index = 0;
                let v20060 = index < optionValuesLength;
                while (v20060) {
                    let key;
                    const v20062 = optionValues === optionValuesKeys;
                    const v20063 = optionValuesKeys[index];
                    if (v20062) {
                        key = index;
                    } else {
                        key = v20063;
                    }
                    var value = optionValues[key];
                    var locals = getLocals(value, key);
                    var viewValue = viewValueFn(scope, locals);
                    var selectValue = getTrackByValueFn(viewValue, locals);
                    var label = displayFn(scope, locals);
                    var group = groupByFn(scope, locals);
                    var disabled = disableWhenFn(scope, locals);
                    var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                    const v20064 = optionItems.push(optionItem);
                    v20064;
                    selectValueMap[selectValue] = optionItem;
                    const v20061 = index++;
                    v20060 = index < optionValuesLength;
                }
                const v20067 = function (value) {
                    const v20065 = getTrackByValue(value);
                    const v20066 = selectValueMap[v20065];
                    return v20066;
                };
                const v20072 = function (option) {
                    const v20068 = option.viewValue;
                    const v20069 = copy(v20068);
                    const v20070 = option.viewValue;
                    let v20071;
                    if (trackBy) {
                        v20071 = v20069;
                    } else {
                        v20071 = v20070;
                    }
                    return v20071;
                };
                const v20073 = {};
                v20073.items = optionItems;
                v20073.selectValueMap = selectValueMap;
                v20073.getOptionFromViewValue = v20067;
                v20073.getViewValueFromOption = v20072;
                return v20073;
            };
            const v20075 = {};
            v20075.trackBy = trackBy;
            v20075.getTrackByValue = getTrackByValue;
            v20075.getWatchables = v20057;
            v20075.getOptions = v20074;
            return v20075;
        };
        const v20076 = window.document;
        var optionTemplate = v20076.createElement('option');
        const v20077 = window.document;
        var optGroupTemplate = v20077.createElement('optgroup');
        const ngOptionsPostLink = function (scope, selectElement, attr, ctrls) {
            var selectCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1];
            var multiple = attr.multiple;
            var i = 0;
            var children = selectElement.children();
            var ii = children.length;
            let v20078 = i < ii;
            while (v20078) {
                const v20080 = children[i];
                const v20081 = v20080.value;
                const v20082 = v20081 === '';
                if (v20082) {
                    selectCtrl.hasEmptyOption = true;
                    const v20083 = children.eq(i);
                    selectCtrl.emptyOption = v20083;
                    break;
                }
                const v20079 = i++;
                v20078 = i < ii;
            }
            const v20084 = selectElement.empty();
            v20084;
            const v20085 = selectCtrl.emptyOption;
            const v20086 = !v20085;
            const v20087 = !v20086;
            var providedEmptyOption = v20087;
            const v20088 = optionTemplate.cloneNode(false);
            var unknownOption = jqLite(v20088);
            const v20089 = unknownOption.val('?');
            v20089;
            var options;
            const v20090 = attr.ngOptions;
            var ngOptions = parseOptionsExpression(v20090, selectElement, scope);
            const v20091 = $document[0];
            var listFragment = v20091.createDocumentFragment();
            const v20092 = function (val) {
                return '?';
            };
            selectCtrl.generateUnknownOptionValue = v20092;
            const v20093 = !multiple;
            if (v20093) {
                const writeNgOptionsValue = function (value) {
                    const v20094 = !options;
                    if (v20094) {
                        return;
                    }
                    const v20095 = selectElement[0];
                    const v20096 = v20095.options;
                    const v20097 = selectElement[0];
                    const v20098 = v20097.selectedIndex;
                    var selectedOption = v20096[v20098];
                    var option = options.getOptionFromViewValue(value);
                    if (selectedOption) {
                        const v20099 = selectedOption.removeAttribute('selected');
                        v20099;
                    }
                    if (option) {
                        const v20100 = selectElement[0];
                        const v20101 = v20100.value;
                        const v20102 = option.selectValue;
                        const v20103 = v20101 !== v20102;
                        if (v20103) {
                            const v20104 = selectCtrl.removeUnknownOption();
                            v20104;
                            const v20105 = selectElement[0];
                            const v20106 = option.selectValue;
                            v20105.value = v20106;
                            const v20107 = option.element;
                            v20107.selected = true;
                        }
                        const v20108 = option.element;
                        const v20109 = v20108.setAttribute('selected', 'selected');
                        v20109;
                    } else {
                        const v20110 = selectCtrl.selectUnknownOrEmptyOption(value);
                        v20110;
                    }
                };
                selectCtrl.writeValue = writeNgOptionsValue;
                const readNgOptionsValue = function () {
                    const v20111 = options.selectValueMap;
                    const v20112 = selectElement.val();
                    var selectedOption = v20111[v20112];
                    const v20113 = selectedOption.disabled;
                    const v20114 = !v20113;
                    const v20115 = selectedOption && v20114;
                    if (v20115) {
                        const v20116 = selectCtrl.unselectEmptyOption();
                        v20116;
                        const v20117 = selectCtrl.removeUnknownOption();
                        v20117;
                        const v20118 = options.getViewValueFromOption(selectedOption);
                        return v20118;
                    }
                    return null;
                };
                selectCtrl.readValue = readNgOptionsValue;
                const v20119 = ngOptions.trackBy;
                if (v20119) {
                    const v20122 = function () {
                        const v20120 = ngModelCtrl.$viewValue;
                        const v20121 = ngOptions.getTrackByValue(v20120);
                        return v20121;
                    };
                    const v20124 = function () {
                        const v20123 = ngModelCtrl.$render();
                        v20123;
                    };
                    const v20125 = scope.$watch(v20122, v20124);
                    v20125;
                }
            } else {
                const writeNgOptionsMultiple = function (values) {
                    const v20126 = !options;
                    if (v20126) {
                        return;
                    }
                    const v20127 = values.map(getAndUpdateSelectedOption);
                    const v20128 = values && v20127;
                    const v20129 = [];
                    var selectedOptions = v20128 || v20129;
                    const v20130 = options.items;
                    const v20137 = function (option) {
                        const v20131 = option.element;
                        const v20132 = v20131.selected;
                        const v20133 = includes(selectedOptions, option);
                        const v20134 = !v20133;
                        const v20135 = v20132 && v20134;
                        if (v20135) {
                            const v20136 = option.element;
                            v20136.selected = false;
                        }
                    };
                    const v20138 = v20130.forEach(v20137);
                    v20138;
                };
                selectCtrl.writeValue = writeNgOptionsMultiple;
                const readNgOptionsMultiple = function () {
                    const v20139 = selectElement.val();
                    const v20140 = [];
                    var selectedValues = v20139 || v20140;
                    var selections = [];
                    const v20147 = function (value) {
                        const v20141 = options.selectValueMap;
                        var option = v20141[value];
                        const v20142 = option.disabled;
                        const v20143 = !v20142;
                        const v20144 = option && v20143;
                        if (v20144) {
                            const v20145 = options.getViewValueFromOption(option);
                            const v20146 = selections.push(v20145);
                            v20146;
                        }
                    };
                    const v20148 = forEach(selectedValues, v20147);
                    v20148;
                    return selections;
                };
                selectCtrl.readValue = readNgOptionsMultiple;
                const v20149 = ngOptions.trackBy;
                if (v20149) {
                    const v20156 = function () {
                        const v20150 = ngModelCtrl.$viewValue;
                        const v20151 = isArray(v20150);
                        if (v20151) {
                            const v20152 = ngModelCtrl.$viewValue;
                            const v20154 = function (value) {
                                const v20153 = ngOptions.getTrackByValue(value);
                                return v20153;
                            };
                            const v20155 = v20152.map(v20154);
                            return v20155;
                        }
                    };
                    const v20158 = function () {
                        const v20157 = ngModelCtrl.$render();
                        v20157;
                    };
                    const v20159 = scope.$watchCollection(v20156, v20158);
                    v20159;
                }
            }
            if (providedEmptyOption) {
                const v20160 = selectCtrl.emptyOption;
                const v20161 = $compile(v20160);
                const v20162 = v20161(scope);
                v20162;
                const v20163 = selectCtrl.emptyOption;
                const v20164 = selectElement.prepend(v20163);
                v20164;
                const v20165 = selectCtrl.emptyOption;
                const v20166 = v20165[0];
                const v20167 = v20166.nodeType;
                const v20168 = v20167 === NODE_TYPE_COMMENT;
                if (v20168) {
                    selectCtrl.hasEmptyOption = false;
                    const v20177 = function (optionScope, optionEl) {
                        const v20169 = optionEl.val();
                        const v20170 = v20169 === '';
                        if (v20170) {
                            selectCtrl.hasEmptyOption = true;
                            selectCtrl.emptyOption = optionEl;
                            const v20171 = selectCtrl.emptyOption;
                            const v20172 = v20171.removeClass('ng-scope');
                            v20172;
                            const v20173 = ngModelCtrl.$render();
                            v20173;
                            const v20175 = function () {
                                var needsRerender = selectCtrl.$isEmptyOptionSelected();
                                selectCtrl.hasEmptyOption = false;
                                selectCtrl.emptyOption = undefined;
                                if (needsRerender) {
                                    const v20174 = ngModelCtrl.$render();
                                    v20174;
                                }
                            };
                            const v20176 = optionEl.on('$destroy', v20175);
                            v20176;
                        }
                    };
                    selectCtrl.registerOption = v20177;
                } else {
                    const v20178 = selectCtrl.emptyOption;
                    const v20179 = v20178.removeClass('ng-scope');
                    v20179;
                }
            }
            const v20180 = ngOptions.getWatchables;
            const v20181 = scope.$watchCollection(v20180, updateOptions);
            v20181;
            const addOptionElement = function (option, parent) {
                var optionElement = optionTemplate.cloneNode(false);
                const v20182 = parent.appendChild(optionElement);
                v20182;
                const v20183 = updateOptionElement(option, optionElement);
                v20183;
            };
            const getAndUpdateSelectedOption = function (viewValue) {
                var option = options.getOptionFromViewValue(viewValue);
                const v20184 = option.element;
                var element = option && v20184;
                const v20185 = element.selected;
                const v20186 = !v20185;
                const v20187 = element && v20186;
                if (v20187) {
                    element.selected = true;
                }
                return option;
            };
            const updateOptionElement = function (option, element) {
                option.element = element;
                const v20188 = option.disabled;
                element.disabled = v20188;
                const v20189 = option.label;
                const v20190 = element.label;
                const v20191 = v20189 !== v20190;
                if (v20191) {
                    const v20192 = option.label;
                    element.label = v20192;
                    const v20193 = option.label;
                    element.textContent = v20193;
                }
                const v20194 = option.selectValue;
                element.value = v20194;
            };
            const updateOptions = function () {
                const v20195 = selectCtrl.readValue();
                var previousValue = options && v20195;
                if (options) {
                    const v20196 = options.items;
                    const v20197 = v20196.length;
                    var i = v20197 - 1;
                    let v20198 = i >= 0;
                    while (v20198) {
                        const v20200 = options.items;
                        var option = v20200[i];
                        const v20201 = option.group;
                        const v20202 = isDefined(v20201);
                        if (v20202) {
                            const v20203 = option.element;
                            const v20204 = v20203.parentNode;
                            const v20205 = jqLiteRemove(v20204);
                            v20205;
                        } else {
                            const v20206 = option.element;
                            const v20207 = jqLiteRemove(v20206);
                            v20207;
                        }
                        const v20199 = i--;
                        v20198 = i >= 0;
                    }
                }
                options = ngOptions.getOptions();
                var groupElementMap = {};
                const v20208 = options.items;
                const v20221 = function addOption(option) {
                    var groupElement;
                    const v20209 = option.group;
                    const v20210 = isDefined(v20209);
                    if (v20210) {
                        const v20211 = option.group;
                        groupElement = groupElementMap[v20211];
                        const v20212 = !groupElement;
                        if (v20212) {
                            groupElement = optGroupTemplate.cloneNode(false);
                            const v20213 = listFragment.appendChild(groupElement);
                            v20213;
                            const v20214 = option.group;
                            const v20215 = v20214 === null;
                            const v20216 = option.group;
                            let v20217;
                            if (v20215) {
                                v20217 = 'null';
                            } else {
                                v20217 = v20216;
                            }
                            groupElement.label = v20217;
                            const v20218 = option.group;
                            groupElementMap[v20218] = groupElement;
                        }
                        const v20219 = addOptionElement(option, groupElement);
                        v20219;
                    } else {
                        const v20220 = addOptionElement(option, listFragment);
                        v20220;
                    }
                };
                const v20222 = v20208.forEach(v20221);
                v20222;
                const v20223 = selectElement[0];
                const v20224 = v20223.appendChild(listFragment);
                v20224;
                const v20225 = ngModelCtrl.$render();
                v20225;
                const v20226 = ngModelCtrl.$isEmpty(previousValue);
                const v20227 = !v20226;
                if (v20227) {
                    var nextValue = selectCtrl.readValue();
                    const v20228 = ngOptions.trackBy;
                    var isNotPrimitive = v20228 || multiple;
                    const v20229 = equals(previousValue, nextValue);
                    const v20230 = !v20229;
                    const v20231 = previousValue !== nextValue;
                    let v20232;
                    if (isNotPrimitive) {
                        v20232 = v20230;
                    } else {
                        v20232 = v20231;
                    }
                    if (v20232) {
                        const v20233 = ngModelCtrl.$setViewValue(nextValue);
                        v20233;
                        const v20234 = ngModelCtrl.$render();
                        v20234;
                    }
                }
            };
        };
        const v20235 = [
            'select',
            'ngModel'
        ];
        const v20237 = function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
            const v20236 = ctrls[0];
            v20236.registerOption = noop;
        };
        const v20238 = {};
        v20238.pre = v20237;
        v20238.post = ngOptionsPostLink;
        const v20239 = {};
        v20239.restrict = 'A';
        v20239.terminal = true;
        v20239.require = v20235;
        v20239.link = v20238;
        return v20239;
    };
    var ngOptionsDirective = [
        '$compile',
        '$document',
        '$parse',
        v20240
    ];
    const v20289 = function ($locale, $interpolate, $log) {
        var BRACE = /{}/g;
        var IS_WHEN = /^when(Minus)?(.+)$/;
        const v20287 = function (scope, element, attr) {
            var numberExp = attr.count;
            const v20241 = attr.$attr;
            const v20242 = v20241.when;
            const v20243 = attr.$attr;
            const v20244 = v20243.when;
            const v20245 = element.attr(v20244);
            var whenExp = v20242 && v20245;
            const v20246 = attr.offset;
            var offset = v20246 || 0;
            const v20247 = scope.$eval(whenExp);
            const v20248 = {};
            var whens = v20247 || v20248;
            var whensExpFns = {};
            var startSymbol = $interpolate.startSymbol();
            var endSymbol = $interpolate.endSymbol();
            const v20249 = startSymbol + numberExp;
            const v20250 = v20249 + '-';
            const v20251 = v20250 + offset;
            var braceReplacement = v20251 + endSymbol;
            var watchRemover = angular.noop;
            var lastCount;
            const v20259 = function (expression, attributeName) {
                var tmpMatch = IS_WHEN.exec(attributeName);
                if (tmpMatch) {
                    const v20252 = tmpMatch[1];
                    let v20253;
                    if (v20252) {
                        v20253 = '-';
                    } else {
                        v20253 = '';
                    }
                    const v20254 = tmpMatch[2];
                    const v20255 = lowercase(v20254);
                    var whenKey = v20253 + v20255;
                    const v20256 = attr.$attr;
                    const v20257 = v20256[attributeName];
                    const v20258 = element.attr(v20257);
                    whens[whenKey] = v20258;
                }
            };
            const v20260 = forEach(attr, v20259);
            v20260;
            const v20263 = function (expression, key) {
                const v20261 = expression.replace(BRACE, braceReplacement);
                const v20262 = $interpolate(v20261);
                whensExpFns[key] = v20262;
            };
            const v20264 = forEach(whens, v20263);
            v20264;
            const v20283 = function ngPluralizeWatchAction(newVal) {
                var count = parseFloat(newVal);
                var countIsNaN = isNumberNaN(count);
                const v20265 = !countIsNaN;
                const v20266 = count in whens;
                const v20267 = !v20266;
                const v20268 = v20265 && v20267;
                if (v20268) {
                    const v20269 = count - offset;
                    count = $locale.pluralCat(v20269);
                }
                const v20270 = count !== lastCount;
                const v20271 = isNumberNaN(lastCount);
                const v20272 = countIsNaN && v20271;
                const v20273 = !v20272;
                const v20274 = v20270 && v20273;
                if (v20274) {
                    const v20275 = watchRemover();
                    v20275;
                    var whenExpFn = whensExpFns[count];
                    const v20276 = isUndefined(whenExpFn);
                    if (v20276) {
                        const v20277 = newVal != null;
                        if (v20277) {
                            const v20278 = 'ngPluralize: no rule defined for \'' + count;
                            const v20279 = v20278 + '\' in ';
                            const v20280 = v20279 + whenExp;
                            const v20281 = $log.debug(v20280);
                            v20281;
                        }
                        watchRemover = noop;
                        const v20282 = updateElementText();
                        v20282;
                    } else {
                        watchRemover = scope.$watch(whenExpFn, updateElementText);
                    }
                    lastCount = count;
                }
            };
            const v20284 = scope.$watch(numberExp, v20283);
            v20284;
            const updateElementText = function (newText) {
                const v20285 = newText || '';
                const v20286 = element.text(v20285);
                v20286;
            };
        };
        const v20288 = {};
        v20288.link = v20287;
        return v20288;
    };
    var ngPluralizeDirective = [
        '$locale',
        '$interpolate',
        '$log',
        v20289
    ];
    var ngRefMinErr = minErr('ngRef');
    const v20318 = function ($parse) {
        const v20290 = -1;
        const v20316 = function (tElement, tAttrs) {
            const v20291 = nodeName_(tElement);
            var controllerName = directiveNormalize(v20291);
            const v20292 = tAttrs.ngRef;
            var getter = $parse(v20292);
            const v20293 = getter.assign;
            const v20296 = function () {
                const v20294 = tAttrs.ngRef;
                const v20295 = ngRefMinErr('nonassign', 'Expression in ngRef="{0}" is non-assignable!', v20294);
                throw v20295;
            };
            var setter = v20293 || v20296;
            const v20315 = function (scope, element, attrs) {
                var refValue;
                const v20297 = attrs.hasOwnProperty('ngRefRead');
                if (v20297) {
                    const v20298 = attrs.ngRefRead;
                    const v20299 = v20298 === '$element';
                    if (v20299) {
                        refValue = element;
                    } else {
                        const v20300 = attrs.ngRefRead;
                        const v20301 = '$' + v20300;
                        const v20302 = v20301 + 'Controller';
                        refValue = element.data(v20302);
                        const v20303 = !refValue;
                        if (v20303) {
                            const v20304 = attrs.ngRefRead;
                            const v20305 = tAttrs.ngRef;
                            const v20306 = ngRefMinErr('noctrl', 'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"', v20304, v20305);
                            throw v20306;
                        }
                    }
                } else {
                    const v20307 = '$' + controllerName;
                    const v20308 = v20307 + 'Controller';
                    refValue = element.data(v20308);
                }
                refValue = refValue || element;
                const v20309 = setter(scope, refValue);
                v20309;
                const v20313 = function () {
                    const v20310 = getter(scope);
                    const v20311 = v20310 === refValue;
                    if (v20311) {
                        const v20312 = setter(scope, null);
                        v20312;
                    }
                };
                const v20314 = element.on('$destroy', v20313);
                v20314;
            };
            return v20315;
        };
        const v20317 = {};
        v20317.priority = v20290;
        v20317.restrict = 'A';
        v20317.compile = v20316;
        return v20317;
    };
    var ngRefDirective = [
        '$parse',
        v20318
    ];
    const v20405 = function ($parse, $animate, $compile) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function (scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value;
            if (keyIdentifier) {
                scope[keyIdentifier] = key;
            }
            scope.$index = index;
            scope.$first = index === 0;
            const v20319 = arrayLength - 1;
            scope.$last = index === v20319;
            const v20320 = scope.$first;
            const v20321 = scope.$last;
            const v20322 = v20320 || v20321;
            const v20323 = !v20322;
            scope.$middle = v20323;
            const v20324 = index & 1;
            const v20325 = !(scope.$even = v20324 === 0);
            scope.$odd = v20325;
        };
        var getBlockStart = function (block) {
            const v20326 = block.clone;
            const v20327 = v20326[0];
            return v20327;
        };
        var getBlockEnd = function (block) {
            const v20328 = block.clone;
            const v20329 = block.clone;
            const v20330 = v20329.length;
            const v20331 = v20330 - 1;
            const v20332 = v20328[v20331];
            return v20332;
        };
        var trackByIdArrayFn = function ($scope, key, value) {
            const v20333 = hashKey(value);
            return v20333;
        };
        var trackByIdObjFn = function ($scope, key) {
            return key;
        };
        const v20403 = function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            const v20334 = !match;
            if (v20334) {
                const v20335 = ngRepeatMinErr('iexp', 'Expected expression in form of \'_item_ in _collection_[ track by _id_]\' but got \'{0}\'.', expression);
                throw v20335;
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);
            const v20336 = !match;
            if (v20336) {
                const v20337 = ngRepeatMinErr('iidexp', '\'_item_\' in \'_item_ in _collection_\' should be an identifier or \'(_key_, _value_)\' expression, but got \'{0}\'.', lhs);
                throw v20337;
            }
            const v20338 = match[3];
            const v20339 = match[1];
            var valueIdentifier = v20338 || v20339;
            var keyIdentifier = match[2];
            const v20340 = /^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs);
            const v20341 = !v20340;
            const v20342 = /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs);
            const v20343 = v20341 || v20342;
            const v20344 = aliasAs && v20343;
            if (v20344) {
                const v20345 = ngRepeatMinErr('badident', 'alias \'{0}\' is invalid --- must be a valid JS identifier which is not a reserved name.', aliasAs);
                throw v20345;
            }
            var trackByIdExpFn;
            if (trackByExp) {
                var hashFnLocals = {};
                hashFnLocals.$id = hashKey;
                var trackByExpGetter = $parse(trackByExp);
                const v20347 = function ($scope, key, value, index) {
                    if (keyIdentifier) {
                        hashFnLocals[keyIdentifier] = key;
                    }
                    hashFnLocals[valueIdentifier] = value;
                    hashFnLocals.$index = index;
                    const v20346 = trackByExpGetter($scope, hashFnLocals);
                    return v20346;
                };
                trackByIdExpFn = v20347;
            }
            const v20402 = function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                var lastBlockMap = createMap();
                const v20400 = function ngRepeatAction(collection) {
                    var index;
                    var length;
                    var previousNode = $element[0];
                    var nextNode;
                    var nextBlockMap = createMap();
                    var collectionLength;
                    var key;
                    var value;
                    var trackById;
                    var trackByIdFn;
                    var collectionKeys;
                    var block;
                    var nextBlockOrder;
                    var elementsToRemove;
                    if (aliasAs) {
                        $scope[aliasAs] = collection;
                    }
                    const v20348 = isArrayLike(collection);
                    if (v20348) {
                        collectionKeys = collection;
                        trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                    } else {
                        trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                        collectionKeys = [];
                        let itemKey;
                        for (itemKey in collection) {
                            const v20349 = hasOwnProperty.call(collection, itemKey);
                            const v20350 = itemKey.charAt(0);
                            const v20351 = v20350 !== '$';
                            const v20352 = v20349 && v20351;
                            if (v20352) {
                                const v20353 = collectionKeys.push(itemKey);
                                v20353;
                            }
                        }
                    }
                    collectionLength = collectionKeys.length;
                    nextBlockOrder = new Array(collectionLength);
                    (index = 0)
                    let v20354 = index < collectionLength;
                    while (v20354) {
                        const v20356 = collection === collectionKeys;
                        const v20357 = collectionKeys[index];
                        if (v20356) {
                            key = index;
                        } else {
                            key = v20357;
                        }
                        value = collection[key];
                        trackById = trackByIdFn($scope, key, value, index);
                        const v20358 = lastBlockMap[trackById];
                        if (v20358) {
                            block = lastBlockMap[trackById];
                            const v20359 = lastBlockMap[trackById];
                            const v20360 = delete v20359;
                            v20360;
                            nextBlockMap[trackById] = block;
                            nextBlockOrder[index] = block;
                        } else {
                            const v20361 = nextBlockMap[trackById];
                            if (v20361) {
                                const v20365 = function (block) {
                                    const v20362 = block.scope;
                                    const v20363 = block && v20362;
                                    if (v20363) {
                                        const v20364 = block.id;
                                        lastBlockMap[v20364] = block;
                                    }
                                };
                                const v20366 = forEach(nextBlockOrder, v20365);
                                v20366;
                                const v20367 = ngRepeatMinErr('dupes', 'Duplicates in a repeater are not allowed. Use \'track by\' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}', expression, trackById, value);
                                throw v20367;
                            } else {
                                const v20368 = {};
                                v20368.id = trackById;
                                v20368.scope = undefined;
                                v20368.clone = undefined;
                                nextBlockOrder[index] = v20368;
                                nextBlockMap[trackById] = true;
                            }
                        }
                        const v20355 = index++;
                        v20354 = index < collectionLength;
                    }
                    if (hashFnLocals) {
                        hashFnLocals[valueIdentifier] = undefined;
                    }
                    let blockKey;
                    for (blockKey in lastBlockMap) {
                        block = lastBlockMap[blockKey];
                        const v20369 = block.clone;
                        elementsToRemove = getBlockNodes(v20369);
                        const v20370 = $animate.leave(elementsToRemove);
                        v20370;
                        const v20371 = elementsToRemove[0];
                        const v20372 = v20371.parentNode;
                        if (v20372) {
                            (index = 0, length = elementsToRemove.length)
                            let v20373 = index < length;
                            while (v20373) {
                                const v20375 = elementsToRemove[index];
                                v20375[NG_REMOVED] = true;
                                const v20374 = index++;
                                v20373 = index < length;
                            }
                        }
                        const v20376 = block.scope;
                        const v20377 = v20376.$destroy();
                        v20377;
                    }
                    (index = 0)
                    let v20378 = index < collectionLength;
                    while (v20378) {
                        const v20380 = collection === collectionKeys;
                        const v20381 = collectionKeys[index];
                        if (v20380) {
                            key = index;
                        } else {
                            key = v20381;
                        }
                        value = collection[key];
                        block = nextBlockOrder[index];
                        const v20382 = block.scope;
                        if (v20382) {
                            nextNode = previousNode;
                            let v20384 = true;
                            while (v20384) {
                                nextNode = nextNode.nextSibling;
                                v20384 = nextNode && v20383;
                            }
                            const v20385 = getBlockStart(block);
                            const v20386 = v20385 !== nextNode;
                            if (v20386) {
                                const v20387 = block.clone;
                                const v20388 = getBlockNodes(v20387);
                                const v20389 = $animate.move(v20388, null, previousNode);
                                v20389;
                            }
                            previousNode = getBlockEnd(block);
                            const v20390 = block.scope;
                            const v20391 = updateScope(v20390, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                            v20391;
                        } else {
                            const v20398 = function ngRepeatTransclude(clone, scope) {
                                block.scope = scope;
                                var endNode = ngRepeatEndComment.cloneNode(false);
                                const v20392 = clone.length;
                                const v20393 = v20392++;
                                clone[v20393] = endNode;
                                const v20394 = $animate.enter(clone, null, previousNode);
                                v20394;
                                previousNode = endNode;
                                block.clone = clone;
                                const v20395 = block.id;
                                nextBlockMap[v20395] = block;
                                const v20396 = block.scope;
                                const v20397 = updateScope(v20396, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                v20397;
                            };
                            const v20399 = $transclude(v20398);
                            v20399;
                        }
                        const v20379 = index++;
                        v20378 = index < collectionLength;
                    }
                    lastBlockMap = nextBlockMap;
                };
                const v20401 = $scope.$watchCollection(rhs, v20400);
                v20401;
            };
            return v20402;
        };
        const v20404 = {};
        v20404.restrict = 'A';
        v20404.multiElement = true;
        v20404.transclude = 'element';
        v20404.priority = 1000;
        v20404.terminal = true;
        v20404.$$tlb = true;
        v20404.compile = v20403;
        return v20404;
    };
    var ngRepeatDirective = [
        '$parse',
        '$animate',
        '$compile',
        v20405
    ];
    var NG_HIDE_CLASS = 'ng-hide';
    var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
    const v20414 = function ($animate) {
        const v20412 = function (scope, element, attr) {
            const v20406 = attr.ngShow;
            const v20410 = function ngShowWatchAction(value) {
                let v20407;
                if (value) {
                    v20407 = 'removeClass';
                } else {
                    v20407 = 'addClass';
                }
                const v20408 = { tempClasses: NG_HIDE_IN_PROGRESS_CLASS };
                const v20409 = $animate[v20407](element, NG_HIDE_CLASS, v20408);
                v20409;
            };
            const v20411 = scope.$watch(v20406, v20410);
            v20411;
        };
        const v20413 = {};
        v20413.restrict = 'A';
        v20413.multiElement = true;
        v20413.link = v20412;
        return v20413;
    };
    var ngShowDirective = [
        '$animate',
        v20414
    ];
    const v20423 = function ($animate) {
        const v20421 = function (scope, element, attr) {
            const v20415 = attr.ngHide;
            const v20419 = function ngHideWatchAction(value) {
                let v20416;
                if (value) {
                    v20416 = 'addClass';
                } else {
                    v20416 = 'removeClass';
                }
                const v20417 = { tempClasses: NG_HIDE_IN_PROGRESS_CLASS };
                const v20418 = $animate[v20416](element, NG_HIDE_CLASS, v20417);
                v20418;
            };
            const v20420 = scope.$watch(v20415, v20419);
            v20420;
        };
        const v20422 = {};
        v20422.restrict = 'A';
        v20422.multiElement = true;
        v20422.link = v20421;
        return v20422;
    };
    var ngHideDirective = [
        '$animate',
        v20423
    ];
    const v20435 = function (scope, element, attr) {
        const v20424 = attr.ngStyle;
        const v20433 = function ngStyleWatchAction(newStyles, oldStyles) {
            const v20425 = newStyles !== oldStyles;
            const v20426 = oldStyles && v20425;
            if (v20426) {
                const v20427 = !newStyles;
                if (v20427) {
                    newStyles = {};
                }
                const v20430 = function (val, style) {
                    const v20428 = newStyles[style];
                    const v20429 = v20428 == null;
                    if (v20429) {
                        newStyles[style] = '';
                    }
                };
                const v20431 = forEach(oldStyles, v20430);
                v20431;
            }
            if (newStyles) {
                const v20432 = element.css(newStyles);
                v20432;
            }
        };
        const v20434 = scope.$watchCollection(v20424, v20433);
        v20434;
    };
    var ngStyleDirective = ngDirective(v20435);
    const v20476 = function ($animate, $compile) {
        const v20437 = function NgSwitchController() {
            const v20436 = {};
            this.cases = v20436;
        };
        const v20438 = [
            '$scope',
            v20437
        ];
        const v20474 = function (scope, element, attr, ngSwitchController) {
            const v20439 = attr.ngSwitch;
            const v20440 = attr.on;
            var watchExpr = v20439 || v20440;
            var selectedTranscludes = [];
            var selectedElements = [];
            var previousLeaveAnimations = [];
            var selectedScopes = [];
            var spliceFactory = function (array, index) {
                const v20443 = function (response) {
                    const v20441 = response !== false;
                    if (v20441) {
                        const v20442 = array.splice(index, 1);
                        v20442;
                    }
                };
                return v20443;
            };
            const v20472 = function ngSwitchWatchAction(value) {
                var i;
                var ii;
                let v20444 = previousLeaveAnimations.length;
                while (v20444) {
                    const v20445 = previousLeaveAnimations.pop();
                    const v20446 = $animate.cancel(v20445);
                    v20446;
                    v20444 = previousLeaveAnimations.length;
                }
                (i = 0, ii = selectedScopes.length)
                let v20447 = i < ii;
                while (v20447) {
                    const v20449 = selectedElements[i];
                    const v20450 = v20449.clone;
                    var selected = getBlockNodes(v20450);
                    const v20451 = selectedScopes[i];
                    const v20452 = v20451.$destroy();
                    v20452;
                    const v20453 = $animate.leave(selected);
                    previousLeaveAnimations[i] = v20453;
                    var runner = previousLeaveAnimations[i];
                    const v20454 = spliceFactory(previousLeaveAnimations, i);
                    const v20455 = runner.done(v20454);
                    v20455;
                    const v20448 = ++i;
                    v20447 = i < ii;
                }
                selectedElements.length = 0;
                selectedScopes.length = 0;
                const v20456 = ngSwitchController.cases;
                const v20457 = '!' + value;
                const v20458 = v20456[v20457];
                const v20459 = ngSwitchController.cases;
                const v20460 = v20459['?'];
                if (selectedTranscludes = v20458 || v20460) {
                    const v20470 = function (selectedTransclude) {
                        const v20468 = function (caseElement, selectedScope) {
                            const v20461 = selectedScopes.push(selectedScope);
                            v20461;
                            var anchor = selectedTransclude.element;
                            const v20464 = $compile.$$createComment('end ngSwitchWhen');
                            caseElement[v20463] = v20464;
                            var block = {};
                            block.clone = caseElement;
                            const v20465 = selectedElements.push(block);
                            v20465;
                            const v20466 = anchor.parent();
                            const v20467 = $animate.enter(caseElement, v20466, anchor);
                            v20467;
                        };
                        const v20469 = selectedTransclude.transclude(v20468);
                        v20469;
                    };
                    const v20471 = forEach(selectedTranscludes, v20470);
                    v20471;
                }
            };
            const v20473 = scope.$watch(watchExpr, v20472);
            v20473;
        };
        const v20475 = {};
        v20475.require = 'ngSwitch';
        v20475.controller = v20438;
        v20475.link = v20474;
        return v20475;
    };
    var ngSwitchDirective = [
        '$animate',
        '$compile',
        v20476
    ];
    const v20498 = function (scope, element, attrs, ctrl, $transclude) {
        const v20477 = attrs.ngSwitchWhen;
        const v20478 = attrs.ngSwitchWhenSeparator;
        const v20479 = v20477.split(v20478);
        const v20480 = v20479.sort();
        const v20484 = function (element, index, array) {
            const v20481 = index - 1;
            const v20482 = array[v20481];
            const v20483 = v20482 !== element;
            return v20483;
        };
        var cases = v20480.filter(v20484);
        const v20496 = function (whenCase) {
            const v20485 = ctrl.cases;
            const v20486 = '!' + whenCase;
            const v20487 = ctrl.cases;
            const v20488 = '!' + whenCase;
            const v20489 = v20487[v20488];
            const v20490 = [];
            v20485[v20486] = v20489 || v20490;
            const v20491 = ctrl.cases;
            const v20492 = '!' + whenCase;
            const v20493 = v20491[v20492];
            const v20494 = {
                transclude: $transclude,
                element: element
            };
            const v20495 = v20493.push(v20494);
            v20495;
        };
        const v20497 = forEach(cases, v20496);
        v20497;
    };
    const v20499 = {
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: v20498
    };
    var ngSwitchWhenDirective = ngDirective(v20499);
    const v20508 = function (scope, element, attr, ctrl, $transclude) {
        const v20500 = ctrl.cases;
        const v20501 = ctrl.cases;
        const v20502 = v20501['?'];
        const v20503 = [];
        v20500['?'] = v20502 || v20503;
        const v20504 = ctrl.cases;
        const v20505 = v20504['?'];
        const v20506 = {
            transclude: $transclude,
            element: element
        };
        const v20507 = v20505.push(v20506);
        v20507;
    };
    const v20509 = {
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: v20508
    };
    var ngSwitchDefaultDirective = ngDirective(v20509);
    var ngTranscludeMinErr = minErr('ngTransclude');
    const v20547 = function ($compile) {
        const v20545 = function ngTranscludeCompile(tElement) {
            const v20510 = tElement.contents();
            var fallbackLinkFn = $compile(v20510);
            const v20511 = tElement.empty();
            v20511;
            const v20544 = function ngTranscludePostLink($scope, $element, $attrs, controller, $transclude) {
                const v20512 = !$transclude;
                if (v20512) {
                    const v20513 = 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ';
                    const v20514 = v20513 + 'Element: {0}';
                    const v20515 = startingTag($element);
                    const v20516 = ngTranscludeMinErr('orphan', v20514, v20515);
                    throw v20516;
                }
                const v20517 = $attrs.ngTransclude;
                const v20518 = $attrs.$attr;
                const v20519 = v20518.ngTransclude;
                const v20520 = v20517 === v20519;
                if (v20520) {
                    $attrs.ngTransclude = '';
                }
                const v20521 = $attrs.ngTransclude;
                const v20522 = $attrs.ngTranscludeSlot;
                var slotName = v20521 || v20522;
                const v20523 = $transclude(ngTranscludeCloneAttachFn, null, slotName);
                v20523;
                const v20524 = $transclude.isSlotFilled(slotName);
                const v20525 = !v20524;
                const v20526 = slotName && v20525;
                if (v20526) {
                    const v20527 = useFallbackContent();
                    v20527;
                }
                const ngTranscludeCloneAttachFn = function (clone, transcludedScope) {
                    const v20528 = clone.length;
                    const v20529 = notWhitespace(clone);
                    const v20530 = v20528 && v20529;
                    if (v20530) {
                        const v20531 = $element.append(clone);
                        v20531;
                    } else {
                        const v20532 = useFallbackContent();
                        v20532;
                        const v20533 = transcludedScope.$destroy();
                        v20533;
                    }
                };
                const useFallbackContent = function () {
                    const v20535 = function (clone) {
                        const v20534 = $element.append(clone);
                        v20534;
                    };
                    const v20536 = fallbackLinkFn($scope, v20535);
                    v20536;
                };
                const notWhitespace = function (nodes) {
                    var i = 0;
                    var ii = nodes.length;
                    let v20537 = i < ii;
                    while (v20537) {
                        var node = nodes[i];
                        const v20539 = node.nodeType;
                        const v20540 = v20539 !== NODE_TYPE_TEXT;
                        const v20541 = node.nodeValue;
                        const v20542 = v20541.trim();
                        const v20543 = v20540 || v20542;
                        if (v20543) {
                            return true;
                        }
                        const v20538 = i++;
                        v20537 = i < ii;
                    }
                };
            };
            return v20544;
        };
        const v20546 = {};
        v20546.restrict = 'EAC';
        v20546.compile = v20545;
        return v20546;
    };
    var ngTranscludeDirective = [
        '$compile',
        v20547
    ];
    const v20554 = function ($templateCache) {
        const v20552 = function (element, attr) {
            const v20548 = attr.type;
            const v20549 = v20548 === 'text/ng-template';
            if (v20549) {
                var templateUrl = attr.id;
                const v20550 = element[0];
                var text = v20550.text;
                const v20551 = $templateCache.put(templateUrl, text);
                v20551;
            }
        };
        const v20553 = {};
        v20553.restrict = 'E';
        v20553.terminal = true;
        v20553.compile = v20552;
        return v20553;
    };
    var scriptDirective = [
        '$templateCache',
        v20554
    ];
    var noopNgModelController = {};
    noopNgModelController.$setViewValue = noop;
    noopNgModelController.$render = noop;
    const setOptionSelectedStatus = function (optionEl, value) {
        const v20555 = optionEl.prop('selected', value);
        v20555;
        const v20556 = optionEl.attr('selected', value);
        v20556;
    };
    const v20740 = function ($element, $scope) {
        var self = this;
        var optionsMap = new NgMap();
        const v20557 = {};
        self.selectValueMap = v20557;
        self.ngModelCtrl = noopNgModelController;
        self.multiple = false;
        const v20558 = window.document;
        const v20559 = v20558.createElement('option');
        const v20560 = jqLite(v20559);
        self.unknownOption = v20560;
        self.hasEmptyOption = false;
        self.emptyOption = undefined;
        const v20568 = function (val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            const v20561 = self.unknownOption;
            const v20562 = v20561.val(unknownVal);
            v20562;
            const v20563 = self.unknownOption;
            const v20564 = $element.prepend(v20563);
            v20564;
            const v20565 = self.unknownOption;
            const v20566 = setOptionSelectedStatus(v20565, true);
            v20566;
            const v20567 = $element.val(unknownVal);
            v20567;
        };
        self.renderUnknownOption = v20568;
        const v20574 = function (val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            const v20569 = self.unknownOption;
            const v20570 = v20569.val(unknownVal);
            v20570;
            const v20571 = self.unknownOption;
            const v20572 = setOptionSelectedStatus(v20571, true);
            v20572;
            const v20573 = $element.val(unknownVal);
            v20573;
        };
        self.updateUnknownOption = v20574;
        const v20578 = function (val) {
            const v20575 = hashKey(val);
            const v20576 = '? ' + v20575;
            const v20577 = v20576 + ' ?';
            return v20577;
        };
        self.generateUnknownOptionValue = v20578;
        const v20583 = function () {
            const v20579 = self.unknownOption;
            const v20580 = v20579.parent();
            if (v20580) {
                const v20581 = self.unknownOption;
                const v20582 = v20581.remove();
                v20582;
            }
        };
        self.removeUnknownOption = v20583;
        const v20588 = function () {
            const v20584 = self.emptyOption;
            if (v20584) {
                const v20585 = $element.val('');
                v20585;
                const v20586 = self.emptyOption;
                const v20587 = setOptionSelectedStatus(v20586, true);
                v20587;
            }
        };
        self.selectEmptyOption = v20588;
        const v20592 = function () {
            const v20589 = self.hasEmptyOption;
            if (v20589) {
                const v20590 = self.emptyOption;
                const v20591 = setOptionSelectedStatus(v20590, false);
                v20591;
            }
        };
        self.unselectEmptyOption = v20592;
        const v20593 = function () {
            self.renderUnknownOption = noop;
        };
        const v20594 = $scope.$on('$destroy', v20593);
        v20594;
        const readSingleValue = function () {
            var val = $element.val();
            let realVal;
            const v20595 = self.selectValueMap;
            const v20596 = val in v20595;
            const v20597 = self.selectValueMap;
            const v20598 = v20597[val];
            if (v20596) {
                realVal = v20598;
            } else {
                realVal = val;
            }
            const v20599 = self.hasOption(realVal);
            if (v20599) {
                return realVal;
            }
            return null;
        };
        self.readValue = readSingleValue;
        const writeSingleValue = function (value) {
            const v20600 = $element[0];
            const v20601 = v20600.options;
            const v20602 = $element[0];
            const v20603 = v20602.selectedIndex;
            var currentlySelectedOption = v20601[v20603];
            if (currentlySelectedOption) {
                const v20604 = jqLite(currentlySelectedOption);
                const v20605 = setOptionSelectedStatus(v20604, false);
                v20605;
            }
            const v20606 = self.hasOption(value);
            if (v20606) {
                const v20607 = self.removeUnknownOption();
                v20607;
                var hashedVal = hashKey(value);
                const v20608 = self.selectValueMap;
                const v20609 = hashedVal in v20608;
                let v20610;
                if (v20609) {
                    v20610 = hashedVal;
                } else {
                    v20610 = value;
                }
                const v20611 = $element.val(v20610);
                v20611;
                const v20612 = $element[0];
                const v20613 = v20612.options;
                const v20614 = $element[0];
                const v20615 = v20614.selectedIndex;
                var selectedOption = v20613[v20615];
                const v20616 = jqLite(selectedOption);
                const v20617 = setOptionSelectedStatus(v20616, true);
                v20617;
            } else {
                const v20618 = self.selectUnknownOrEmptyOption(value);
                v20618;
            }
        };
        self.writeValue = writeSingleValue;
        const v20628 = function (value, element) {
            const v20619 = element[0];
            const v20620 = v20619.nodeType;
            const v20621 = v20620 === NODE_TYPE_COMMENT;
            if (v20621) {
                return;
            }
            const v20622 = assertNotHasOwnProperty(value, '"option value"');
            v20622;
            const v20623 = value === '';
            if (v20623) {
                self.hasEmptyOption = true;
                self.emptyOption = element;
            }
            const v20624 = optionsMap.get(value);
            var count = v20624 || 0;
            const v20625 = count + 1;
            const v20626 = optionsMap.set(value, v20625);
            v20626;
            const v20627 = scheduleRender();
            v20627;
        };
        self.addOption = v20628;
        const v20634 = function (value) {
            var count = optionsMap.get(value);
            if (count) {
                const v20629 = count === 1;
                if (v20629) {
                    const v20630 = optionsMap.delete(value);
                    v20630;
                    const v20631 = value === '';
                    if (v20631) {
                        self.hasEmptyOption = false;
                        self.emptyOption = undefined;
                    }
                } else {
                    const v20632 = count - 1;
                    const v20633 = optionsMap.set(value, v20632);
                    v20633;
                }
            }
        };
        self.removeOption = v20634;
        const v20638 = function (value) {
            const v20635 = optionsMap.get(value);
            const v20636 = !v20635;
            const v20637 = !v20636;
            return v20637;
        };
        self.hasOption = v20638;
        const v20640 = function () {
            const v20639 = self.hasEmptyOption;
            return v20639;
        };
        self.$hasEmptyOption = v20640;
        const v20647 = function () {
            const v20641 = $element[0];
            const v20642 = v20641.options;
            const v20643 = v20642[0];
            const v20644 = self.unknownOption;
            const v20645 = v20644[0];
            const v20646 = v20643 === v20645;
            return v20646;
        };
        self.$isUnknownOptionSelected = v20647;
        const v20658 = function () {
            const v20648 = self.hasEmptyOption;
            const v20649 = $element[0];
            const v20650 = v20649.options;
            const v20651 = $element[0];
            const v20652 = v20651.selectedIndex;
            const v20653 = v20650[v20652];
            const v20654 = self.emptyOption;
            const v20655 = v20654[0];
            const v20656 = v20653 === v20655;
            const v20657 = v20648 && v20656;
            return v20657;
        };
        self.$isEmptyOptionSelected = v20658;
        const v20669 = function (value) {
            const v20659 = value == null;
            const v20660 = self.emptyOption;
            const v20661 = v20659 && v20660;
            if (v20661) {
                const v20662 = self.removeUnknownOption();
                v20662;
                const v20663 = self.selectEmptyOption();
                v20663;
            } else {
                const v20664 = self.unknownOption;
                const v20665 = v20664.parent();
                const v20666 = v20665.length;
                if (v20666) {
                    const v20667 = self.updateUnknownOption(value);
                    v20667;
                } else {
                    const v20668 = self.renderUnknownOption(value);
                    v20668;
                }
            }
        };
        self.selectUnknownOrEmptyOption = v20669;
        var renderScheduled = false;
        const scheduleRender = function () {
            if (renderScheduled) {
                return;
            }
            renderScheduled = true;
            const v20672 = function () {
                renderScheduled = false;
                const v20670 = self.ngModelCtrl;
                const v20671 = v20670.$render();
                v20671;
            };
            const v20673 = $scope.$$postDigest(v20672);
            v20673;
        };
        var updateScheduled = false;
        const scheduleViewValueUpdate = function (renderAfter) {
            if (updateScheduled) {
                return;
            }
            updateScheduled = true;
            const v20680 = function () {
                const v20674 = $scope.$$destroyed;
                if (v20674) {
                    return;
                }
                updateScheduled = false;
                const v20675 = self.ngModelCtrl;
                const v20676 = self.readValue();
                const v20677 = v20675.$setViewValue(v20676);
                v20677;
                if (renderAfter) {
                    const v20678 = self.ngModelCtrl;
                    const v20679 = v20678.$render();
                    v20679;
                }
            };
            const v20681 = $scope.$$postDigest(v20680);
            v20681;
        };
        const v20739 = function (optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
            const v20682 = optionAttrs.$attr;
            const v20683 = v20682.ngValue;
            if (v20683) {
                var oldVal;
                var hashedVal;
                const v20694 = function valueAttributeObserveAction(newVal) {
                    var removal;
                    var previouslySelected = optionElement.prop('selected');
                    const v20684 = isDefined(hashedVal);
                    if (v20684) {
                        const v20685 = self.removeOption(oldVal);
                        v20685;
                        const v20686 = self.selectValueMap;
                        const v20687 = v20686[hashedVal];
                        const v20688 = delete v20687;
                        v20688;
                        removal = true;
                    }
                    hashedVal = hashKey(newVal);
                    oldVal = newVal;
                    const v20689 = self.selectValueMap;
                    v20689[hashedVal] = newVal;
                    const v20690 = self.addOption(newVal, optionElement);
                    v20690;
                    const v20691 = optionElement.attr('value', hashedVal);
                    v20691;
                    const v20692 = removal && previouslySelected;
                    if (v20692) {
                        const v20693 = scheduleViewValueUpdate();
                        v20693;
                    }
                };
                const v20695 = optionAttrs.$observe('value', v20694);
                v20695;
            } else {
                if (interpolateValueFn) {
                    const v20702 = function valueAttributeObserveAction(newVal) {
                        const v20696 = self.readValue();
                        v20696;
                        var removal;
                        var previouslySelected = optionElement.prop('selected');
                        const v20697 = isDefined(oldVal);
                        if (v20697) {
                            const v20698 = self.removeOption(oldVal);
                            v20698;
                            removal = true;
                        }
                        oldVal = newVal;
                        const v20699 = self.addOption(newVal, optionElement);
                        v20699;
                        const v20700 = removal && previouslySelected;
                        if (v20700) {
                            const v20701 = scheduleViewValueUpdate();
                            v20701;
                        }
                    };
                    const v20703 = optionAttrs.$observe('value', v20702);
                    v20703;
                } else {
                    if (interpolateTextFn) {
                        const v20710 = function interpolateWatchAction(newVal, oldVal) {
                            const v20704 = optionAttrs.$set('value', newVal);
                            v20704;
                            var previouslySelected = optionElement.prop('selected');
                            const v20705 = oldVal !== newVal;
                            if (v20705) {
                                const v20706 = self.removeOption(oldVal);
                                v20706;
                            }
                            const v20707 = self.addOption(newVal, optionElement);
                            v20707;
                            const v20708 = oldVal && previouslySelected;
                            if (v20708) {
                                const v20709 = scheduleViewValueUpdate();
                                v20709;
                            }
                        };
                        const v20711 = optionScope.$watch(interpolateTextFn, v20710);
                        v20711;
                    } else {
                        const v20712 = optionAttrs.value;
                        const v20713 = self.addOption(v20712, optionElement);
                        v20713;
                    }
                }
            }
            const v20724 = function (newVal) {
                const v20714 = newVal === 'true';
                const v20715 = optionElement.prop('selected');
                const v20716 = newVal && v20715;
                const v20717 = v20714 || v20716;
                if (v20717) {
                    const v20718 = self.multiple;
                    if (v20718) {
                        const v20719 = scheduleViewValueUpdate(true);
                        v20719;
                    } else {
                        const v20720 = self.ngModelCtrl;
                        const v20721 = v20720.$setViewValue(null);
                        v20721;
                        const v20722 = self.ngModelCtrl;
                        const v20723 = v20722.$render();
                        v20723;
                    }
                }
            };
            const v20725 = optionAttrs.$observe('disabled', v20724);
            v20725;
            const v20737 = function () {
                var currentValue = self.readValue();
                var removeValue = optionAttrs.value;
                const v20726 = self.removeOption(removeValue);
                v20726;
                const v20727 = scheduleRender();
                v20727;
                const v20728 = self.multiple;
                const v20729 = v20728 && currentValue;
                const v20730 = currentValue.indexOf(removeValue);
                const v20731 = -1;
                const v20732 = v20730 !== v20731;
                const v20733 = v20729 && v20732;
                const v20734 = currentValue === removeValue;
                const v20735 = v20733 || v20734;
                if (v20735) {
                    const v20736 = scheduleViewValueUpdate(true);
                    v20736;
                }
            };
            const v20738 = optionElement.on('$destroy', v20737);
            v20738;
        };
        self.registerOption = v20739;
    };
    var SelectController = [
        '$element',
        '$scope',
        v20740
    ];
    var selectDirective = function () {
        const v20741 = [
            'select',
            '?ngModel'
        ];
        const v20742 = {};
        v20742.pre = selectPreLink;
        v20742.post = selectPostLink;
        const v20743 = {};
        v20743.restrict = 'E';
        v20743.require = v20741;
        v20743.controller = SelectController;
        v20743.priority = 1;
        v20743.link = v20742;
        return v20743;
        const selectPreLink = function (scope, element, attr, ctrls) {
            var selectCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1];
            const v20744 = !ngModelCtrl;
            if (v20744) {
                selectCtrl.registerOption = noop;
                return;
            }
            selectCtrl.ngModelCtrl = ngModelCtrl;
            const v20750 = function () {
                const v20745 = selectCtrl.removeUnknownOption();
                v20745;
                const v20748 = function () {
                    const v20746 = selectCtrl.readValue();
                    const v20747 = ngModelCtrl.$setViewValue(v20746);
                    v20747;
                };
                const v20749 = scope.$apply(v20748);
                v20749;
            };
            const v20751 = element.on('change', v20750);
            v20751;
            const v20752 = attr.multiple;
            if (v20752) {
                selectCtrl.multiple = true;
                const readMultipleValue = function () {
                    var array = [];
                    const v20753 = element.find('option');
                    const v20764 = function (option) {
                        const v20754 = option.selected;
                        const v20755 = option.disabled;
                        const v20756 = !v20755;
                        const v20757 = v20754 && v20756;
                        if (v20757) {
                            var val = option.value;
                            const v20758 = selectCtrl.selectValueMap;
                            const v20759 = val in v20758;
                            const v20760 = selectCtrl.selectValueMap;
                            const v20761 = v20760[val];
                            let v20762;
                            if (v20759) {
                                v20762 = v20761;
                            } else {
                                v20762 = val;
                            }
                            const v20763 = array.push(v20762);
                            v20763;
                        }
                    };
                    const v20765 = forEach(v20753, v20764);
                    v20765;
                    return array;
                };
                selectCtrl.readValue = readMultipleValue;
                const writeMultipleValue = function (value) {
                    const v20766 = element.find('option');
                    const v20779 = function (option) {
                        const v20767 = !value;
                        const v20768 = !v20767;
                        const v20769 = option.value;
                        const v20770 = includes(value, v20769);
                        const v20771 = selectCtrl.selectValueMap;
                        const v20772 = option.value;
                        const v20773 = v20771[v20772];
                        const v20774 = includes(value, v20773);
                        const v20775 = v20770 || v20774;
                        var shouldBeSelected = v20768 && v20775;
                        var currentlySelected = option.selected;
                        const v20776 = shouldBeSelected !== currentlySelected;
                        if (v20776) {
                            const v20777 = jqLite(option);
                            const v20778 = setOptionSelectedStatus(v20777, shouldBeSelected);
                            v20778;
                        }
                    };
                    const v20780 = forEach(v20766, v20779);
                    v20780;
                };
                selectCtrl.writeValue = writeMultipleValue;
                var lastView;
                var lastViewRef = NaN;
                const v20789 = function selectMultipleWatch() {
                    const v20781 = ngModelCtrl.$viewValue;
                    const v20782 = lastViewRef === v20781;
                    const v20783 = ngModelCtrl.$viewValue;
                    const v20784 = equals(lastView, v20783);
                    const v20785 = !v20784;
                    const v20786 = v20782 && v20785;
                    if (v20786) {
                        const v20787 = ngModelCtrl.$viewValue;
                        lastView = shallowCopy(v20787);
                        const v20788 = ngModelCtrl.$render();
                        v20788;
                    }
                    lastViewRef = ngModelCtrl.$viewValue;
                };
                const v20790 = scope.$watch(v20789);
                v20790;
                const v20795 = function (value) {
                    const v20791 = !value;
                    const v20792 = value.length;
                    const v20793 = v20792 === 0;
                    const v20794 = v20791 || v20793;
                    return v20794;
                };
                ngModelCtrl.$isEmpty = v20795;
            }
        };
        const selectPostLink = function (scope, element, attrs, ctrls) {
            var ngModelCtrl = ctrls[1];
            const v20796 = !ngModelCtrl;
            if (v20796) {
                return;
            }
            var selectCtrl = ctrls[0];
            const v20799 = function () {
                const v20797 = ngModelCtrl.$viewValue;
                const v20798 = selectCtrl.writeValue(v20797);
                v20798;
            };
            ngModelCtrl.$render = v20799;
        };
    };
    const v20816 = function ($interpolate) {
        const v20814 = function (element, attr) {
            var interpolateValueFn;
            var interpolateTextFn;
            const v20800 = attr.ngValue;
            const v20801 = isDefined(v20800);
            if (v20801) {
            } else {
                const v20802 = attr.value;
                const v20803 = isDefined(v20802);
                if (v20803) {
                    const v20804 = attr.value;
                    interpolateValueFn = $interpolate(v20804, true);
                } else {
                    const v20805 = element.text();
                    interpolateTextFn = $interpolate(v20805, true);
                    const v20806 = !interpolateTextFn;
                    if (v20806) {
                        const v20807 = element.text();
                        const v20808 = attr.$set('value', v20807);
                        v20808;
                    }
                }
            }
            const v20813 = function (scope, element, attr) {
                var selectCtrlName = '$selectController';
                var parent = element.parent();
                const v20809 = parent.data(selectCtrlName);
                const v20810 = parent.parent();
                const v20811 = v20810.data(selectCtrlName);
                var selectCtrl = v20809 || v20811;
                if (selectCtrl) {
                    const v20812 = selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                    v20812;
                }
            };
            return v20813;
        };
        const v20815 = {};
        v20815.restrict = 'E';
        v20815.priority = 100;
        v20815.compile = v20814;
        return v20815;
    };
    var optionDirective = [
        '$interpolate',
        v20816
    ];
    const v20836 = function ($parse) {
        const v20834 = function (scope, elm, attr, ctrl) {
            const v20817 = !ctrl;
            if (v20817) {
                return;
            }
            const v20818 = attr.hasOwnProperty('required');
            const v20819 = attr.ngRequired;
            const v20820 = $parse(v20819);
            const v20821 = v20820(scope);
            var value = v20818 || v20821;
            const v20822 = attr.ngRequired;
            const v20823 = !v20822;
            if (v20823) {
                attr.required = true;
            }
            const v20824 = ctrl.$validators;
            const v20829 = function (modelValue, viewValue) {
                const v20825 = !value;
                const v20826 = ctrl.$isEmpty(viewValue);
                const v20827 = !v20826;
                const v20828 = v20825 || v20827;
                return v20828;
            };
            v20824.required = v20829;
            const v20832 = function (newVal) {
                const v20830 = value !== newVal;
                if (v20830) {
                    value = newVal;
                    const v20831 = ctrl.$validate();
                    v20831;
                }
            };
            const v20833 = attr.$observe('required', v20832);
            v20833;
        };
        const v20835 = {};
        v20835.restrict = 'A';
        v20835.require = '?ngModel';
        v20835.link = v20834;
        return v20835;
    };
    var requiredDirective = [
        '$parse',
        v20836
    ];
    const v20867 = function ($parse) {
        const v20865 = function (tElm, tAttr) {
            var patternExp;
            var parseFn;
            const v20837 = tAttr.ngPattern;
            if (v20837) {
                patternExp = tAttr.ngPattern;
                const v20838 = tAttr.ngPattern;
                const v20839 = v20838.charAt(0);
                const v20840 = v20839 === '/';
                const v20841 = tAttr.ngPattern;
                const v20842 = REGEX_STRING_REGEXP.test(v20841);
                const v20843 = v20840 && v20842;
                if (v20843) {
                    const v20845 = function () {
                        const v20844 = tAttr.ngPattern;
                        return v20844;
                    };
                    parseFn = v20845;
                } else {
                    const v20846 = tAttr.ngPattern;
                    parseFn = $parse(v20846);
                }
            }
            const v20864 = function (scope, elm, attr, ctrl) {
                const v20847 = !ctrl;
                if (v20847) {
                    return;
                }
                var attrVal = attr.pattern;
                const v20848 = attr.ngPattern;
                if (v20848) {
                    attrVal = parseFn(scope);
                } else {
                    patternExp = attr.pattern;
                }
                var regexp = parsePatternAttr(attrVal, patternExp, elm);
                const v20855 = function (newVal) {
                    var oldRegexp = regexp;
                    regexp = parsePatternAttr(newVal, patternExp, elm);
                    const v20849 = oldRegexp.toString();
                    const v20850 = oldRegexp && v20849;
                    const v20851 = regexp.toString();
                    const v20852 = regexp && v20851;
                    const v20853 = v20850 !== v20852;
                    if (v20853) {
                        const v20854 = ctrl.$validate();
                        v20854;
                    }
                };
                const v20856 = attr.$observe('pattern', v20855);
                v20856;
                const v20857 = ctrl.$validators;
                const v20863 = function (modelValue, viewValue) {
                    const v20858 = ctrl.$isEmpty(viewValue);
                    const v20859 = isUndefined(regexp);
                    const v20860 = v20858 || v20859;
                    const v20861 = regexp.test(viewValue);
                    const v20862 = v20860 || v20861;
                    return v20862;
                };
                v20857.pattern = v20863;
            };
            return v20864;
        };
        const v20866 = {};
        v20866.restrict = 'A';
        v20866.require = '?ngModel';
        v20866.compile = v20865;
        return v20866;
    };
    var patternDirective = [
        '$parse',
        v20867
    ];
    const v20887 = function ($parse) {
        const v20885 = function (scope, elm, attr, ctrl) {
            const v20868 = !ctrl;
            if (v20868) {
                return;
            }
            const v20869 = attr.maxlength;
            const v20870 = attr.ngMaxlength;
            const v20871 = $parse(v20870);
            const v20872 = v20871(scope);
            var maxlength = v20869 || v20872;
            var maxlengthParsed = parseLength(maxlength);
            const v20875 = function (value) {
                const v20873 = maxlength !== value;
                if (v20873) {
                    maxlengthParsed = parseLength(value);
                    maxlength = value;
                    const v20874 = ctrl.$validate();
                    v20874;
                }
            };
            const v20876 = attr.$observe('maxlength', v20875);
            v20876;
            const v20877 = ctrl.$validators;
            const v20884 = function (modelValue, viewValue) {
                const v20878 = maxlengthParsed < 0;
                const v20879 = ctrl.$isEmpty(viewValue);
                const v20880 = v20878 || v20879;
                const v20881 = viewValue.length;
                const v20882 = v20881 <= maxlengthParsed;
                const v20883 = v20880 || v20882;
                return v20883;
            };
            v20877.maxlength = v20884;
        };
        const v20886 = {};
        v20886.restrict = 'A';
        v20886.require = '?ngModel';
        v20886.link = v20885;
        return v20886;
    };
    var maxlengthDirective = [
        '$parse',
        v20887
    ];
    const v20909 = function ($parse) {
        const v20907 = function (scope, elm, attr, ctrl) {
            const v20888 = !ctrl;
            if (v20888) {
                return;
            }
            const v20889 = attr.minlength;
            const v20890 = attr.ngMinlength;
            const v20891 = $parse(v20890);
            const v20892 = v20891(scope);
            var minlength = v20889 || v20892;
            const v20893 = parseLength(minlength);
            const v20894 = -1;
            var minlengthParsed = v20893 || v20894;
            const v20899 = function (value) {
                const v20895 = minlength !== value;
                if (v20895) {
                    const v20896 = parseLength(value);
                    const v20897 = -1;
                    minlengthParsed = v20896 || v20897;
                    minlength = value;
                    const v20898 = ctrl.$validate();
                    v20898;
                }
            };
            const v20900 = attr.$observe('minlength', v20899);
            v20900;
            const v20901 = ctrl.$validators;
            const v20906 = function (modelValue, viewValue) {
                const v20902 = ctrl.$isEmpty(viewValue);
                const v20903 = viewValue.length;
                const v20904 = v20903 >= minlengthParsed;
                const v20905 = v20902 || v20904;
                return v20905;
            };
            v20901.minlength = v20906;
        };
        const v20908 = {};
        v20908.restrict = 'A';
        v20908.require = '?ngModel';
        v20908.link = v20907;
        return v20908;
    };
    var minlengthDirective = [
        '$parse',
        v20909
    ];
    const parsePatternAttr = function (regex, patternExp, elm) {
        const v20910 = !regex;
        if (v20910) {
            return undefined;
        }
        const v20911 = isString(regex);
        if (v20911) {
            const v20912 = '^' + regex;
            const v20913 = v20912 + '$';
            regex = new RegExp(v20913);
        }
        const v20914 = regex.test;
        const v20915 = !v20914;
        if (v20915) {
            const v20916 = minErr('ngPattern');
            const v20917 = startingTag(elm);
            const v20918 = v20916('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, v20917);
            throw v20918;
        }
        return regex;
    };
    const parseLength = function (val) {
        var intVal = toInt(val);
        const v20919 = isNumberNaN(intVal);
        const v20920 = -1;
        let v20921;
        if (v20919) {
            v20921 = v20920;
        } else {
            v20921 = intVal;
        }
        return v20921;
    };
    const v20922 = window.angular;
    const v20923 = v20922.bootstrap;
    if (v20923) {
        const v20924 = window.console;
        if (v20924) {
            const v20925 = console.log('WARNING: Tried to load AngularJS more than once.');
            v20925;
        }
        return;
    }
    const v20926 = bindJQuery();
    v20926;
    const v20927 = publishExternalAPI(angular);
    v20927;
    const v20928 = [];
    const v20963 = function ($provide) {
        var PLURAL_CATEGORY = {};
        PLURAL_CATEGORY.ZERO = 'zero';
        PLURAL_CATEGORY.ONE = 'one';
        PLURAL_CATEGORY.TWO = 'two';
        PLURAL_CATEGORY.FEW = 'few';
        PLURAL_CATEGORY.MANY = 'many';
        PLURAL_CATEGORY.OTHER = 'other';
        const getDecimals = function (n) {
            n = n + '';
            var i = n.indexOf('.');
            const v20929 = -1;
            const v20930 = i == v20929;
            const v20931 = n.length;
            const v20932 = v20931 - i;
            const v20933 = v20932 - 1;
            let v20934;
            if (v20930) {
                v20934 = 0;
            } else {
                v20934 = v20933;
            }
            return v20934;
        };
        const getVF = function (n, opt_precision) {
            var v = opt_precision;
            const v20935 = undefined === v;
            if (v20935) {
                const v20936 = getDecimals(n);
                v = Math.min(v20936, 3);
            }
            var base = Math.pow(10, v);
            const v20937 = n * base;
            const v20938 = v20937 | 0;
            var f = v20938 % base;
            const v20939 = {};
            v20939.v = v;
            v20939.f = f;
            return v20939;
        };
        const v20940 = [
            'AM',
            'PM'
        ];
        const v20941 = [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday'
        ];
        const v20942 = [
            'Before Christ',
            'Anno Domini'
        ];
        const v20943 = [
            'BC',
            'AD'
        ];
        const v20944 = [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
        ];
        const v20945 = [
            'Sun',
            'Mon',
            'Tue',
            'Wed',
            'Thu',
            'Fri',
            'Sat'
        ];
        const v20946 = [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec'
        ];
        const v20947 = [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
        ];
        const v20948 = [
            5,
            6
        ];
        const v20949 = {};
        v20949['AMPMS'] = v20940;
        v20949['DAY'] = v20941;
        v20949['ERANAMES'] = v20942;
        v20949['ERAS'] = v20943;
        v20949['FIRSTDAYOFWEEK'] = 6;
        v20949['MONTH'] = v20944;
        v20949['SHORTDAY'] = v20945;
        v20949['SHORTMONTH'] = v20946;
        v20949['STANDALONEMONTH'] = v20947;
        v20949['WEEKENDRANGE'] = v20948;
        v20949['fullDate'] = 'EEEE, MMMM d, y';
        v20949['longDate'] = 'MMMM d, y';
        v20949['medium'] = 'MMM d, y h:mm:ss a';
        v20949['mediumDate'] = 'MMM d, y';
        v20949['mediumTime'] = 'h:mm:ss a';
        v20949['short'] = 'M/d/yy h:mm a';
        v20949['shortDate'] = 'M/d/yy';
        v20949['shortTime'] = 'h:mm a';
        const v20950 = {
            'gSize': 3,
            'lgSize': 3,
            'maxFrac': 3,
            'minFrac': 0,
            'minInt': 1,
            'negPre': '-',
            'negSuf': '',
            'posPre': '',
            'posSuf': ''
        };
        const v20951 = {
            'gSize': 3,
            'lgSize': 3,
            'maxFrac': 2,
            'minFrac': 2,
            'minInt': 1,
            'negPre': '-\xA4',
            'negSuf': '',
            'posPre': '\xA4',
            'posSuf': ''
        };
        const v20952 = [
            v20950,
            v20951
        ];
        const v20953 = {};
        v20953['CURRENCY_SYM'] = '$';
        v20953['DECIMAL_SEP'] = '.';
        v20953['GROUP_SEP'] = ',';
        v20953['PATTERNS'] = v20952;
        const v20960 = function (n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            const v20954 = i == 1;
            const v20955 = vf.v;
            const v20956 = v20955 == 0;
            const v20957 = v20954 && v20956;
            if (v20957) {
                const v20958 = PLURAL_CATEGORY.ONE;
                return v20958;
            }
            const v20959 = PLURAL_CATEGORY.OTHER;
            return v20959;
        };
        const v20961 = {
            'DATETIME_FORMATS': v20949,
            'NUMBER_FORMATS': v20953,
            'id': 'en-us',
            'localeID': 'en_US',
            'pluralCat': v20960
        };
        const v20962 = $provide.value('$locale', v20961);
        v20962;
    };
    const v20964 = [
        '$provide',
        v20963
    ];
    const v20965 = angular.module('ngLocale', v20928, v20964);
    v20965;
    const v20968 = function () {
        const v20966 = window.document;
        const v20967 = angularInit(v20966, bootstrap);
        v20967;
    };
    const v20969 = jqLite(v20968);
    v20969;
};
const v20971 = v20970(window);
v20971;
const v20972 = window.angular;
const v20973 = v20972.$$csp();
const v20974 = v20973.noInlineStyle;
const v20975 = !v20974;
const v20976 = window.angular;
const v20977 = document.head;
const v20978 = v20976.element(v20977);
const v20979 = v20978.prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
const v20980 = v20975 && v20979;
v20980;