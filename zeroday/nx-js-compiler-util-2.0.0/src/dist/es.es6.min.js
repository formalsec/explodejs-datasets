const filters=new Map,limiters=new Map;function filter(a,b){if('string'!=typeof a)throw new TypeError('First argument must be a string.');if('function'!=typeof b)throw new TypeError('Second argument must be a function.');if(filters.has(a))throw new Error(`A filter named ${a} is already registered.`);filters.set(a,b)}function limiter(a,b){if('string'!=typeof a)throw new TypeError('First argument must be a string.');if('function'!=typeof b)throw new TypeError('Second argument must be a function.');if(limiters.has(a))throw new Error(`A limiter named ${a} is already registered.`);limiters.set(a,b)}function compileRawExpression(a){return new Function('context','tempVars',`const sandbox = $nxCompileToSandbox(context, tempVars)
    try { with (sandbox) { return ${a} } } catch (err) {
      if (!(err instanceof TypeError)) throw err
    }
    $nxClearSandbox()`)}function compileRawCode(a){return new Function('context','tempVars',`const sandbox = $nxCompileToSandbox(context, tempVars)
    with (sandbox) { ${a} }
    $nxClearSandbox()`)}const filterRegex=/(?:[^\|]|\|\|)+/g,limiterRegex=/(?:[^&]|&&)+/g,argsRegex=/\S+/g;function parseExpression(a){const b=a.match(filterRegex);if(1===b.length)return compileRawExpression(b[0]);const c={exec:compileRawExpression(b[0]),filters:[]};for(let d,e=1;e<b.length;e++){d=b[e].match(argsRegex);const a=d.shift(),f=filters.get(a);if(!f)throw new Error(`There is no filter named: ${a}.`);c.filters.push({effect:f,argExpressions:d.map(compileRawExpression)})}return c}function parseCode(a){const b=a.match(limiterRegex);if(1===b.length)return compileRawCode(b[0]);const c={exec:compileRawCode(b[0]),limiters:[]};for(let d=1;d<b.length;d++){const a=b[d].match(argsRegex),e=a.shift(),f=limiters.get(e);if(!f)throw new Error(`There is no limiter named: ${e}.`);c.limiters.push({effect:f,argExpressions:a.map(compileRawExpression)})}return c}const expressionCache=new Map,codeCache=new Map;function compileExpression(a){if('string'!=typeof a)throw new TypeError('First argument must be a string.');let b=expressionCache.get(a);return b||(b=parseExpression(a),expressionCache.set(a,b)),'function'==typeof b?b:function(a,c){let d=b.exec(a,c);for(let e of b.filters){const b=e.argExpressions.map(evaluateArgExpression,a);d=e.effect(d,...b)}return d}}function compileCode(a){if('string'!=typeof a)throw new TypeError('First argument must be a string.');let b=codeCache.get(a);if(b||(b=parseCode(a),codeCache.set(a,b)),'function'==typeof b)return b;const c={};return function(a,d){function e(){if(Object.assign(c,d),f<b.limiters.length){const d=b.limiters[f++],g=d.argExpressions.map(evaluateArgExpression,a);d.effect(e,c,...g)}else b.exec(a,d)}let f=0;e()}}function evaluateArgExpression(a){return a(this)}const hasHandler={has},allHandlers={has,get},globals=new Set;let temp,globalObj;'undefined'==typeof window?'undefined'==typeof global?'undefined'!=typeof self&&(globalObj=self):globalObj=global:globalObj=window,globalObj.$nxCompileToSandbox=toSandbox,globalObj.$nxClearSandbox=clearSandbox;function expose(...a){for(let b of a)globals.add(b)}function hide(...a){for(let b of a)globals.delete(b)}function hideAll(){globals.clear()}function has(a,b){return!globals.has(b)||b in a}function get(a,b){return b in temp?temp[b]:a[b]}function toSandbox(a,b){return b?(temp=b,new Proxy(a,allHandlers)):new Proxy(a,hasHandler)}function clearSandbox(){temp=void 0}export{compileExpression,compileCode,compileRawExpression,compileRawCode,expose,hide,hideAll,filters,limiters,filter,limiter};